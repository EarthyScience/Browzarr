(self.webpackChunk_N_E=self.webpackChunk_N_E||[]).push([[974],{1219:()=>{},1700:(e,t,n)=>{Promise.resolve().then(n.bind(n,5310))},3040:()=>{},3433:()=>{},5310:(e,t,n)=>{"use strict";n.d(t,{default:()=>$});var r=n(8049),i=n(5272),a=n(6773),o=n(3411),s=n(4981),l=n(2818),c=n(6251);n(8947);var u=n(3901);let m=e=>"string"==typeof e?e:Array.isArray(e)?e.join(", "):String(e),d=e=>{let{meta:t}=e,[n,i]=(0,s.useState)(!1),o=(0,l.on)((0,c.k)(e=>e.setVariable)),{slice:d,compress:h,setSlice:f,setCompress:p}=(0,l.SZ)((0,c.k)(e=>({slice:e.slice,compress:e.compress,setSlice:e.setSlice,setCompress:e.setCompress}))),[x,v]=(0,s.useState)(!1),g=(0,s.useMemo)(()=>t.totalSize?t.totalSize:0,[t]),y=(0,s.useMemo)(()=>t.shape?t.shape[0]:0,[t]),w=(0,s.useMemo)(()=>!!t.shape&&t.shape.length>2,[t]),S=(0,s.useMemo)(()=>{if(!w)return 0;let e=d[0]?d[0]:0,n=d[1]?d[1]:y,r=t.shape[2]/t.chunks[2]*(t.shape[1]/t.chunks[1])*t.chunkSize;return Math.ceil((n-e)/(t.chunks?t.chunks[0]:1))*r},[t,d]);return(0,s.useEffect)(()=>{S>1e8?v(!0):v(!1)},[S]),(0,r.jsxs)("div",{className:"meta-container max-w-sm md:max-w-md",style:{background:"var(--background)",border:"1px solid var(--border)",borderRadius:"8px",padding:"10px",marginBottom:"10px"},children:[(0,r.jsxs)("div",{className:"meta-info",children:[(0,r.jsx)("b",{children:"Long Name:"})," ","".concat(t.long_name),(0,r.jsx)("br",{}),(0,r.jsx)("br",{}),(0,r.jsx)("b",{children:"Shape:"})," ","[".concat(m(t.shape),"]"),(0,r.jsx)("br",{}),(0,r.jsx)("br",{}),w&&(0,r.jsxs)(r.Fragment,{children:[g>1e8&&(0,r.jsxs)(r.Fragment,{children:[(0,r.jsx)("div",{className:"flex justify-center",children:(0,r.jsx)("b",{children:"Select Data Range"})}),(0,r.jsxs)("div",{className:"w-full flex justify-between flex-col",children:[(0,r.jsx)(u.A,{range:!0,min:0,max:y,value:[d[0]?d[0]:0,d[1]?d[1]:y],step:1,onChange:e=>f(e)}),(0,r.jsxs)("div",{style:{display:"flex",justifyContent:"space-between",fontSize:12,marginTop:18},children:[(0,r.jsxs)("span",{children:["Min: ",(0,r.jsx)("br",{})," ",d[0]?d[0]:0]}),(0,r.jsxs)("span",{children:["Max: ",(0,r.jsx)("br",{})," ",d[1]?d[1]:y]})]})]})]}),(0,r.jsx)("b",{children:"Total Size: "}),"".concat((0,a.z3)(S)),(0,r.jsx)("br",{}),S<1e8&&(0,r.jsx)("span",{style:{background:"lightgreen",borderRadius:"3px",padding:"5px"},children:"Selected data will fit in memory"}),S>1e8&&S<2e8&&(0,r.jsx)("span",{style:{background:"sandybrown",borderRadius:"3px",padding:"5px"},children:"Data may not fit in memory"}),S>2e8&&(0,r.jsx)("span",{style:{background:"red",borderRadius:"3px",padding:"5px"},children:"Data will not fit in memory"})]})]}),(0,r.jsx)("button",{onClick:()=>o(t.name),children:(0,r.jsx)("b",{children:"Plot"})})]})},h=()=>{let{variables:e,zMeta:t,setVariable:n}=(0,l.on)((0,c.k)(e=>({variables:e.variables,zMeta:e.zMeta,setVariable:e.setVariable}))),[i,a]=(0,s.useState)(Math.floor(e.length/2)),[o,u]=(0,s.useState)(null),[m,h]=(0,s.useState)(82),f=(0,s.useRef)(null),p=(0,s.useRef)(0);function x(){let e=window.innerWidth;e<=480?h(42):e<=570?h(54):h(82)}return(0,s.useEffect)(()=>{let e=e=>{e.cancelable&&e.preventDefault()};return document.addEventListener("touchmove",e,{passive:!1}),()=>{document.removeEventListener("touchmove",e)}},[]),(0,s.useEffect)(()=>{if(e&&t){let n=e[i];u(t.find(e=>e.name===n))}},[i,e]),(0,s.useEffect)(()=>{let e=window.innerWidth;return e<=480?h(42):e<=570?h(54):h(82),window.addEventListener("resize",x)},[]),(0,r.jsxs)("div",{className:"scroll-container",onWheel:t=>{let n=i+(t.deltaY>0?1:-1);n>=0&&n<e.length&&a(n)},onTouchMove:t=>{let n=t.touches[0].clientY,r=f.current?f.current:n;if(f.current=n,p.current+=r-n,Math.abs(p.current)>=m){let t=i+(p.current>0?1:-1);t>=0&&t<e.length&&(a(t),p.current=0)}},onTouchEnd:()=>{f.current=null,p.current=0},children:[(0,r.jsx)("div",{className:"scroll-element",style:{transform:"translateY(calc(40% + ".concat(-i*m,"px))")},children:e.map((e,t)=>{let o=Math.abs(i-t);return(0,r.jsx)("div",{className:"scroll-item",style:{opacity:1-.3*o,fontWeight:i===t?"bold":"normal"},onClick:()=>a(t),onDoubleClick:()=>n(e),children:e},t)})}),o&&(0,r.jsx)(d,{meta:o})]})},f=" // by Jeran Poehls\r\n\r\nout vec3 vOrigin;\r\nout vec3 vDirection;\r\nout vec3 aPosition;\r\n\r\nout vec2 Vuv;\r\n\r\nvoid main() {\r\n    vec4 worldPos = modelViewMatrix * vec4( position, 1.0 );\r\n\r\n    aPosition = position; //Pass out position for sphere frag\r\n    vOrigin = vec3( inverse( modelMatrix ) * vec4( cameraPosition, 1.0 ) ).xyz;\r\n    vDirection = position - vOrigin;\r\n    Vuv = uv;\r\n    gl_Position = projectionMatrix * worldPos;\r\n}";var p=n(7542);let x=e=>{let{volTexture:t}=e,{shape:n,colormap:a,flipY:o}=(0,l.on)((0,c.k)(e=>({shape:e.shape,colormap:e.colormap,flipY:e.flipY}))),{valueRange:u,xRange:m,yRange:d,zRange:h,quality:x,animate:v,resetAnim:g,cScale:y,cOffset:w,useFragOpt:S}=(0,l.Ws)((0,c.k)(e=>({valueRange:e.valueRange,xRange:e.xRange,yRange:e.yRange,zRange:e.zRange,quality:e.quality,animate:e.animate,resetAnim:e.resetAnim,cScale:e.cScale,cOffset:e.cOffset,useFragOpt:e.useFragOpt}))),[C,b]=(0,s.useState)(0),j=(0,s.useMemo)(()=>new i.BKk({glslVersion:i.Wdf,uniforms:{map:{value:t},cmap:{value:a},cOffset:{value:w},cScale:{value:y},cameraPos:{value:new i.Pq0},threshold:{value:new i.I9Y(u[0],u[1])},scale:{value:n},flatBounds:{value:new i.IUQ(m[0],m[1],h[0],h[1])},vertBounds:{value:new i.I9Y(d[0]/n.x,d[1]/n.x)},steps:{value:x},animateProg:{value:C}},vertexShader:f,fragmentShader:S?"// by Jeran Poehls\r\nprecision highp float;\r\nprecision highp sampler3D;\r\n\r\nin vec3 vOrigin;\r\nin vec3 vDirection;\r\n\r\nout vec4 color;\r\n\r\nuniform sampler3D map;\r\nuniform sampler2D cmap;\r\n\r\nuniform float cOffset;\r\nuniform float cScale;\r\nuniform vec3 scale;\r\nuniform vec2 threshold;\r\nuniform float steps;\r\nuniform vec4 flatBounds;\r\nuniform vec2 vertBounds;\r\nuniform float animateProg;\r\n\r\nvec2 hitBox(vec3 orig, vec3 dir) {\r\n    vec3 box_min = vec3(-(scale * 0.5));\r\n    vec3 box_max = vec3(scale * 0.5);\r\n    vec3 inv_dir = 1.0 / dir;\r\n    vec3 tmin_tmp = (box_min - orig) * inv_dir;\r\n    vec3 tmax_tmp = (box_max - orig) * inv_dir;\r\n    vec3 tmin = min(tmin_tmp, tmax_tmp);\r\n    vec3 tmax = max(tmin_tmp, tmax_tmp);\r\n    float t0 = max(tmin.x, max(tmin.y, tmin.z));\r\n    float t1 = min(tmax.x, min(tmax.y, tmax.z));\r\n    return vec2(t0, t1);\r\n}\r\n\r\nfloat sample1( vec3 p ) {\r\n    return texture( map, p ).r;\r\n}\r\n\r\n#define epsilon 0.0001\r\n\r\nvoid main() {\r\n    vec3 rayDir = normalize(vDirection);\r\n    vec2 bounds = hitBox(vOrigin, rayDir);\r\n\r\n    if (bounds.x > bounds.y) discard;\r\n\r\n    bounds.x = max(bounds.x, 0.0);\r\n\r\n    vec3 p = vOrigin + bounds.x * rayDir;\r\n    vec3 inc = 1.0 / abs(rayDir);\r\n\r\n    //Step Sizes\r\n    float fineDelta = min(inc.x, min(inc.y, inc.z)) / steps;\r\n\r\n    float coarseDelta = min(inc.x, min(inc.y, inc.z))/50.;\r\n\r\n    float delta = fineDelta;\r\n\r\n    vec4 accumColor = vec4(0.0);\r\n    float alphaAcc = 0.0;\r\n\r\n    float t = bounds.x;\r\n    int countdown = 0;\r\n    bool useCoarseStep = false;\r\n\r\n    while (t < bounds.y) {\r\n        vec3 p = vOrigin + rayDir * t;\r\n        \r\n        // --- Boundary checks ---\r\n        if (p.x < flatBounds.x || p.x > flatBounds.y ||\r\n            p.z < flatBounds.z || p.z > flatBounds.w ||\r\n            p.y < vertBounds.x || p.y > vertBounds.y) {\r\n\r\n            t += useCoarseStep ? coarseDelta : fineDelta;\r\n            continue;\r\n        }\r\n\r\n        vec3 texCoord = p / scale + 0.5;\r\n        texCoord.z = mod(texCoord.z + animateProg, 1.0001);\r\n        float d = sample1(texCoord);\r\n\r\n        bool cond = (d > threshold.x) && (d < threshold.y);\r\n        \r\n        if (cond) {\r\n            // Hit something interesting - switch to fine stepping\r\n            if (useCoarseStep) {\r\n                useCoarseStep = false;\r\n                countdown = 40;\r\n                // Step back to ensure we don't miss the boundary\r\n                t -= coarseDelta;\r\n                continue;\r\n            }\r\n            float sampLoc = d == 1. ? d : (d - 0.5)*cScale + 0.5;\r\n            sampLoc = d == 1. ? d : min(sampLoc+cOffset,0.99);\r\n            vec4 col = texture(cmap, vec2(sampLoc, 0.5));\r\n            float alpha = float(col.a > 0.);\r\n\r\n            accumColor.rgb += (1.0 - alphaAcc) * alpha * col.rgb;\r\n            alphaAcc += alpha * (1.0 - alphaAcc);\r\n\r\n            if (alphaAcc >= 1.0) break;\r\n            \r\n            t += fineDelta;\r\n        }\r\n        else {\r\n            // Nothing interesting here\r\n            if (countdown > 0) {\r\n                countdown--;\r\n                t += fineDelta; // Continue with fine steps while countdown > 0\r\n            } else {\r\n                useCoarseStep = true;\r\n                t += coarseDelta; // Switch to coarse steps\r\n            }\r\n        }\r\n    }\r\n    accumColor.a = alphaAcc; // Set the final accumulated alpha\r\n    color = accumColor;\r\n    if (color.a == 0.0) discard;\r\n}\r\n":"// by Jeran Poehls\r\nprecision highp float;\r\nprecision highp sampler3D;\r\n\r\nin vec3 vOrigin;\r\nin vec3 vDirection;\r\n\r\nout vec4 color;\r\n\r\nuniform sampler3D map;\r\nuniform sampler2D cmap;\r\n\r\nuniform float cOffset;\r\nuniform float cScale;\r\nuniform vec3 scale;\r\nuniform vec2 threshold;\r\nuniform float steps;\r\nuniform vec4 flatBounds;\r\nuniform vec2 vertBounds;\r\nuniform float animateProg;\r\n\r\nvec2 hitBox(vec3 orig, vec3 dir) {\r\n    vec3 box_min = vec3(-(scale * 0.5));\r\n    vec3 box_max = vec3(scale * 0.5);\r\n    vec3 inv_dir = 1.0 / dir;\r\n    vec3 tmin_tmp = (box_min - orig) * inv_dir;\r\n    vec3 tmax_tmp = (box_max - orig) * inv_dir;\r\n    vec3 tmin = min(tmin_tmp, tmax_tmp);\r\n    vec3 tmax = max(tmin_tmp, tmax_tmp);\r\n    float t0 = max(tmin.x, max(tmin.y, tmin.z));\r\n    float t1 = min(tmax.x, min(tmax.y, tmax.z));\r\n    return vec2(t0, t1);\r\n}\r\n\r\nfloat sample1( vec3 p ) {\r\n    return texture( map, p ).r;\r\n}\r\n\r\n#define epsilon 0.0001\r\n\r\nvoid main() {\r\n    vec3 rayDir = normalize(vDirection);\r\n    vec2 bounds = hitBox(vOrigin, rayDir);\r\n\r\n    if (bounds.x > bounds.y) discard;\r\n\r\n    bounds.x = max(bounds.x, 0.0);\r\n\r\n    vec3 p = vOrigin + bounds.x * rayDir;\r\n    vec3 inc = 1.0 / abs(rayDir);\r\n    float delta = min(inc.x, min(inc.y, inc.z));\r\n    delta /= steps;\r\n    vec4 accumColor = vec4(0.0);\r\n    float alphaAcc = 0.0;\r\n\r\n    for (float t = bounds.x; t < bounds.y; t += delta) {\r\n        p = vOrigin + rayDir * t;\r\n        if (p.x > -flatBounds.x || p.x < -flatBounds.y) { \r\n            continue;\r\n        }\r\n        if (-p.z > -flatBounds.z || -p.z < -flatBounds.w) {\r\n            continue;\r\n        }\r\n        if (p.y < vertBounds.x || p.y > vertBounds.y) {\r\n            continue;\r\n        }\r\n\r\n        vec3 texCoord = p / scale + 0.5;\r\n        texCoord.z = mod(texCoord.z + animateProg, 1.0001);\r\n        float d = sample1(texCoord);\r\n\r\n        bool cond = (d > threshold.x) && (d < threshold.y);\r\n        \r\n        if (cond) {\r\n            float sampLoc = d == 1. ? d : (d - 0.5)*cScale + 0.5;\r\n            sampLoc = d == 1. ? d : min(sampLoc+cOffset,0.99);\r\n            vec4 col = texture(cmap, vec2(sampLoc, 0.5));\r\n            // Change this later back to use intensity then delete comment. Or maybe we don't need intensity\r\n            float alpha = float(col.a > 0.);\r\n\r\n            accumColor.rgb += (1.0 - alphaAcc) * alpha * col.rgb;\r\n            alphaAcc += alpha * (1.0 - alphaAcc);\r\n\r\n            if (alphaAcc >= 1.0) break;\r\n        }\r\n    }\r\n\r\n    accumColor.a = alphaAcc; // Set the final accumulated alpha\r\n    color = accumColor;\r\n    if (color.a == 0.0) discard;\r\n}\r\n",transparent:!0,blending:i.NTi,depthWrite:!1,side:i.hsX}),[t,a,w,y,u,m,d,h,x,C,S]),D=(0,s.useMemo)(()=>new i.WBB(2,4),[]);return(0,p.D)(()=>{v&&b((C+.001)%1)}),(0,s.useEffect)(()=>()=>{D.dispose()},[]),(0,s.useEffect)(()=>{b(0)},[g]),(0,r.jsx)(r.Fragment,{children:(0,r.jsx)("mesh",{geometry:D,scale:[1,o?-1:1,1],children:(0,r.jsx)("primitive",{attach:"material",object:j})})})};var v=n(4186);let g=e=>{let{ZarrDS:t}=e,[n,a]=(0,s.useState)(null),{setTimeSeries:o,setPlotDim:u,setDimCoords:m,updateTimeSeries:d,updateDimCoords:h}=(0,l.on)((0,c.k)(e=>({setTimeSeries:e.setTimeSeries,setPlotDim:e.setPlotDim,setDimCoords:e.setDimCoords,updateTimeSeries:e.updateTimeSeries,updateDimCoords:e.updateDimCoords}))),{shape:f,dimArrays:p,dimNames:x,dimUnits:g}=(0,l.on)((0,c.k)(e=>({shape:e.shape,dimArrays:e.dimArrays,dimNames:e.dimNames,dimUnits:e.dimUnits}))),y=(0,l.Ws)(e=>e.selectTS),w=(0,s.useRef)(null),S=(0,s.useMemo)(()=>new i.iNn(1,1,1),[]);return(0,s.useEffect)(()=>()=>{S.dispose()},[]),(0,r.jsxs)(r.Fragment,{children:[(0,r.jsx)("mesh",{geometry:S,scale:f,onClick:e=>{e.stopPropagation(),e.intersections.length>0&&y&&function(e){let n=e.point,r=e.uv,i=e.normal,s=(0,v._8)(i);if(s!=w.current&&(o({}),m({})),w.current=s,t){var l,c;let e=t.GetTimeSeries({uv:r,normal:i}),n=i.toArray().map((e,t)=>Math.abs(e)>0?t:null).filter(e=>null!==e);u(2-n[0]);let a=(0,v.jT)({normal:i,uv:r}).map((e,t)=>e?p[t][Math.round(e*p[t].length)]:null),o=x.filter((e,t)=>null!==a[t]),s=g.filter((e,t)=>null!==a[t]);a=a.filter(e=>null!==e);let m="".concat(a[0],"_").concat(a[1]);d({[m]:e}),h({[m]:{first:{name:o[0],loc:null!=(l=a[0])?l:0,units:s[0]},second:{name:o[1],loc:null!=(c=a[1])?c:0,units:s[1]},plot:{units:g[2-n[0]]}}})}a(n)}(e.intersections[0])},children:(0,r.jsx)("meshBasicMaterial",{transparent:!0,opacity:0})}),n&&(0,r.jsxs)("mesh",{position:n,scale:.01,children:[(0,r.jsx)("boxGeometry",{}),(0,r.jsx)("meshBasicMaterial",{color:"#ff0000"})]})]})},y=e=>{let{dimensions:t,ZarrDS:n,setters:i}=e,{width:a,height:o,depth:u}=t,{setPointIDs:m,setStride:d,setDimWidth:h}=i,f=(0,l.Ws)(e=>e.selectTS),p=a/o,x=u/o,{dimArrays:g,dimUnits:y,dimNames:w,strides:S,setPlotDim:C,setTimeSeries:b,updateTimeSeries:j,setDimCoords:D,updateDimCoords:M}=(0,l.on)((0,c.k)(e=>({dimArrays:e.dimArrays,dimUnits:e.dimUnits,dimNames:e.dimNames,strides:e.strides,setPlotDim:e.setPlotDim,setTimeSeries:e.setTimeSeries,updateTimeSeries:e.updateTimeSeries,setDimCoords:e.setDimCoords,updateDimCoords:e.updateDimCoords}))),P=(0,s.useRef)(null),z=(0,l.Ws)(e=>e.timeScale);return(0,r.jsxs)("mesh",{scale:[2*p,2,2*x*z],onClick:function(e){if(!f)return;let t=e.uv,r=e.normal,i=(0,v._8)(r);if(i!=P.current&&(b({}),D({}),m(Array(10).fill(-1))),P.current=i,n){var s,l;let e=n.GetTimeSeries({uv:t,normal:r}),i=r.toArray().map((e,t)=>Math.abs(e)>0?t:null).filter(e=>null!==e);C(2-i[0]);let c=(0,v.jT)({normal:r,uv:t}),f=c.map((e,t)=>e?g[t][Math.round(e*g[t].length-.5)]:null),p=w.filter((e,t)=>null!==f[t]),x=y.filter((e,t)=>null!==f[t]);f=f.filter(e=>null!==e);let b="".concat(f[0],"_").concat(f[1]);j({[b]:e}),M({[b]:{first:{name:p[0],loc:null!=(s=f[0])?s:0,units:x[0]},second:{name:p[1],loc:null!=(l=f[1])?l:0,units:x[1]},plot:{units:y[2-i[0]]}}});let D=[u,o,a].filter((e,t)=>null!=c[t]),P=[u,o,a].filter((e,t)=>null==c[t]),z=c.filter(e=>null!=e),A=S.filter((e,t)=>null!=c[t]),V=Math.round(z[0]*D[0]-.5),k=Math.round(z[1]*D[1]-.5),T=V*A[0]+k*A[1],R=S.filter((e,t)=>null==c[t]);h(P[0]),m(e=>[T,...e].slice(0,10)),d(R[0])}},children:[(0,r.jsx)("boxGeometry",{}),(0,r.jsx)("meshBasicMaterial",{transparent:!0,opacity:0})]})},w=e=>{let{textures:t,ZarrDS:n}=e,{texture:a,colormap:o}=t,u=(0,l.on)(e=>e.flipY),{scalePoints:m,scaleIntensity:d,pointSize:h,cScale:f,cOffset:x,valueRange:v,animate:g,resetAnim:w,selectTS:S,timeScale:C,xRange:b,yRange:j,zRange:D}=(0,l.Ws)((0,c.k)(e=>({scalePoints:e.scalePoints,scaleIntensity:e.scaleIntensity,pointSize:e.pointSize,cScale:e.cScale,cOffset:e.cOffset,valueRange:e.valueRange,animate:e.animate,resetAnim:e.resetAnim,selectTS:e.selectTS,timeScale:e.timeScale,xRange:e.xRange,yRange:e.yRange,zRange:e.zRange}))),[M,P]=(0,s.useState)(0),[z,A]=(0,s.useState)(Array(10).fill(-1)),[V,k]=(0,s.useState)(1),[T,R]=(0,s.useState)(0),{data:O,width:B,height:F,depth:N}=(0,s.useMemo)(()=>a instanceof i.dYF?{data:a.image.data,width:a.image.width,height:a.image.height,depth:a.image.depth}:(console.warn("Provided texture is not a Data3DTexture"),{data:[],width:0,height:0,depth:0}),[a]),_=(0,s.useMemo)(()=>B/F,[B,F]),U=(0,s.useMemo)(()=>N/F,[N,F]),{positions:L,values:W}=(0,s.useMemo)(()=>{let e=new Float32Array(N*F*B*3),t=new Uint8Array(N*F*B);for(let n=0;n<N;n++)for(let r=0;r<F;r++)for(let i=0;i<B;i++){let a=i+r*B+n*B*F,o=O[a]||0,s=(i/(B-1)-.5)*_,l=r/(F-1)-.5,c=(n/(N-1)-.5)*U,u=3*a;e[u]=2*s,e[u+1]=2*l,e[u+2]=2*c,t[a]=o}return{positions:e,values:t}},[O,B,F,N]),Y=(0,s.useMemo)(()=>{let e=new i.LoY;return e.setAttribute("position",new i.qtW(L,3)),e.setAttribute("value",new i.qtW(W,1)),e},[L,W]),E=(0,s.useMemo)(()=>new i.BKk({glslVersion:i.Wdf,uniforms:{pointSize:{value:h},cmap:{value:o},cOffset:{value:x},cScale:{value:f},valueRange:{value:new i.I9Y(v[0],v[1])},scalePoints:{value:m},scaleIntensity:{value:d},startIDs:{value:z},stride:{value:V},showTransect:{value:S},dimWidth:{value:T},timeScale:{value:C},animateProg:{value:M},depthRatio:{value:U},flatBounds:{value:new i.IUQ(b[0]*_,b[1]*_,D[0]*U,D[1]*U)},vertBounds:{value:new i.I9Y(j[0],j[1])}},vertexShader:"attribute float value;\r\nout float vValue;\r\n\r\nflat out int highlight;\r\n\r\nuniform float pointSize;\r\nuniform bool scalePoints;\r\nuniform float scaleIntensity;\r\nuniform vec2 valueRange;\r\nuniform int[10] startIDs;\r\nuniform int stride;\r\nuniform int dimWidth;\r\nuniform bool showTransect;\r\nuniform float timeScale;\r\nuniform float animateProg;\r\nuniform float depthRatio;\r\nuniform vec4 flatBounds;\r\nuniform vec2 vertBounds;\r\n\r\nbool isValidPoint(){\r\n    for (int i = 0; i < 10; i++){\r\n        if (startIDs[i] == -1){\r\n            return false;\r\n        }\r\n        int rePos = gl_VertexID - startIDs[i];\r\n        bool isValid = rePos % stride == 0;\r\n        bool secondary = gl_VertexID < (startIDs[i] + dimWidth*stride) && gl_VertexID > startIDs[i];\r\n        isValid = isValid && secondary;\r\n        if (isValid){\r\n            return true;\r\n        }\r\n    }\r\n    return false;\r\n}\r\n\r\nvoid main() {\r\n    vValue = value/255.;\r\n    vec3 scaledPos = position;\r\n    scaledPos.z += depthRatio;\r\n    scaledPos.z = mod(scaledPos.z + animateProg*depthRatio, 2.*depthRatio);\r\n    scaledPos.z -= depthRatio;\r\n\r\n    scaledPos.z *= timeScale;\r\n    gl_Position = projectionMatrix * modelViewMatrix * vec4(scaledPos, 1.0);\r\n    //If it is nan we just yeet it tf out of the screen space. LMAO I love this solution\r\n    float pointScale = pointSize/gl_Position.w;\r\n    pointScale = scalePoints ? pointScale*pow(vValue,scaleIntensity) : pointScale;\r\n\r\n    bool isValid = isValidPoint();\r\n    highlight = isValid ? 1 : 0;\r\n    \r\n    if (value == 255. || (pointScale*gl_Position.w < 0.75 && scalePoints)){ //Hide points that are invisible or get too small when scalled\r\n        gl_Position = vec4(2.0, 2.0, 2.0, 1.0);\r\n    }\r\n\r\n    if (vValue < valueRange.x || vValue > valueRange.y){ //Hide points that are outside of value range\r\n        gl_Position = vec4(2.0, 2.0, 2.0, 1.0);\r\n    }\r\n\r\n    bool xCheck = scaledPos.x < flatBounds.x || scaledPos.x > flatBounds.y;\r\n    bool zCheck = scaledPos.z < flatBounds.z || scaledPos.z > flatBounds.w;\r\n    bool yCheck = scaledPos.y < vertBounds.x || scaledPos.y> vertBounds.y;\r\n\r\n    if (xCheck || zCheck || yCheck){ //Hide points that are clipped\r\n        gl_Position = vec4(2.0, 2.0, 2.0, 1.0);\r\n    }\r\n    \r\n    if (showTransect){\r\n        gl_PointSize = isValid ? max(pointScale*5. , pointScale+80./gl_Position.w) : pointScale;\r\n    }\r\n    else{\r\n        gl_PointSize =  pointScale;\r\n    }\r\n\r\n}\r\n",fragmentShader:"out vec4 Color;\r\n\r\nin float vValue;\r\nflat in int highlight;\r\n\r\n\r\nuniform sampler2D cmap;\r\nuniform float cScale;\r\nuniform float cOffset;\r\nuniform bool showTransect;\r\n\r\nvoid main() {\r\n\r\n    float sampLoc = vValue == 1. ? vValue : (vValue - 0.5)*cScale + 0.5;\r\n    sampLoc = vValue == 1. ? vValue : min(sampLoc+cOffset,0.99);\r\n    vec4 color = texture(cmap, vec2(sampLoc, 0.5));\r\n    color.a = 1.;\r\n    Color = color;\r\n    if (showTransect){\r\n        Color = highlight == 1 ? color : color * vec4(vec3(0.4),1.);\r\n    }\r\n    else{\r\n        Color = color;\r\n    }\r\n\r\n}\r\n",depthWrite:!0,transparent:!0,blending:i.NTi,side:i.$EB}),[h,o,x,f,v,m,d,z,V,S,M,C,U,_,b,j,D]);return(0,p.D)(()=>{g&&P((M+.001)%1)}),(0,s.useEffect)(()=>{P(0)},[w]),(0,r.jsxs)(r.Fragment,{children:[(0,r.jsx)("mesh",{scale:[1,u?-1:1,1],children:(0,r.jsx)("points",{geometry:Y,material:E})}),(0,r.jsx)(y,{dimensions:{width:B,height:F,depth:N},ZarrDS:n,setters:{setPointIDs:A,setStride:k,setDimWidth:R}})]})};var S=n(6483),C=n(731);n(1219);var b=n(677);n(3040);var j=n(3662);let D=s.memo(function(){let{showPoints:e,linePointSize:t,pointColor:n,useCustomPointColor:i,setLinePointSize:a,setPointColor:o,setUseCustomPointColor:s}=(0,l.Ws)((0,c.k)(e=>({showPoints:e.showPoints,linePointSize:e.linePointSize,pointColor:e.pointColor,useCustomPointColor:e.useCustomPointColor,setLinePointSize:e.setLinePointSize,setPointColor:e.setPointColor,setUseCustomPointColor:e.setUseCustomPointColor})));return e?(0,r.jsxs)(r.Fragment,{children:[(0,r.jsxs)("div",{className:"w-full flex items-center",children:[(0,r.jsx)("div",{className:"w-[40%]",children:(0,r.jsx)("b",{children:"Point Size"})}),(0,r.jsx)("input",{type:"range",min:1,max:10,step:.1,value:t,onChange:e=>a(parseFloat(e.target.value))})]}),(0,r.jsxs)("div",{className:"w-full flex items-center",children:[(0,r.jsx)("div",{className:"w-[40%]",children:(0,r.jsx)("b",{children:"Point Color"})}),i&&(0,r.jsx)("input",{type:"color",title:"Point Color",value:n,onChange:e=>o(e.target.value)}),(0,r.jsxs)(b.$,{className:"h-8 px-2 py-1",variant:"outline",onClick:()=>s(!i),children:["Use",i?" Browzarr Color":" Custom Color"]})]})]}):null}),M=s.memo(function(){let{lineWidth:e,lineColor:t,useLineColor:n,lineResolution:i,useCustomColor:a,setLineWidth:o,setLineColor:s,setUseLineColor:u,setLineResolution:m,setUseCustomColor:d}=(0,l.Ws)((0,c.k)(e=>({lineWidth:e.lineWidth,lineColor:e.lineColor,useLineColor:e.useLineColor,lineResolution:e.lineResolution,useCustomColor:e.useCustomColor,setLineWidth:e.setLineWidth,setLineColor:e.setLineColor,setUseLineColor:e.setUseLineColor,setLineResolution:e.setLineResolution,setUseCustomColor:e.setUseCustomColor})));return(0,r.jsxs)(r.Fragment,{children:[(0,r.jsxs)("div",{className:"w-full flex items-center",children:[(0,r.jsx)("div",{className:"w-[40%]",children:(0,r.jsx)("b",{children:"Line Width"})}),(0,r.jsx)("input",{type:"range",min:1,max:10,step:.2,value:e,onChange:e=>o(parseFloat(e.target.value))})]}),(0,r.jsxs)("div",{className:"w-full flex items-center",children:[(0,r.jsx)("div",{className:"w-[40%]",children:(0,r.jsx)("b",{children:"Line Resolution"})}),(0,r.jsx)("input",{type:"range",min:1,max:10,step:1,value:i,onChange:e=>m(parseFloat(e.target.value))})]}),(0,r.jsxs)("div",{className:"w-full flex items-center",children:[(0,r.jsx)("div",{className:"w-[40%]",children:(0,r.jsx)("b",{children:"Line Color"})}),a&&(0,r.jsx)("input",{type:"color",title:"Line Color",value:t,onChange:e=>s(e.target.value)}),!a&&(0,r.jsxs)(b.$,{className:"h-8 px-2 py-5",variant:"outline",onClick:()=>u(!n),children:["Use ",(0,r.jsx)("br",{}),n?"Individual Color":"Plot Color"]}),(0,r.jsxs)(b.$,{className:"h-8 px-2 py-5",variant:"outline",onClick:()=>d(!a),children:["Use ",(0,r.jsx)("br",{}),a?"Browzarr Color":"Custom Color"]})]})]})}),P=s.memo(function(){let{showPoints:e,setShowPoints:t}=(0,l.Ws)((0,c.k)(e=>({showPoints:e.showPoints,setShowPoints:e.setShowPoints})));return(0,r.jsx)("div",{className:"plotline-options",children:(0,r.jsxs)(j.rI,{children:[(0,r.jsx)(j.ty,{asChild:!0,children:(0,r.jsx)(b.$,{className:"cursor-pointer",variant:"outline",children:"Line Options"})}),(0,r.jsxs)(j.SQ,{className:"w-80 items-center",align:"center",children:[(0,r.jsx)(j.I,{onClick:e=>e.preventDefault(),children:(0,r.jsx)(j._2,{children:(0,r.jsx)(b.$,{variant:"outline",onClick:n=>{n.preventDefault(),t(!e)},children:e?"Hide Points":"Show Points"})})}),(0,r.jsx)(D,{}),(0,r.jsx)(j.mB,{}),(0,r.jsx)(M,{})]})]})})});var z=n(6070),A=n(1020);function V(e){let{pointID:t,pointLoc:n,showPointInfo:i,plotUnits:a}=e,{plotDim:o,dimArrays:u,dimNames:m,dimUnits:d,timeSeries:h}=(0,l.on)((0,c.k)(e=>({plotDim:e.plotDim,dimArrays:e.dimArrays,dimNames:e.dimNames,dimUnits:e.dimUnits,timeSeries:e.timeSeries}))),f=0,p=0;if(Object.entries(t).length>0&&Object.entries(h).length>0){let[e,n]=Object.entries(t)[0];f=h[e][n],p=u[o][n]}let[x,g]=n,[y,w]=(0,s.useState)(!1);return(0,s.useEffect)(()=>{if(!i){let e=setTimeout(()=>{w(!1)},100);return()=>clearTimeout(e)}w(!0)},[i]),(0,r.jsx)(r.Fragment,{children:y&&(0,r.jsxs)("div",{className:"point-info",style:{left:"".concat(x,"px"),top:"".concat(g,"px")},children:["".concat(f.toFixed(2)).concat(a),(0,r.jsx)("br",{}),"".concat(m[o],": ").concat((0,v.SB)(p,d[o]),"       \n        ")]})})}function k(){let{coords:e,timeSeries:t,setDimCoords:n,setTimeSeries:i}=(0,l.on)((0,c.k)(e=>({coords:e.dimCoords,timeSeries:e.timeSeries,setDimCoords:e.setDimCoords,setTimeSeries:e.setTimeSeries}))),[a,o]=(0,s.useState)(!1),u=(0,s.useRef)([0,Math.round(.255*window.innerHeight)]),m=(0,s.useRef)([0,Math.round(.255*window.innerHeight)]),[d,h]=(0,s.useState)([0,Math.round(.255*window.innerHeight)]);function f(e){if(a){let t=u.current[0]-e.clientX,n=u.current[1]-e.clientY,r=Math.min(Math.max(m.current[0]-t,10),window.innerWidth-120),i=Math.max(m.current[1]+n,0);h([Math.min(r,window.innerWidth-100),Math.min(i,window.innerHeight-100)])}}function p(){o(!1)}return(0,s.useEffect)(()=>(a&&(document.addEventListener("mousemove",f),document.addEventListener("mouseup",p)),()=>{document.removeEventListener("mousemove",f),document.removeEventListener("mouseup",p)}),[a]),(0,r.jsx)(r.Fragment,{children:(0,r.jsx)("div",{className:"coord-container",onPointerDown:function(e){u.current=[e.clientX,e.clientY],m.current=[...d],o(!0)},onPointerMove:f,onPointerUp:()=>o(!1),style:{left:"".concat(d[0],"px"),bottom:"".concat(d[1],"px")},children:Object.keys(e).length>0&&Object.keys(e).map((a,o)=>(0,r.jsxs)("div",{className:"plot-coords",style:{background:"rgb(".concat((0,z.md)(o/10,"Paired"),")"),justifyContent:"space-between"},children:[(0,r.jsx)("b",{children:"".concat(e[a].first.name,": ")}),"".concat((0,v.SB)(e[a].first.loc,e[a].first.units)),(0,r.jsx)("br",{}),(0,r.jsx)("b",{children:"".concat(e[a].second.name,": ")}),"".concat((0,v.SB)(e[a].second.loc,e[a].second.units)),(0,r.jsx)(A.Xr4,{onClick:()=>(function(r){let{[r]:a,...o}=e;n(o);let{[r]:s,...l}=t;i(l)})(a),color:"red",style:{cursor:"pointer",zIndex:3}})]},a))})})}function T(){let[e,t]=(0,s.useState)({}),[n,i]=(0,s.useState)([0,0]),[a,o]=(0,s.useState)(!1),[c,u]=(0,s.useState)(Math.round(window.innerHeight-.25*window.innerHeight)),m=(0,l.on)(e=>e.metadata),d=m?m.units:"Default",[h,f]=(0,s.useState)(1),[p,x]=(0,s.useState)(1);(0,s.useEffect)(()=>{let e=()=>{let e=Math.round(window.innerHeight-.25*window.innerHeight);u(e),document.documentElement.style.setProperty("--plot-height","".concat(e,"px"))};return window.addEventListener("orientationchange",e),window.addEventListener("resize",e),()=>{window.removeEventListener("orientationchange",e),window.removeEventListener("resize",e)}},[]),(0,s.useEffect)(()=>{document.documentElement.style.setProperty("--plot-height","".concat(c,"px"))},[c]);let v=window.innerHeight-c>=10;return(0,r.jsxs)(r.Fragment,{children:[!v&&(0,r.jsx)(C.de,{onClick:()=>{u(window.innerHeight-60)}}),v&&(0,r.jsxs)("div",{className:"plot-canvas",children:[(0,r.jsx)(P,{}),a&&(0,r.jsx)(V,{pointID:e,pointLoc:n,showPointInfo:a,plotUnits:d}),(0,r.jsx)(C.A,{height:c,setHeight:u}),(0,r.jsx)(C.gj,{scale:h,setScale:f}),(0,r.jsx)(C.LC,{scale:p,setScale:x}),(0,r.jsxs)(S.Hl,{orthographic:!0,camera:{position:[0,0,100]},frameloop:"demand",children:[(0,r.jsx)(q,{height:c,yScale:h,pointSetters:{setPointID:t,setPointLoc:i,setShowPointInfo:o},xScale:p}),(0,r.jsx)(B,{height:c,yScale:h,xScale:p})]}),(0,r.jsx)(k,{})]})]})}var R=n(4420),O=n(9181);function B(e){let{colorTicks:t="grey",tickSize:n=4,fontSize:i=14,showGrid:a=!0,gridOpacity:o=.5,height:u,yScale:m=1,xScale:d=1}=e,{camera:h}=(0,p.C)(),[f,x]=(0,s.useState)({left:0,right:0,top:0,bottom:0}),{dimCoords:g,dimArrays:y,plotDim:w,valueScales:S}=(0,l.on)((0,c.k)(e=>({dimCoords:e.dimCoords,dimArrays:e.dimArrays,plotDim:e.plotDim,valueScales:e.valueScales}))),C=y[w],b=C.length,j=S.maxVal-S.minVal,D=(0,s.useMemo)(()=>{let e=["Jan","Feb","Mar","Apr","May","Jun","Jul","Aug","Sep","Oct","Nov","Dec"];if(C){if(C.every(e=>"bigint"==typeof e)){let t=Object.keys(g).length>0?Object.keys(g)[0]:null,n=t?(0,v.lt)(g[t].plot.units):1,r=[];for(let t=0;t<C.length;t++){let i=new Date(Number(C[t])*n),a="".concat(i.getDate().toString().padStart(2,"0")," ").concat(e[i.getMonth()],"\n").concat(i.getFullYear());r.push(a)}return r}return C.map(e=>String(e))}},[C,g]),M=(0,s.useMemo)(()=>{let e=window.innerWidth,t=window.innerHeight-u;return{left:-e/2+h.position.x,right:e/2+h.position.x,top:t/2+h.position.y,bottom:-t/2+h.position.y}},[]),[P,z]=(0,s.useState)(h.zoom),A=(0,s.useMemo)(()=>{let e=1/h.zoom;return{tickSize:n*e,fontSize:i/e,labelOffset:n*e}},[h.zoom,n,i]);(0,p.D)(()=>{h.zoom!==P&&z(h.zoom);let e=window.innerWidth/h.zoom,t=(window.innerHeight-u)/h.zoom,n={left:-e/2+h.position.x,right:e/2+h.position.x,top:t/2+h.position.y,bottom:-t/2+h.position.y};JSON.stringify(f)!=JSON.stringify(n)&&x(n)});let V=(0,s.useRef)(null),k=(0,s.useRef)(null);(0,s.useEffect)(()=>(V.current&&clearTimeout(V.current),k.current&&(V.current=setTimeout(()=>{k.current&&k.current.reset()},100)),()=>{null!==V.current&&clearTimeout(V.current)}),[u]);let T=(f.top+f.bottom)/2,B=(f.left+f.right)/2;return(0,r.jsxs)("group",{children:[a&&(0,r.jsxs)(r.Fragment,{children:[Array.from({length:10},(e,n)=>{var i;if(0===n||9===n)return null;let a=+Math.round(f.left/1)+(Math.round(f.right/1)-Math.round(f.left/1))*(n/9),l=a/d/(M.right-M.left)+.5;return(0,r.jsxs)(s.Fragment,{children:[(0,r.jsx)("group",{position:[a,T,0],children:(0,r.jsxs)("line",{children:[(0,r.jsx)("bufferGeometry",{children:(0,r.jsx)("float32BufferAttribute",{attach:"attributes-position",args:[new Float32Array([0,f.top-T,0,0,f.bottom-T,0]),3]})}),(0,r.jsx)("lineDashedMaterial",{color:t,opacity:o,transparent:!0,dashSize:.5,gapSize:.5})]},"vgrid-".concat(n))}),(0,r.jsxs)("group",{position:[a,f.top,0],children:[(0,r.jsxs)("line",{children:[(0,r.jsx)("bufferGeometry",{children:(0,r.jsx)("float32BufferAttribute",{attach:"attributes-position",args:[new Float32Array([0,0,0,0,-A.tickSize,0]),3]})}),(0,r.jsx)("lineBasicMaterial",{color:t})]}),0!==n&&9!==n&&(0,r.jsx)(R.E,{position:[0,A.tickSize/4-A.labelOffset,0],fontSize:A.fontSize/P**2,color:t,anchorX:"center",anchorY:"top",children:null!=(i=null==D?void 0:D[Math.round(l*b-.5)])?i:""})]},"top-tick-".concat(n))]},"vert-group-".concat(n))}),Array.from({length:8},(e,n)=>{if(0===n||7===n)return null;let i=f.bottom+(f.top-f.bottom)*(n/7),a=i/m/(f.top-f.bottom)/P+.5;return(0,r.jsxs)(s.Fragment,{children:[(0,r.jsx)("group",{position:[B,i,0],children:(0,r.jsxs)("line",{children:[(0,r.jsx)("bufferGeometry",{children:(0,r.jsx)("float32BufferAttribute",{attach:"attributes-position",args:[new Float32Array([f.left-B,0,0,f.right-B,0,0]),3]})}),(0,r.jsx)("lineDashedMaterial",{color:t,opacity:o,transparent:!0,dashSize:0,gapSize:.5,linewidth:1})]})},"hgrid-".concat(n)),(0,r.jsxs)("group",{position:[f.right,i,0],children:[(0,r.jsxs)("line",{children:[(0,r.jsx)("bufferGeometry",{children:(0,r.jsx)("float32BufferAttribute",{attach:"attributes-position",args:[new Float32Array([0,0,0,-A.tickSize,0,0]),3]})}),(0,r.jsx)("lineBasicMaterial",{color:t})]}),0!==n&&7!==n&&(0,r.jsx)(R.E,{position:[-A.tickSize-A.labelOffset,0,0],fontSize:A.fontSize/P**2,color:t,anchorX:"right",anchorY:"middle",children:(S.minVal+a*j).toFixed(1)})]},"right-tick-".concat(n))]},"vert-group-".concat(n))})]}),(0,r.jsx)(O.N,{ref:k,enableRotate:!1,enablePan:!0,enableZoom:!0,zoomSpeed:.85,maxDistance:500,maxZoom:20,minZoom:.5})]})}var F=n(12);n(3433);let N=e=>{let{loc:t,show:n,info:i}=e,{dimNames:a,dimUnits:o}=(0,l.on)((0,c.k)(e=>({dimNames:e.dimNames,dimUnits:e.dimUnits}))),u=(0,l.r2)(e=>e.axis),m=(0,s.useMemo)(()=>a.length<3?[a[0],a[1]]:a.filter((e,t)=>t!=u),[a,u]),d=(0,s.useMemo)(()=>a.length<3?[o[0],o[1]]:o.filter((e,t)=>t!=u),[o,u]);return(0,r.jsxs)("div",{className:"analysis-info",style:{left:"".concat(t[0]+10,"px"),top:"".concat(t[1]+10,"px"),display:n?"":"none"},children:["".concat(m[0],": ").concat(n&&(0,v.SB)(i[0],d[0])),(0,r.jsx)("br",{}),"".concat(m[1],": ").concat(n&&(0,v.SB)(i[1],d[1])),(0,r.jsx)("br",{}),"Value: ".concat(Math.round(100*i[2])/100)]})},_=e=>{let{isFlat:t}=e,{resetCamera:n}=(0,l.Ws)((0,c.k)(e=>({resetCamera:e.resetCamera}))),a=(0,s.useRef)(null);return(0,s.useEffect)(()=>{if(a.current){let e,n=a.current,r=performance.now(),o=n.object.position.clone(),s=n.position0.clone(),l=n.target.clone(),c=n.target0.clone(),u=n.object.zoom,m=a=>{(0,p.m)();let d=Math.min((a-r)/1e3,1);n.object.position.lerpVectors(o,s,d),n.target.lerpVectors(l,c,d),t&&(n.object.zoom=i.cj9.lerp(u,1e3,d),n.object.updateProjectionMatrix(),n.update()),d<1&&(e=requestAnimationFrame(m))};return e=requestAnimationFrame(m),()=>cancelAnimationFrame(e)}},[n]),(0,r.jsxs)(r.Fragment,{children:[t&&(0,r.jsx)(O.N,{ref:a,enableRotate:!1,enablePan:!0,maxDistance:50,minZoom:50,maxZoom:3e3}),!t&&(0,r.jsx)(O.N,{ref:a,minPolarAngle:0,maxPolarAngle:Math.PI/2,enablePan:!0,maxDistance:50})]})},U=e=>{let{values:t,setShowLoading:n}=e,{setShape:a,setFlipY:o,setValueScales:u,setMetadata:m,setDimArrays:d,setDimNames:h,setDimUnits:f,setPlotOn:p}=(0,l.on)((0,c.k)(e=>({setShape:e.setShape,setFlipY:e.setFlipY,setValueScales:e.setValueScales,setMetadata:e.setMetadata,setDimArrays:e.setDimArrays,setDimNames:e.setDimNames,setDimUnits:e.setDimUnits,setPlotOn:e.setPlotOn}))),{colormap:v,variable:y,isFlat:b,metadata:j,valueScales:D,setIsFlat:M,setDataArray:P}=(0,l.on)((0,c.k)(e=>({colormap:e.colormap,variable:e.variable,isFlat:e.isFlat,metadata:e.metadata,valueScales:e.valueScales,setIsFlat:e.setIsFlat,setDataArray:e.setDataArray}))),{ZarrDS:z,canvasWidth:A}=t,{plotType:V,resetCamera:k}=(0,l.Ws)((0,c.k)(e=>({plotType:e.plotType,resetCamera:e.resetCamera}))),T=(0,l.SZ)(e=>e.slice),R=(0,s.useRef)([0,0]),O=(0,s.useRef)(0),[B,U]=(0,s.useState)(!1),[L,W]=(0,s.useState)([0,0]),[Y,E]=(0,s.useState)(null),[I,X]=(0,s.useState)(!0),[G,H]=(0,s.useState)(0);(0,s.useEffect)(()=>{H(window.innerWidth);let e=()=>H(window.innerWidth);return window.addEventListener("resize",e),()=>window.removeEventListener("resize",e)},[]),(0,s.useEffect)(()=>{let e=new MutationObserver(e=>{e.forEach(e=>{e.attributeName})});return e.observe(document.documentElement,{attributes:!0,attributeFilter:["data-theme"]}),()=>e.disconnect()},[]),(0,s.useEffect)(()=>{"Default"!=y?(n(!0),X(!1),z.GetArray(y,T).then(e=>{let[t,r]=(0,F.oW)({data:e.data,shape:e.shape});t instanceof i.GYF||t instanceof i.dYF?E(t):(console.error("Invalid texture type returned from ArrayToTexture"),E(null)),"object"==typeof r&&"maxVal"in r&&"minVal"in r&&u(r),2==e.shape.length?(M(!0),P(e.data)):M(!1);let o=e.shape[1]/e.shape[2]*2;a(new i.Pq0(2,o,2)),n(!1),X(!0),p(!0)}),z.GetAttributes(y).then(e=>{m(e);let[t,n,r]=z.GetDimArrays();d(t),h(r),t.length>2?t[1][1]<t[1][0]?o(!0):o(!1):t[0][1]<t[0][0]?o(!0):o(!1);let i=[];for(let e of n)i.push(e.units);f(i)})):m(null)},[y]);let q=(0,s.useMemo)(()=>({setLoc:W,setShowInfo:U,coords:R,val:O}),[]),$=(0,s.useMemo)(()=>C.Fp,[]);return(0,r.jsxs)("div",{className:"main-canvas",style:{width:G-A},children:[I&&(0,r.jsx)(C.PL,{units:null==j?void 0:j.units,valueScales:D}),(0,r.jsx)($,{}),b&&(0,r.jsx)(N,{loc:L,show:B,info:[...R.current,O.current]}),!b&&(0,r.jsx)(r.Fragment,{children:(0,r.jsxs)(S.Hl,{camera:{position:b?[0,0,5]:[-4.5,3,4.5],fov:50},frameloop:"demand",children:["volume"==V&&I&&(0,r.jsxs)(r.Fragment,{children:[(0,r.jsx)(x,{volTexture:Y}),(0,r.jsx)(g,{ZarrDS:z})]}),"point-cloud"==V&&I&&(0,r.jsx)(r.Fragment,{children:(0,r.jsx)(w,{textures:{texture:Y,colormap:v},ZarrDS:z})}),"sphere"==V&&I&&(0,r.jsx)(J,{texture:Y,ZarrDS:z}),(0,r.jsx)(_,{isFlat:!1})]})}),b&&(0,r.jsx)(r.Fragment,{children:(0,r.jsxs)(S.Hl,{camera:{position:[0,0,5],zoom:1e3},orthographic:!0,frameloop:"demand",children:[(0,r.jsx)(Z,{texture:Y,infoSetters:q}),(0,r.jsx)(_,{isFlat:!0})]})})]})};var L=n(3395);let W=" // by Jeran Poehls\r\nvarying vec2 vUv;\r\n\r\nvoid main() {\r\n    vUv = uv;\r\n    gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);\r\n}",Y="uniform sampler2D data;\r\nuniform sampler2D cmap;\r\n\r\nuniform float cOffset;\r\nuniform float cScale;\r\n\r\nvarying vec2 vUv;\r\nout vec4 Color;\r\n\r\nvoid main() {\r\n    vec4 val = texture(data,vUv);\r\n    float d = val.x;\r\n    float sampLoc = d == 1. ? d : (d - 0.5)*cScale + 0.5;\r\n    sampLoc = d == 1. ? d : min(sampLoc+cOffset,0.99);\r\n    vec4 color = texture(cmap, vec2(sampLoc,0.5));\r\n    color.a = val.x > 0.999 ? 0. : 1.;\r\n\r\n    Color = color;\r\n}";class E{initAxis(e){let t=this.shape.filter((t,n)=>n!==e);this.GPUCompute=new L.d(t[1],t[0],this.renderer),this.targetAxis=e,this.renderTarget.texture.dispose(),this.renderTarget=this.GPUCompute.createRenderTarget(t[1],t[0],i.ghU,i.ghU,1006,1006),this.renderTarget.texture.format=i.VT0,this.renderTarget.texture.minFilter=i.hxR,this.renderTarget.texture.magFilter=i.hxR,this.renderTarget.texture.needsUpdate=!0}performReduction(e,t){e!=this.targetAxis&&this.initAxis(e);let n=this.GPUCompute.addVariable("reduction",t,this.initTexture);n.material.uniforms.dataArray={value:this.texture},n.material.uniforms.axisSize={value:this.shape[this.targetAxis]},n.material.uniforms.axis={value:this.targetAxis},this.GPUCompute.doRenderTarget(n.material,this.renderTarget);let r=new Float32Array(this.renderTarget.width*this.renderTarget.height);return this.renderer.readRenderTargetPixels(this.renderTarget,0,0,this.renderTarget.width,this.renderTarget.height,r),[this.renderTarget.texture,r]}Mean(e){return this.performReduction(e,"uniform sampler3D dataArray;\nuniform int axis;\nuniform int axisSize;\n\nvoid main() {\n    vec2 uv = gl_FragCoord.xy / resolution.xy;\n\n    vec3 sampleCoord;\n    \n    // Initialize sampling coordinates based on reduction axis\n    if (axis == 0) {\n        // Reduce along depth (D0), uv maps to (s,t) = (D2,D1)\n        sampleCoord = vec3(uv.x, uv.y, 0.0);\n    } else if (axis == 1) {\n        // Reduce along height (D1), uv maps to (s,r) = (D2,D0)\n        sampleCoord = vec3(uv.x, 0.0, uv.y);\n    } else if (axis == 2) {\n        // Reduce along width (D2), uv maps to (t,r) = (D1,D0)\n        sampleCoord = vec3(0.0, uv.x, uv.y);\n    }\n\n    float sum = 0.0;\n    for (int m = 0; m < axisSize; m++) { \n        float coord = (float(m) + 0.5) / float(axisSize); //0.5 for center of pixel\n        // Vary the appropriate coordinate\n        if (axis == 0) {\n            sampleCoord.z = coord; // Vary r (depth)\n        } else if (axis == 1) {\n            sampleCoord.y = coord; // Vary t (height)\n        } else if (axis == 2) {\n            sampleCoord.x = coord; // Vary s (width)\n        }\n        float samp = texture(dataArray, sampleCoord).r;\n        sum += samp == 0.0 ? 0.6 : samp; // Assuming data in red channel\n    }\n    \n    float mean = sum / float(axisSize);\n    gl_FragColor = vec4(mean, 0.0, 0.0, 1.0); // Output mean in red channel\n}")}Max(e){return this.performReduction(e,"uniform sampler3D dataArray;\r\nuniform int axis;\r\nuniform int axisSize;\r\n\r\nvoid main() {\r\n    vec2 uv = gl_FragCoord.xy / resolution.xy;\r\n\r\n    vec3 sampleCoord;\r\n    \r\n    // Initialize sampling coordinates based on reduction axis\r\n    if (axis == 0) {\r\n        // Reduce along depth (D0), uv maps to (s,t) = (D2,D1)\r\n        sampleCoord = vec3(uv.x, uv.y, 0.0);\r\n    } else if (axis == 1) {\r\n        // Reduce along height (D1), uv maps to (s,r) = (D2,D0)\r\n        sampleCoord = vec3(uv.x, 0.0, uv.y);\r\n    } else if (axis == 2) {\r\n        // Reduce along width (D2), uv maps to (t,r) = (D1,D0)\r\n        sampleCoord = vec3(0.0, uv.x, uv.y);\r\n    }\r\n\r\n    float maxVal = 0.0;\r\n    for (int m = 0; m < axisSize; m++) { \r\n        float coord = (float(m) + 0.5) / float(axisSize); //0.5 for center of pixel\r\n        \r\n        // Vary the appropriate coordinate\r\n        if (axis == 0) {\r\n            sampleCoord.z = coord; // Vary r (depth)\r\n        } else if (axis == 1) {\r\n            sampleCoord.y = coord; // Vary t (height)\r\n        } else if (axis == 2) {\r\n            sampleCoord.x = coord; // Vary s (width)\r\n        }\r\n        float sampled = texture(dataArray, sampleCoord).r; // Assuming data in red channel\r\n        maxVal = sampled > maxVal ? sampled : maxVal; \r\n    }\r\n    \r\n    gl_FragColor = vec4(maxVal, 0.0, 0.0, 1.0); // Output mean in red channel\r\n}")}Min(e){return this.performReduction(e,"uniform sampler3D dataArray;\r\nuniform int axis;\r\nuniform int axisSize;\r\n\r\nvoid main() {\r\n    vec2 uv = gl_FragCoord.xy / resolution.xy;\r\n\r\n    vec3 sampleCoord;\r\n    \r\n    // Initialize sampling coordinates based on reduction axis\r\n    if (axis == 0) {\r\n        // Reduce along depth (D0), uv maps to (s,t) = (D2,D1)\r\n        sampleCoord = vec3(uv.x, uv.y, 0.0);\r\n    } else if (axis == 1) {\r\n        // Reduce along height (D1), uv maps to (s,r) = (D2,D0)\r\n        sampleCoord = vec3(uv.x, 0.0, uv.y);\r\n    } else if (axis == 2) {\r\n        // Reduce along width (D2), uv maps to (t,r) = (D1,D0)\r\n        sampleCoord = vec3(0.0, uv.x, uv.y);\r\n    }\r\n\r\n    float minVal = 1.0e15; //BigNum\r\n    for (int m = 0; m < axisSize; m++) { \r\n        float coord = (float(m) + 0.5) / float(axisSize); //0.5 for center of pixel\r\n        \r\n        // Vary the appropriate coordinate\r\n        if (axis == 0) {\r\n            sampleCoord.z = coord; // Vary r (depth)\r\n        } else if (axis == 1) {\r\n            sampleCoord.y = coord; // Vary t (height)\r\n        } else if (axis == 2) {\r\n            sampleCoord.x = coord; // Vary s (width)\r\n        }\r\n        float sampled = texture(dataArray, sampleCoord).r; // Assuming data in red channel\r\n        minVal = sampled < minVal ? sampled : minVal; \r\n    }\r\n    \r\n    gl_FragColor = vec4(minVal, 0.0, 0.0, 1.0); // Output mean in red channel\r\n}")}StDev(e){return this.performReduction(e,"uniform sampler3D dataArray;\r\nuniform int axis;\r\nuniform int axisSize;\r\n\r\nvoid main() {\r\n    vec2 uv = gl_FragCoord.xy / resolution.xy;\r\n\r\n    vec3 sampleCoord;\r\n    \r\n    // Initialize sampling coordinates based on reduction axis\r\n    if (axis == 0) {\r\n        // Reduce along depth (D0), uv maps to (s,t) = (D2,D1)\r\n        sampleCoord = vec3(uv.x, uv.y, 0.0);\r\n    } else if (axis == 1) {\r\n        // Reduce along height (D1), uv maps to (s,r) = (D2,D0)\r\n        sampleCoord = vec3(uv.x, 0.0, uv.y);\r\n    } else if (axis == 2) {\r\n        // Reduce along width (D2), uv maps to (t,r) = (D1,D0)\r\n        sampleCoord = vec3(0.0, uv.x, uv.y);\r\n    }\r\n\r\n    float sum = 0.0;\r\n    for (int m = 0; m < axisSize; m++) { \r\n        float coord = (float(m) + 0.5) / float(axisSize); //0.5 for center of pixel\r\n        \r\n        // Vary the appropriate coordinate\r\n        if (axis == 0) {\r\n            sampleCoord.z = coord; // Vary r (depth)\r\n        } else if (axis == 1) {\r\n            sampleCoord.y = coord; // Vary t (height)\r\n        } else if (axis == 2) {\r\n            sampleCoord.x = coord; // Vary s (width)\r\n        }\r\n        \r\n        sum += texture(dataArray, sampleCoord).r; // Assuming data in red channel\r\n    }\r\n    \r\n    float mean = sum / float(axisSize);\r\n\r\n\r\n    float squaredDiffSum = 0.0;\r\n\r\n    for (int m = 0; m < axisSize; m++) { \r\n        float coord = (float(m) + 0.5) / float(axisSize); //0.5 for center of pixel\r\n        \r\n        // Vary the appropriate coordinate\r\n        if (axis == 0) {\r\n            sampleCoord.z = coord; // Vary r (depth)\r\n        } else if (axis == 1) {\r\n            sampleCoord.y = coord; // Vary t (height)\r\n        } else if (axis == 2) {\r\n            sampleCoord.x = coord; // Vary s (width)\r\n        }\r\n\r\n        float diff = mean - texture(dataArray, sampleCoord).r;\r\n\r\n        squaredDiffSum += pow(diff,2.); // Assuming data in red channel\r\n    }\r\n    float stdev = sqrt(squaredDiffSum / float(axisSize));\r\n\r\n    gl_FragColor = vec4(stdev, 0.0, 0.0, 1.0); // Output mean in red channel\r\n}")}dispose(){var e;null==(e=this.texture)||e.dispose(),this.renderTarget.texture.dispose(),this.initTexture.dispose()}constructor(e,t,n){this.shape=e.shape,this.renderer=t,this.GPUCompute=new L.d(10,10,this.renderer),this.initTexture=this.GPUCompute.createTexture(),this.targetAxis=5,this.renderTarget=this.GPUCompute.createRenderTarget(10,10,i.ghU,i.ghU,1006,1006);let r=e.shape[0]*e.shape[1]*e.shape[2],a=new Uint8Array(r),{minVal:o,maxVal:s}=n;for(let t=0;t<r;t++){let n=(e.data[t]-o)/(s-o)*254;a[t]=isNaN(e.data[t])?255:n}this.texture=new i.dYF(a,this.shape[2],this.shape[1],this.shape[0]),this.texture.format=i.VT0,this.texture.minFilter=i.hxR,this.texture.magFilter=i.hxR,this.texture.needsUpdate=!0}}class I{initAxis(e){let t=this.shape.filter((t,n)=>n!==e);this.GPUCompute=new L.d(t[1],t[0],this.renderer),this.targetAxis=e,this.renderTarget=this.GPUCompute.createRenderTarget(t[1],t[0],i.ghU,i.ghU,1006,1006),this.renderTarget.texture.format=i.VT0,this.renderTarget.texture.minFilter=i.hxR,this.renderTarget.texture.magFilter=i.hxR,this.renderTarget.texture.needsUpdate=!0}performReduction(e,t){e!==this.targetAxis&&this.initAxis(e);let n=this.GPUCompute.addVariable("reduction",t,this.initTexture);n.material.uniforms.dataArray1={value:this.textureOne},n.material.uniforms.dataArray2={value:this.textureTwo},n.material.uniforms.axisSize={value:this.shape[this.targetAxis]},n.material.uniforms.axis={value:this.targetAxis},this.GPUCompute.doRenderTarget(n.material,this.renderTarget);let r=new Float32Array(this.renderTarget.width*this.renderTarget.height*4);return this.renderer.readRenderTargetPixels(this.renderTarget,0,0,this.renderTarget.width,this.renderTarget.height,r),[this.renderTarget.texture,r]}Correlate(e){return this.performReduction(e,"uniform sampler3D dataArray1;\r\nuniform sampler3D dataArray2;\r\nuniform int axis;\r\nuniform int axisSize;\r\n\r\n\r\n\r\nvoid main() {\r\n    vec2 uv = gl_FragCoord.xy / resolution.xy;\r\n    vec3 sampleCoord;\r\n    \r\n    if (axis == 0) {\r\n        sampleCoord = vec3(uv.x, uv.y, 0.0);\r\n    } else if (axis == 1) {\r\n        sampleCoord = vec3(uv.x, 0.0, uv.y);\r\n    } else if (axis == 2) {\r\n        sampleCoord = vec3(0.0, uv.x, uv.y);\r\n    }\r\n\r\n    float sumX = 0.0;\r\n    float sumY = 0.0;\r\n    float sumXX = 0.0;\r\n    float sumYY = 0.0;\r\n    float sumXY = 0.0;\r\n\r\n    for (int m = 0; m < axisSize; m++) {\r\n        float coord = (float(m) + 0.5) / float(axisSize);\r\n        if (axis == 0) {\r\n            sampleCoord.z = coord;\r\n        } else if (axis == 1) {\r\n            sampleCoord.y = coord;\r\n        } else if (axis == 2) {\r\n            sampleCoord.x = coord;\r\n        }\r\n        float X_i = texture(dataArray1, sampleCoord).r;\r\n        float Y_i = texture(dataArray2, sampleCoord).r;\r\n        sumX += X_i;\r\n        sumY += Y_i;\r\n        sumXX += X_i * X_i;\r\n        sumYY += Y_i * Y_i;\r\n        sumXY += X_i * Y_i;\r\n    }\r\n\r\n    float N = float(axisSize);\r\n    float meanX = sumX / N;\r\n    float meanY = sumY / N;\r\n    float varX = (sumXX / N) - (meanX * meanX);\r\n    float varY = (sumYY / N) - (meanY * meanY);\r\n    float covXY = (sumXY / N) - (meanX * meanY);\r\n    float sigmaX = sqrt(max(0.0, varX));\r\n    float sigmaY = sqrt(max(0.0, varY));\r\n    float epsilon = 1e-6;\r\n    float denominator = sigmaX * sigmaY + epsilon;\r\n    float correlation = covXY / denominator;\r\n\r\n    float newCorrelation = (correlation + 1.)/2.;\r\n\r\n    gl_FragColor = vec4(newCorrelation, 0.0, 0.0, 1.0);\r\n    \r\n}")}dispose(){var e,t;null==(e=this.textureOne)||e.dispose(),null==(t=this.textureTwo)||t.dispose(),this.renderTarget.texture.dispose(),this.initTexture.dispose()}constructor(e,t,n){let{firstArray:r,secondArray:a}=e;this.shape=r.shape,this.renderer=t,this.GPUCompute=new L.d(10,10,this.renderer),this.initTexture=this.GPUCompute.createTexture(),this.targetAxis=5,this.renderTarget=this.GPUCompute.createRenderTarget(10,10,i.ghU,i.ghU,1006,1006);let o=r.shape[0]*r.shape[1]*r.shape[2],s=new Uint8Array(o),{minVal:l,maxVal:c}=n.firstArray;for(let e=0;e<o;e++){let t=(r.data[e]-l)/(c-l)*254;s[e]=isNaN(r.data[e])?255:t}this.textureOne=new i.dYF(s,this.shape[2],this.shape[1],this.shape[0]),this.textureOne.format=i.VT0,this.textureOne.minFilter=i.hxR,this.textureOne.magFilter=i.hxR,this.textureOne.needsUpdate=!0;let u=new Uint8Array(o);l=n.secondArray.minVal,c=n.secondArray.maxVal;for(let e=0;e<o;e++){let t=(a.data[e]-l)/(c-l)*254;u[e]=isNaN(a.data[e])?255:t}this.textureTwo=new i.dYF(u,this.shape[2],this.shape[1],this.shape[0]),this.textureTwo.format=i.VT0,this.textureTwo.minFilter=i.hxR,this.textureTwo.magFilter=i.hxR,this.textureTwo.needsUpdate=!0}}let X=e=>{let{arrays:t,values:n,setters:a}=e,{setShowInfo:o,setLoc:u,uv:m,setVal:d}=a,{colormap:h,flipY:f}=(0,l.on)((0,c.k)(e=>({colormap:e.colormap,flipY:e.flipY}))),{stateVars:x,valueScales:v}=n,{firstArray:g,secondArray:y}=t,{axis:w,operation:S,execute:C}=x,b=g.shape,[j,D]=(0,s.useState)(b.filter((e,t)=>t!==w)),{gl:M}=(0,p.C)(),P=(0,s.useRef)(!1),z=(0,s.useRef)(new Float32Array(0)),{cScale:A,cOffset:V}=(0,l.Ws)((0,c.k)(e=>({cScale:e.cScale,cOffset:e.cOffset}))),k=(0,s.useMemo)(()=>y?new I({firstArray:g,secondArray:y},M,v):new E(g,M,v.firstArray),[g,y]),[T,R]=(0,s.useState)(null),O=new i.BKk({glslVersion:i.Wdf,uniforms:{cScale:{value:A},cOffset:{value:V},data:{value:T},cmap:{value:h}},vertexShader:W,fragmentShader:Y,side:i.$EB});(0,s.useEffect)(()=>{if(g){let e=null;if(y&&k instanceof I)[e,z.current]=k.Correlate(w);else switch(S){case"Max":[e,z.current]=k instanceof E?k.Max(w):[null,z.current];break;case"Min":[e,z.current]=k instanceof E?k.Min(w):[null,z.current];break;case"Mean":[e,z.current]=k instanceof E?k.Mean(w):[null,z.current];break;case"StDev":[e,z.current]=k instanceof E?k.StDev(w):[null,z.current];break;default:e=T}R(e),D(b.filter((e,t)=>t!==w))}},[C,w,y,g,S]);let B=(0,s.useMemo)(()=>f?-(j[0]/j[1]*2):j[0]/j[1]*2,[f,j]);(0,s.useEffect)(()=>{k&&k.dispose()},[g,y]);let F=(0,s.useRef)(null),N=(0,s.useCallback)(e=>{if(P.current&&e.uv){F.current=e,u([e.clientX,e.clientY]);let{x:t,y:n}=e.uv;m.current=[t,n];let r=Math.round(j[0]*n-.5),i=Math.round(j[1]*t-.5),a=j[1]*r+i,o=z.current[a];y||"StDev"===S?d(o):d(function(e,t){return e*(t.maxVal-t.minVal)+t.minVal}(o,v.firstArray))}},[g,y,w,S,j]),_=(0,s.useMemo)(()=>new i.bdM(2,B),[B]);return(0,s.useEffect)(()=>{_.dispose()},[_]),(0,r.jsx)("mesh",{material:O,onPointerEnter:()=>{o(!0),P.current=!0},onPointerLeave:()=>{o(!1),P.current=!1},onPointerMove:N,geometry:_,rotation:[0,0,2==w?Math.PI/2:0]})};function G(e){let{values:t}=e,{dimNames:n,dimArrays:i,dimUnits:a,variables:o,setDimNames:u,setDimArrays:m,setDimUnits:d}=(0,l.on)((0,c.k)(e=>({dimNames:e.dimNames,dimArrays:e.dimArrays,dimUnits:e.dimUnits,variables:e.variables,setDimNames:e.setDimNames,setDimArrays:e.setDimArrays,setDimUnits:e.setDimUnits}))),{axis:h,operation:f,variable1:p,variable2:x,execute:g}=(0,l.r2)((0,c.k)(e=>({axis:e.axis,operation:e.operation,variable1:e.variable1,variable2:e.variable2,execute:e.execute}))),{ZarrDS:y,canvasWidth:w}=t,b=(0,s.useRef)({}),j=(0,l.on)(e=>e.setFlipY),[D,M]=(0,s.useState)([0,100]),[P,z]=(0,s.useState)([0,100]),[A,V]=(0,s.useState)(null),[k,T]=(0,s.useState)(null),[R,B]=(0,s.useState)(!1),[F,_]=(0,s.useState)([0,0]),U=(0,s.useRef)([0,0]),[L,W]=(0,s.useState)(0),Y=(0,s.useRef)([0,0]),[E,I]=(0,s.useState)("Default");(0,s.useMemo)(()=>n.map((e,t)=>({text:e,value:t})),[]);let G=(0,s.useMemo)(()=>({operation:f,axis:h,execute:g}),[f,h,g]);(0,s.useEffect)(()=>{"Default"!==p&&(y.GetArray(p,[0,10]).then(e=>{if(V(e),p in b.current)M([b.current[p].min,b.current[p].max]);else{let[t,n]=(0,v.ArrayMinMax)(e.data);M([n,t]),b.current[p]={min:t,max:n}}}),y.GetAttributes(p).then(e=>{I(e.units);let[t,n,r]=y.GetDimArrays();m(t),u(r);let i=[];for(let e of n)i.push(e.units);d(i),t[1][1]<t[1][0]?j(!0):j(!1)})),"Default"!==x&&y.GetArray(x,[0,10]).then(e=>{if(T(e),x in b.current)z([b.current[x].min,b.current[x].max]);else{let[t,n]=(0,v.ArrayMinMax)(e.data);z([t,n]),b.current[x]={min:t,max:n}}}),"Default"===x&&T(null)},[p,x,h]);let H=(0,s.useMemo)(()=>3===i.length?i.filter((e,t)=>t!=h):i,[h,i]);(0,s.useEffect)(()=>{if(i){let e=H[1].length,t=H[0].length,n=Math.round(U.current[0]*e-.5),r=Math.round(U.current[1]*t-.5);Y.current=[H[0][r],H[1][n]]}},[U,F,H]);let q=(0,s.useMemo)(()=>({firstArray:{maxVal:D[1],minVal:D[0]},secondArray:{maxVal:P[1],minVal:P[0]}}),[D,P]),Z=(0,s.useMemo)(()=>({stateVars:G,valueScales:q}),[G,q]),J=(0,s.useMemo)(()=>C.pH,[]);return(0,r.jsxs)("div",{className:"analysis-canvas",style:{width:w},children:[A&&(0,r.jsx)(C.PL,{units:E,valueScales:k?{maxVal:1,minVal:0}:{maxVal:D[0],minVal:D[1]}}),(0,r.jsx)(J,{}),(0,r.jsx)(N,{loc:F,show:R,info:[...Y.current,L]}),(0,r.jsxs)(S.Hl,{camera:{position:[0,0,50],zoom:400},orthographic:!0,children:[A&&(0,r.jsx)(X,{arrays:{firstArray:A,secondArray:k},values:Z,setters:{setShowInfo:B,setLoc:_,uv:U,setVal:W}}),(0,r.jsx)(O.N,{enablePan:!0,enableRotate:!1})]})]})}function H(e){let{points:t,tsID:n,pointSetters:a,colIDX:o,scalers:u}=e,m=(0,s.useRef)(null),d=t.length,h=(0,s.useRef)(null),[f,x]=(0,s.useState)(!1),{setPointID:v,setPointLoc:g,setShowPointInfo:y}=a,[w,S]=(0,s.useState)(1),{pointColor:C,pointSize:b,useCustomPointColor:j}=(0,l.Ws)((0,c.k)(e=>({pointColor:e.pointColor,pointSize:e.linePointSize,showPoints:e.showPoints,useCustomPointColor:e.useCustomPointColor}))),{xScale:D,yScale:M}=u,[P,A,V]=(0,s.useMemo)(()=>(0,z.md)(o/10,"Paired"),[o]),k=(0,s.useMemo)(()=>new i.Gu$(b),[b]),T=(0,s.useMemo)(()=>new i.V9B({color:j?C:new i.Q1f().setRGB(P/500,A/500,V/500)}),[C,j]);return(0,s.useEffect)(()=>{if(m.current){let e=new i.B69;for(let n=0;n<d;n++){let r=t[n].toArray();e.position.set(r[0]*(D/2),r[1]*M,1),e.scale.set(b/w,b/w,b/w),e.updateMatrix(),m.current.setMatrixAt(n,e.matrix)}m.current.instanceMatrix.needsUpdate=!0}},[t,w,k,T,D,M,b]),(0,p.D)(e=>{let{camera:t}=e;t.zoom!==w&&S(t.zoom)}),(0,r.jsx)(r.Fragment,{children:(0,r.jsx)("mesh",{position:[0,0,5],onPointerEnter:function(e){if(m.current){let t=e.instanceId,r=new i.B69,a=new i.kn4,o=new i.Pq0;t!=h.current&&h.current&&(m.current.getMatrixAt(h.current,a),o.setFromMatrixPosition(a),r.scale.set(b/w,b/w,b/w),r.position.copy(o),r.updateMatrix(),m.current.setMatrixAt(h.current,r.matrix)),h.current=t,m.current.getMatrixAt(t,a),o.setFromMatrixPosition(a),r.scale.set(3*b/w,3*b/w,3/w),r.position.copy(o),r.updateMatrix(),m.current.setMatrixAt(e.instanceId,r.matrix),m.current.instanceMatrix.needsUpdate=!0,x(e=>!e),v({[n]:e.instanceId}),g([e.clientX,e.clientY]),y(!0)}},onPointerLeave:function(e){let t=e.instanceId;if(m.current){let e=new i.B69,n=new i.kn4,r=new i.Pq0;h.current&&(m.current.getMatrixAt(t,n),r.setFromMatrixPosition(n),e.scale.set(b/w,b/w,b/w),e.position.copy(r),e.updateMatrix(),m.current.setMatrixAt(t,e.matrix),m.current.instanceMatrix.needsUpdate=!0,x(e=>!e),y(t!=h.current))}},children:(0,r.jsx)("instancedMesh",{ref:m,args:[k,T,d]})})})}let q=e=>{let{height:t,xScale:n,yScale:a,pointSetters:o}=e,{valueScales:u,timeSeries:m,colormap:d}=(0,l.on)((0,c.k)(e=>({valueScales:e.valueScales,timeSeries:e.timeSeries,colormap:e.colormap}))),{lineWidth:h,useLineColor:f,lineColor:x,showPoints:v,lineResolution:g,useCustomColor:y}=(0,l.Ws)((0,c.k)(e=>({lineWidth:e.lineWidth,linePointSize:e.linePointSize,showPoints:e.showPoints,useLineColor:e.useLineColor,lineColor:e.lineColor,lineResolution:e.lineResolution,useCustomColor:e.useCustomColor})));(0,s.useRef)([]);let{camera:w}=(0,p.C)(),{maxVal:S,minVal:C}=u,b=(0,s.useMemo)(()=>{let e={};return Object.keys(m).map((t,r)=>{let[o,s,l]=(0,z.md)(r/10,"Paired");e[t]=new i.BKk({glslVersion:i.Wdf,uniforms:{cmap:{value:d},xScale:{value:n},yScale:{value:a},aspect:{value:window.innerWidth/window.innerHeight},thickness:{value:h},miter:{value:1},useLineColor:{value:y},useMapColors:{value:f},lineColor:{value:new i.Q1f().setRGB(o/255,s/255,l/255)},userColor:{value:new i.Q1f(x)},zoom:{value:w.zoom}},vertexShader:"attribute float direction; \nattribute vec3 next;\nattribute vec3 previous;\nattribute float normed;\n\nvarying float vNormed;\n\nuniform float zoom;\nuniform float thickness;\nuniform int miter;\nuniform float xScale; \nuniform float yScale;\n\nfloat getOrthographicZoom(mat4 projectionMatrix, float referenceWidth) {\n    float m0 = projectionMatrix[0][0]; // Scaling factor: 2/(right-left)\n    float viewWidth = 2.0 / m0; // Viewable width\n    return referenceWidth / viewWidth; // Zoom level\n}\n\nvoid main() {\n    vec3 pos = position;\n    vec3 prev = previous;\n    vec3 nex = next;\n    pos.x *= xScale/2.0;\n    pos.y *= yScale;\n    prev.x *= xScale/2.0;\n    prev.y *= yScale;\n    nex.x *= xScale/2.0;\n    nex.y *= yScale;\n\n    // Transform positions to view space (before projection)\n    float zoom = getOrthographicZoom(projectionMatrix, 2.);\n    float zoomLevel = 2. / projectionMatrix[0][0]; // Extract vertical scale\n    vec4 currentView = modelViewMatrix * vec4(pos, 1.0);\n    vec4 prevView = modelViewMatrix * vec4(prev, 1.0);\n    vec4 nextView = modelViewMatrix * vec4(nex, 1.0);\n\n    // Compute directions in view space\n    vec3 dir = vec3(0.0);\n    if (currentView.xyz == prevView.xyz) {\n        dir = normalize(nextView.xyz - currentView.xyz);\n    } else if (currentView.xyz == nextView.xyz) {\n        dir = normalize(currentView.xyz - prevView.xyz);\n    } else {\n        vec3 dirA = normalize(currentView.xyz - prevView.xyz);\n        if (miter == 1) {\n            vec3 dirB = normalize(nextView.xyz - currentView.xyz);\n            vec3 tangent = normalize(dirA + dirB);\n            vec3 perp = vec3(-dirA.y, dirA.x, 0.0); // Perpendicular in view space\n            vec3 miterVec = vec3(-tangent.y, tangent.x, 0.0);\n            float miterLen = dot(miterVec, perp);\n            miterLen = max(miterLen, 0.5); // Avoid division by zero\n            dir = tangent;\n        } else {\n            dir = dirA;\n        }\n    }\n\n    // Compute normal in view space\n    vec3 normal = vec3(-dir.y, dir.x, 0.0); // Perpendicular to direction\n    float len = thickness / zoom/500.; // Thickness in world/view space units\n    normal *= 0.5 * len * direction; // Apply thickness and direction\n\n    // Apply offset in view space\n    currentView.xyz += normal;\n\n    // Project to clip space\n    gl_Position = projectionMatrix * currentView;\n\n\n    vNormed = normed;\n    gl_PointSize = 1.0;\n}",fragmentShader:"\n                out vec4 Color;\n                uniform sampler2D cmap;\n                uniform bool useLineColor;\n                uniform bool useMapColors;\n                uniform vec3 lineColor;\n                uniform vec3 userColor;\n                varying float vNormed;\n\n                void main() {\n                    vec4 texColor = texture(cmap, vec2(vNormed, 0.1));\n                    texColor.a = 1.;\n                    Color = useLineColor ? vec4(userColor, 1.0) : useMapColors ? texColor : vec4(lineColor, 1.0) ;\n                }\n                ",depthWrite:!1})}),e},[d,h,n,a,window.innerWidth,window.innerHeight,f,x,w.zoom,y,m]),j=(0,s.useMemo)(()=>window.innerWidth,[window.innerWidth]),D=(0,s.useMemo)(()=>window.innerHeight-t,[window.innerWidth,t]),[M,P]=(0,s.useState)({}),A=(0,s.useMemo)(()=>{let e={},t={};return Object.keys(m).map((n,r)=>{let a=m[n],o=a.map(e=>(e-C)/(S-C)),s=function(e,t,n){let r=(t-e)/(n-1);return Array.from({length:n},(t,n)=>e+r*n)}(-j,j,a.length),l=o.map((e,t)=>new i.Pq0(s[t],(e-.5)*D,5));t[n]=l;let c=new i.B6O(l).getPoints(l.length*g-1),u=[];for(let e=0;e<c.length;e++){let t=e/(c.length-1)*(o.length-1),n=Math.floor(t),r=Math.min(o.length-1,Math.ceil(t)),i=t-n;u.push(o[n]*(1-i)+o[r]*i)}let d=c.length,h=[],f=[],p=[],x=[],v=[],y=[];for(let e=0;e<d;e++){let t=c[e],n=c[Math.max(0,e-1)],r=c[Math.min(d-1,e+1)];h.push(...t,...t),f.push(1,-1),p.push(...n,...n),x.push(...r,...r),v.push(u[e],u[e])}for(let e=0;e<d-1;e++){let t=2*e,n=t+1,r=t+2,i=t+3;y.push(t,n,r),y.push(n,i,r)}let w=new i.LoY;w.setAttribute("position",new i.qtW(h,3)),w.setAttribute("direction",new i.qtW(f,1)),w.setAttribute("previous",new i.qtW(p,3)),w.setAttribute("next",new i.qtW(x,3)),w.setAttribute("normed",new i.qtW(v,1)),w.setIndex(new i.A$4(y,1)),e[n]=w}),P(t),e},[m,g]);return(0,s.useEffect)(()=>{(0,p.m)()},[v]),(0,r.jsx)(r.Fragment,{children:(0,r.jsxs)("group",{children:[Object.keys(m).map((e,t)=>(0,r.jsx)("mesh",{geometry:A[e],material:b[e]},"lineMesh_".concat(t))),v&&Object.keys(m).map((e,t)=>(0,r.jsx)(H,{points:M[e],tsID:e,colIDX:t,pointSetters:o,scalers:{xScale:n,yScale:a}},"plotPoints_".concat(t)))]})})},Z=e=>{let{texture:t,infoSetters:n}=e,{setLoc:a,setShowInfo:o,val:u,coords:m}=n,{shape:d,flipY:h,colormap:f,dataArray:p,valueScales:x,dimArrays:v}=(0,l.on)((0,c.k)(e=>({shape:e.shape,flipY:e.flipY,colormap:e.colormap,dataArray:e.dataArray,valueScales:e.valueScales,dimArrays:e.dimArrays}))),{cScale:g,cOffset:y}=(0,l.Ws)((0,c.k)(e=>({cOffset:e.cOffset,cScale:e.cScale}))),w=(0,s.useMemo)(()=>d.x/d.z,[d]),S=(0,s.useMemo)(()=>new i.bdM(2,w),[w]),C=(0,s.useRef)(!1),b=new i.BKk({glslVersion:i.Wdf,uniforms:{cScale:{value:g},cOffset:{value:y},data:{value:t},cmap:{value:f}},vertexShader:W,fragmentShader:Y,side:i.$EB});(0,s.useEffect)(()=>{S.dispose()},[S]);let j=(0,s.useRef)(null),D=(0,s.useCallback)(e=>{if(C.current&&e.uv){j.current=e,a([e.clientX,e.clientY]);let{x:t,y:n}=e.uv,r=v[1].length,i=v[0].length,o=Math.round(t*r-.5),s=Math.round(n*i-.5);u.current=function(e,t){return e*(t.maxVal-t.minVal)+t.minVal}(p?p[r*s+o]:0,x),m.current=[v[0][s],v[1][o]]}},[p,d,v]);return(0,r.jsx)(r.Fragment,{children:(0,r.jsx)("mesh",{material:b,geometry:S,scale:[1,h?-1:1,1],onPointerEnter:()=>{o(!0),C.current=!0},onPointerLeave:()=>{o(!1),C.current=!1},onPointerMove:D})})},J=e=>{let{texture:t,ZarrDS:n}=e,{colormap:a,flipY:o}=(0,l.on)((0,c.k)(e=>({colormap:e.colormap,flipY:e.flipY}))),{setPlotDim:u,updateDimCoords:m,updateTimeSeries:d}=(0,l.on)((0,c.k)(e=>({setPlotDim:e.setPlotDim,updateDimCoords:e.updateDimCoords,updateTimeSeries:e.updateTimeSeries}))),{dimArrays:h,dimNames:x,dimUnits:g}=(0,l.on)((0,c.k)(e=>({shape:e.shape,dimArrays:e.dimArrays,dimNames:e.dimNames,dimUnits:e.dimUnits}))),{animate:y,cOffset:w,cScale:S,resetAnim:C,selectTS:b}=(0,l.Ws)((0,c.k)(e=>({animate:e.animate,cOffset:e.cOffset,cScale:e.cScale,resetAnim:e.resetAnim,selectTS:e.selectTS}))),[j,D]=(0,s.useState)(Array(10).fill(new i.IUQ(-1,-1,-1,-1))),{height:M,width:P}=(0,s.useMemo)(()=>null==t?void 0:t.source.data,[t]),[z,A]=(0,s.useState)(0),V=(0,s.useMemo)(()=>new i.WBB(1,9),[]),k=(0,s.useMemo)(()=>new i.BKk({glslVersion:i.Wdf,uniforms:{map:{value:t},selectTS:{value:b},selectBounds:{value:j},cmap:{value:a},cOffset:{value:w},cScale:{value:S},animateProg:{value:z}},vertexShader:f,fragmentShader:" // by Jeran Poehls\nprecision highp float;\nprecision highp sampler3D;\n\nout vec4 color;\n\nin vec3 aPosition;\n\nuniform sampler3D map;\nuniform sampler2D cmap;\n\nuniform float cOffset;\nuniform float cScale;\nuniform float animateProg;\nuniform vec4[10] selectBounds; \nuniform bool selectTS;\n\n#define pi 3.141592653\n\nvec2 giveUV(vec3 position){\n    vec3 n = normalize(position);\n    float latitude = asin(n.y);\n    float longitude = atan(n.z, n.x);\n    vec2 uv = vec2(-longitude/(pi), latitude/(pi/2.0));\n    uv /= 2.;\n    uv += 0.5;\n    return uv;\n}\n\nbool isValid(vec2 sampleCoord){\n    for (int i = 0; i < 10; i++){\n        vec4 thisBound = selectBounds[i];\n        if (thisBound.x == -1.){\n            return false;\n        }\n        bool cond = (sampleCoord.x < thisBound.r || sampleCoord.x > thisBound.g || sampleCoord.y < thisBound.b ||  sampleCoord.y > thisBound.a);\n        if (!cond){\n            return true;\n        }\n    }\n    return false;\n}\n\nvoid main(){\n    vec2 sampleCoord = giveUV(aPosition);\n    float strength = texture(map, vec3(sampleCoord, animateProg)).r;\n    strength = strength == 1. ? strength : (strength - 0.5)*cScale + 0.5;\n    strength = strength == 1. ? strength : min(strength+cOffset,0.99);\n    color = texture(cmap, vec2(strength, 0.5));\n    bool cond = isValid(sampleCoord);\n    if (!cond && selectTS){\n        color.rgb *= 0.65;\n    }\n    color.a = 1.;\n    // color = vec4(sampleCoord, 0., 1.0);\n\n}",blending:i.NTi}),[t,z,a,w,S,y,j,b]);return(0,p.D)(()=>{y&&A((z+.001)%1)}),(0,s.useEffect)(()=>{A(0)},[C]),(0,r.jsx)(r.Fragment,{children:(0,r.jsx)("mesh",{geometry:V,material:k,scale:[1,o?-1:1,1],onClick:e=>b&&function(e){let r=function(e,t,n){let r=Math.atan2(e.z,e.x),a=Math.asin(e.y),o=(r+Math.PI)/(2*Math.PI),s=(a+Math.PI/2)/Math.PI;return o=Math.round((o=1-o)*t-.5)/t,s=Math.round(s*n-.5)/n,new i.I9Y(o,s)}(e.point.normalize(),null==t?void 0:t.source.data.width,null==t?void 0:t.source.data.height),a=new i.Pq0(0,0,1);if(n){var s,l;let e=n.GetTimeSeries({uv:r,normal:a}),t=a.toArray().map((e,t)=>Math.abs(e)>0?t:null).filter(e=>null!==e);u(2-t[0]);let i=(0,v.jT)({normal:a,uv:r}).map((e,t)=>e?h[t][Math.round(e*h[t].length)]:null),o=x.filter((e,t)=>null!==i[t]),c=g.filter((e,t)=>null!==i[t]);i=i.filter(e=>null!==e);let f="".concat(i[0],"_").concat(i[1]);d({[f]:e}),m({[f]:{first:{name:o[0],loc:null!=(s=i[0])?s:0,units:c[0]},second:{name:o[1],loc:null!=(l=i[1])?l:0,units:c[1]},plot:{units:g[2-t[0]]}}})}!function(e){let t=Math.round(e.x*P)+.5,n=o?Math.round((1-e.y)*M)-.5:Math.round(e.y*M)+.5,r=1/P,a=1/M,s=new i.IUQ(...[t/P-r/2,t/P+r/2],...[n/M-a/2,n/M+a/2]);D(e=>[s,...e].slice(0,10))}(r)}(e)})})};i.l2R.enabled=!0;let $=function(){let{initStore:e,setZMeta:t}=(0,l.on)((0,c.k)(e=>({initStore:e.initStore,setZMeta:e.setZMeta}))),n=(0,s.useMemo)(()=>new o.Y5(e),[e]),[i,u]=(0,s.useState)({});(0,s.useEffect)(()=>{let n=!0;(0,a.tz)((0,o.Oe)(e)).then(e=>{n&&u(e)});let r=(0,o.Oe)(e),i=(0,a.Tk)(r),s=(0,a.Bi)(i);return i.then(e=>t(e)),s.then(e=>{m(e)}),()=>{n=!1}},[e]);let{setVariables:m,setPlotOn:d,timeSeries:f,variable:p,metadata:x,plotOn:v}=(0,l.on)((0,c.k)(e=>({setVariables:e.setVariables,setPlotOn:e.setPlotOn,timeSeries:e.timeSeries,variable:e.variable,metadata:e.metadata,plotOn:e.plotOn}))),[g,y]=(0,s.useState)(!1),[w,S]=(0,s.useState)(window.innerWidth);(0,s.useEffect)(()=>{let e=()=>S(window.innerWidth);return window.addEventListener("resize",e),()=>window.removeEventListener("resize",e)},[]);let[b,j]=(0,s.useState)(0);(0,s.useEffect)(()=>{j(Math.round(0*window.innerWidth))},[]);let D=(0,s.useMemo)(()=>({ZarrDS:n,canvasWidth:b}),[n,b]),M=(0,s.useMemo)(()=>({values:{ZarrDS:n,canvasWidth:b}}),[n,b]);return(0,s.useEffect)(()=>{"Default"===p&&(j(0),d(!1))},[p]),(0,r.jsxs)(r.Fragment,{children:[!v&&(0,r.jsx)(C.Fp,{}),b<15&&"Default"!=p&&(0,r.jsx)(C.kW,{onClick:()=>j(.5*w)}),b>w-15&&"Default"!=p&&(0,r.jsx)(C.h7,{onClick:()=>j(.5*w)}),b>15&&b<w-15&&(0,r.jsx)(C.t2,{canvasWidth:b,setCanvasWidth:j}),(0,r.jsx)(C.Rh,{showLoading:g}),b>10&&"Default"!=p&&(0,r.jsx)(G,{values:M.values}),"Default"===p&&(0,r.jsx)(h,{}),"Default"!=p&&b<w-15&&(0,r.jsx)(U,{values:D,setShowLoading:y}),x&&(0,r.jsx)(C.OS,{data:x}),Object.keys(f).length>=1&&(0,r.jsx)(T,{})]})}},8947:()=>{}},e=>{var t=t=>e(e.s=t);e.O(0,[154,910,285,383,458,667,217,935,587,195,970,441,984,269,543,7,112,831,78,358],()=>t(1700)),_N_E=e.O()}]);