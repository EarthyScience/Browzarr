(self.webpackChunk_N_E=self.webpackChunk_N_E||[]).push([[974],{596:()=>{},885:(e,n,t)=>{"use strict";t.d(n,{default:()=>ep});var r=t(9564),i=t(7510),a=t(6431),o=t(9901),s=t(7776),l=t(8688),u=t(3277);t(3143),t(4593);let c=()=>{let{variables:e,zMeta:n,setVariable:t}=(0,l.on)((0,u.k)(e=>({variables:e.variables,zMeta:e.zMeta,setVariable:e.setVariable}))),[i,a]=(0,s.useState)(Math.floor(e.length/2)),[o,c]=(0,s.useState)(null),[d,m]=(0,s.useState)(82),f=(0,s.useRef)(null),p=(0,s.useRef)(0);function x(){let e=window.innerWidth;e<=480?m(42):e<=570?m(54):m(82)}return(0,s.useEffect)(()=>{let e=e=>{e.cancelable&&e.preventDefault()};return document.addEventListener("touchmove",e,{passive:!1}),()=>{document.removeEventListener("touchmove",e)}},[]),(0,s.useEffect)(()=>{if(e&&n){let t=e[i];c(n.find(e=>e.name===t))}},[i,e]),(0,s.useEffect)(()=>{let e=window.innerWidth;return e<=480?m(42):e<=570?m(54):m(82),window.addEventListener("resize",x)},[]),(0,r.jsx)("div",{className:"scroll-container",onWheel:n=>{let t=i+(n.deltaY>0?1:-1);t>=0&&t<e.length&&a(t)},onTouchMove:n=>{let t=n.touches[0].clientY,r=f.current?f.current:t;if(f.current=t,p.current+=r-t,Math.abs(p.current)>=d){let n=i+(p.current>0?1:-1);n>=0&&n<e.length&&(a(n),p.current=0)}},onTouchEnd:()=>{f.current=null,p.current=0},children:(0,r.jsx)("div",{className:"scroll-element",style:{transform:"translateY(calc(40% + ".concat(-i*d,"px))")},children:e.map((e,n)=>{let o=Math.abs(i-n);return(0,r.jsx)("div",{className:"scroll-item",style:{opacity:1-.3*o,fontWeight:i===n?"bold":"normal"},onClick:()=>a(n),onDoubleClick:()=>t(e),children:e},n)})})})},d=" // by Jeran Poehls\r\n\r\nout vec3 vOrigin;\r\nout vec3 vDirection;\r\nout vec3 aPosition;\r\n\r\nout vec2 Vuv;\r\n\r\nvoid main() {\r\n    vec4 worldPos = modelViewMatrix * vec4( position, 1.0 );\r\n\r\n    aPosition = position; //Pass out position for sphere frag\r\n    vOrigin = vec3( inverse( modelMatrix ) * vec4( cameraPosition, 1.0 ) ).xyz;\r\n    vDirection = position - vOrigin;\r\n    Vuv = uv;\r\n    gl_Position = projectionMatrix * worldPos;\r\n}",m=e=>{let{volTexture:n}=e,{shape:t,colormap:a,flipY:o}=(0,l.on)((0,u.k)(e=>({shape:e.shape,colormap:e.colormap,flipY:e.flipY}))),{valueRange:c,xRange:m,yRange:f,zRange:p,quality:x,animProg:h,cScale:g,cOffset:v,useFragOpt:y,transparency:S,nanTransparency:z,nanColor:w}=(0,l.Ws)((0,u.k)(e=>({valueRange:e.valueRange,xRange:e.xRange,yRange:e.yRange,zRange:e.zRange,quality:e.quality,animProg:e.animProg,cScale:e.cScale,cOffset:e.cOffset,useFragOpt:e.useFragOpt,transparency:e.transparency,nanTransparency:e.nanTransparency,nanColor:e.nanColor}))),b=t.y/t.x,P=(0,s.useMemo)(()=>new i.BKk({glslVersion:i.Wdf,uniforms:{map:{value:n},cmap:{value:a},cOffset:{value:v},cScale:{value:g},threshold:{value:new i.I9Y(c[0],c[1])},scale:{value:t},flatBounds:{value:new i.IUQ(-m[1],-m[0],p[0],p[1])},vertBounds:{value:new i.I9Y(f[0]*b,f[1]*b)},steps:{value:x},animateProg:{value:h},transparency:{value:S},nanAlpha:{value:1-z},nanColor:{value:new i.Q1f(w)}},vertexShader:d,fragmentShader:y?"// This is an optimized version of the original Volumetric shader\r\n\r\nprecision highp float;\r\nprecision highp sampler3D;\r\n\r\nin vec3 vOrigin;\r\nin vec3 vDirection;\r\n\r\nout vec4 color;\r\n\r\nuniform sampler3D map;\r\nuniform sampler2D cmap;\r\n\r\nuniform float cOffset;\r\nuniform float cScale;\r\nuniform vec3 scale;\r\nuniform vec2 threshold;\r\nuniform float steps;\r\nuniform vec4 flatBounds;\r\nuniform vec2 vertBounds;\r\nuniform float animateProg;\r\nuniform float transparency;\r\nuniform float nanAlpha;\r\nuniform vec3 nanColor;\r\n\r\nvec2 hitBox(vec3 orig, vec3 dir) {\r\n    vec3 box_min = vec3(-(scale * 0.5));\r\n    vec3 box_max = vec3(scale * 0.5);\r\n    vec3 inv_dir = 1.0 / dir;\r\n    vec3 tmin_tmp = (box_min - orig) * inv_dir;\r\n    vec3 tmax_tmp = (box_max - orig) * inv_dir;\r\n    vec3 tmin = min(tmin_tmp, tmax_tmp);\r\n    vec3 tmax = max(tmin_tmp, tmax_tmp);\r\n    float t0 = max(tmin.x, max(tmin.y, tmin.z));\r\n    float t1 = min(tmax.x, min(tmax.y, tmax.z));\r\n    return vec2(t0, t1);\r\n}\r\n\r\nfloat sample1( vec3 p ) {\r\n    return texture( map, p ).r;\r\n}\r\n\r\n#define epsilon 0.0001\r\n\r\nvoid main() {\r\n    vec3 rayDir = normalize(vDirection);\r\n    vec2 bounds = hitBox(vOrigin, rayDir);\r\n\r\n    if (bounds.x > bounds.y) discard;\r\n\r\n    bounds.x = max(bounds.x, 0.0);\r\n\r\n    vec3 p = vOrigin + bounds.x * rayDir;\r\n    vec3 inc = 1.0 / abs(rayDir);\r\n\r\n    //Step Sizes\r\n    float fineDelta = min(inc.x, min(inc.y, inc.z)) / steps;\r\n\r\n    float coarseDelta = min(inc.x, min(inc.y, inc.z))/50.;\r\n\r\n    float delta = fineDelta;\r\n\r\n    vec4 accumColor = vec4(0.0);\r\n    float alphaAcc = 0.0;\r\n\r\n    float t = bounds.x;\r\n    int countdown = 0;\r\n    bool useCoarseStep = false;\r\n\r\n    while (t < bounds.y) {\r\n        vec3 p = vOrigin + rayDir * t;\r\n        \r\n        // --- Boundary checks ---\r\n        if (p.x < flatBounds.x || p.x > flatBounds.y ||\r\n            p.z < flatBounds.z || p.z > flatBounds.w ||\r\n            p.y < vertBounds.x || p.y > vertBounds.y) {\r\n\r\n            t += useCoarseStep ? coarseDelta : fineDelta;\r\n            continue;\r\n        }\r\n\r\n        vec3 texCoord = p / scale + 0.5;\r\n        texCoord.z = mod(texCoord.z + animateProg, 1.0001);\r\n        float d = sample1(texCoord);\r\n\r\n        bool cond = nanAlpha == 0. ? (d > threshold.x) && (d < threshold.y) : (d > threshold.x) && (d < threshold.y+.01); //We skip over nans if the transparency is enabled\r\n        \r\n        if (cond) {\r\n            // Hit something interesting - switch to fine stepping\r\n            if (useCoarseStep) {\r\n                useCoarseStep = false;\r\n                countdown = 40;\r\n                // Step back to ensure we don't miss the boundary\r\n                t -= coarseDelta;\r\n                continue;\r\n            }\r\n            if (d == 1.){\r\n                accumColor.rgb += (1.0 - alphaAcc) * pow(nanAlpha, 5.) * nanColor.rgb;\r\n                alphaAcc += pow(nanAlpha, 5.);\r\n            }\r\n            else{\r\n                float sampLoc = (d - 0.5)*cScale + 0.5;\r\n                sampLoc = min(sampLoc+cOffset,0.99);\r\n                vec4 col = texture(cmap, vec2(sampLoc, 0.5));\r\n                float alpha = pow(max(sampLoc, 0.001), transparency);\r\n                accumColor.rgb += (1.0 - alphaAcc) * alpha * col.rgb;\r\n                alphaAcc += alpha * (1.0 - alphaAcc);\r\n            }      \r\n\r\n            if (alphaAcc >= 1.0) break;\r\n            \r\n            t += fineDelta;\r\n        }\r\n        else {\r\n            // Nothing interesting here\r\n            if (countdown > 0) {\r\n                countdown--;\r\n                t += fineDelta; // Continue with fine steps while countdown > 0\r\n            } else {\r\n                useCoarseStep = true;\r\n                t += coarseDelta; // Switch to coarse steps\r\n            }\r\n        }\r\n    }\r\n    accumColor.a = alphaAcc; // Set the final accumulated alpha\r\n    color = accumColor;\r\n    if (color.a == 0.0) discard;\r\n}\r\n":"// by Jeran Poehls\r\nprecision highp float;\r\nprecision highp sampler3D;\r\n\r\nin vec3 vOrigin;\r\nin vec3 vDirection;\r\n\r\nout vec4 color;\r\n\r\nuniform sampler3D map;\r\nuniform sampler2D cmap;\r\n\r\nuniform float cOffset;\r\nuniform float cScale;\r\nuniform vec3 scale;\r\nuniform vec2 threshold;\r\nuniform float steps;\r\nuniform vec4 flatBounds;\r\nuniform vec2 vertBounds;\r\nuniform float animateProg;\r\nuniform float transparency;\r\nuniform float nanAlpha;\r\nuniform vec3 nanColor;\r\n\r\n\r\nvec2 hitBox(vec3 orig, vec3 dir) {\r\n    vec3 box_min = vec3(-(scale * 0.5));\r\n    vec3 box_max = vec3(scale * 0.5);\r\n    vec3 inv_dir = 1.0 / dir;\r\n    vec3 tmin_tmp = (box_min - orig) * inv_dir;\r\n    vec3 tmax_tmp = (box_max - orig) * inv_dir;\r\n    vec3 tmin = min(tmin_tmp, tmax_tmp);\r\n    vec3 tmax = max(tmin_tmp, tmax_tmp);\r\n    float t0 = max(tmin.x, max(tmin.y, tmin.z));\r\n    float t1 = min(tmax.x, min(tmax.y, tmax.z));\r\n    return vec2(t0, t1);\r\n}\r\n\r\nfloat sample1( vec3 p ) {\r\n    return texture( map, p ).r;\r\n}\r\n\r\n#define epsilon 0.0001\r\n\r\nvoid main() {\r\n    vec3 rayDir = normalize(vDirection);\r\n    vec2 bounds = hitBox(vOrigin, rayDir);\r\n\r\n    if (bounds.x > bounds.y) discard;\r\n\r\n    bounds.x = max(bounds.x, 0.0);\r\n\r\n    vec3 p = vOrigin + bounds.x * rayDir;\r\n    vec3 inc = 1.0 / abs(rayDir);\r\n    float delta = min(inc.x, min(inc.y, inc.z));\r\n    delta /= steps;\r\n    vec4 accumColor = vec4(0.0);\r\n    float alphaAcc = 0.0;\r\n\r\n    for (float t = bounds.x; t < bounds.y; t += delta) {\r\n        p = vOrigin + rayDir * t;\r\n        if (p.x > -flatBounds.x || p.x < -flatBounds.y) { \r\n            continue;\r\n        }\r\n        if (-p.z > -flatBounds.z || -p.z < -flatBounds.w) {\r\n            continue;\r\n        }\r\n        if (p.y < vertBounds.x || p.y > vertBounds.y) {\r\n            continue;\r\n        }\r\n\r\n        vec3 texCoord = p / scale + 0.5;\r\n        texCoord.z = mod(texCoord.z + animateProg, 1.0001);\r\n        float d = sample1(texCoord);\r\n\r\n        bool cond = nanAlpha == 0. ? (d > threshold.x) && (d < threshold.y) : (d > threshold.x) && (d < threshold.y+.01); //We skip over nans if the transparency is enabled\r\n        \r\n        if (cond) {\r\n            if (d == 1.){\r\n                accumColor.rgb += (1.0 - alphaAcc) * pow(nanAlpha, 5.) * nanColor.rgb;\r\n                alphaAcc += pow(nanAlpha, 5.);\r\n            }\r\n            else{\r\n                float sampLoc = (d - 0.5)*cScale + 0.5;\r\n                sampLoc = min(sampLoc+cOffset,0.99);\r\n                vec4 col = texture(cmap, vec2(sampLoc, 0.5));\r\n                float alpha = pow(max(sampLoc, 0.001), transparency);\r\n                accumColor.rgb += (1.0 - alphaAcc) * alpha * col.rgb;\r\n                alphaAcc += alpha * (1.0 - alphaAcc);\r\n            }      \r\n\r\n            if (alphaAcc >= 1.0) break;\r\n        }\r\n    }\r\n\r\n    accumColor.a = alphaAcc; // Set the final accumulated alpha\r\n    color = accumColor;\r\n    if (color.a == 0.0) discard;\r\n}\r\n",transparent:!0,blending:i.NTi,depthWrite:!1,side:i.hsX}),[n,t,a,v,g,c,m,f,p,x,h,y,S,z,w]),C=(0,s.useMemo)(()=>new i.WBB(2,4),[]);return(0,s.useEffect)(()=>()=>{C.dispose()},[]),(0,r.jsx)(r.Fragment,{children:(0,r.jsx)("mesh",{geometry:C,scale:[1,o?-1:1,1],children:(0,r.jsx)("primitive",{attach:"material",object:P})})})};var f=t(8804);let p=e=>{let{ZarrDS:n}=e,[t,a]=(0,s.useState)(null),{setTimeSeries:o,setPlotDim:c,setDimCoords:d,updateTimeSeries:m,updateDimCoords:p}=(0,l.on)((0,u.k)(e=>({setTimeSeries:e.setTimeSeries,setPlotDim:e.setPlotDim,setDimCoords:e.setDimCoords,updateTimeSeries:e.updateTimeSeries,updateDimCoords:e.updateDimCoords}))),{shape:x,dimArrays:h,dimNames:g,dimUnits:v}=(0,l.on)((0,u.k)(e=>({shape:e.shape,dimArrays:e.dimArrays,dimNames:e.dimNames,dimUnits:e.dimUnits}))),y=(0,l.Ws)(e=>e.selectTS),S=(0,s.useRef)(null),z=(0,s.useMemo)(()=>new i.iNn(1,1,1),[]);return(0,s.useEffect)(()=>()=>{z.dispose()},[]),(0,r.jsxs)(r.Fragment,{children:[(0,r.jsx)("mesh",{geometry:z,scale:x,onClick:e=>{e.stopPropagation(),e.intersections.length>0&&y&&function(e){let t=e.point,r=e.uv,i=e.normal,s=(0,f._8)(i);if(s!=S.current&&(o({}),d({})),S.current=s,n){var l,u;let e=n.GetTimeSeries({uv:r,normal:i}),t=i.toArray().map((e,n)=>Math.abs(e)>0?n:null).filter(e=>null!==e);c(2-t[0]);let a=(0,f.jT)({normal:i,uv:r}).map((e,n)=>e?h[n][Math.round(e*h[n].length)]:null),o=g.filter((e,n)=>null!==a[n]),s=v.filter((e,n)=>null!==a[n]);a=a.filter(e=>null!==e);let d="".concat(a[0],"_").concat(a[1]);m({[d]:e}),p({[d]:{first:{name:o[0],loc:null!=(l=a[0])?l:0,units:s[0]},second:{name:o[1],loc:null!=(u=a[1])?u:0,units:s[1]},plot:{units:v[2-t[0]]}}})}a(t)}(e.intersections[0])},children:(0,r.jsx)("meshBasicMaterial",{transparent:!0,opacity:0})}),t&&(0,r.jsxs)("mesh",{position:t,scale:.01,children:[(0,r.jsx)("boxGeometry",{}),(0,r.jsx)("meshBasicMaterial",{color:"#ff0000"})]})]})},x=e=>{let{dimensions:n,ZarrDS:t,setters:i}=e,{width:a,height:o,depth:c}=n,{setPointIDs:d,setStride:m,setDimWidth:p}=i,x=(0,l.Ws)(e=>e.selectTS),h=a/o,g=c/o,{dimArrays:v,dimUnits:y,dimNames:S,strides:z,setPlotDim:w,setTimeSeries:b,updateTimeSeries:P,setDimCoords:C,updateDimCoords:D}=(0,l.on)((0,u.k)(e=>({dimArrays:e.dimArrays,dimUnits:e.dimUnits,dimNames:e.dimNames,strides:e.strides,setPlotDim:e.setPlotDim,setTimeSeries:e.setTimeSeries,updateTimeSeries:e.updateTimeSeries,setDimCoords:e.setDimCoords,updateDimCoords:e.updateDimCoords}))),k=(0,s.useRef)(null),M=(0,l.Ws)(e=>e.timeScale);return(0,r.jsxs)("mesh",{scale:[2*h,2,2*g*M],onClick:function(e){if(!x)return;let n=e.uv,r=e.normal,i=(0,f._8)(r);if(i!=k.current&&(b({}),C({}),d(Array(10).fill(-1))),k.current=i,t){var s,l;let e=t.GetTimeSeries({uv:n,normal:r}),i=r.toArray().map((e,n)=>Math.abs(e)>0?n:null).filter(e=>null!==e);w(2-i[0]);let u=(0,f.jT)({normal:r,uv:n}),x=u.map((e,n)=>e?v[n][Math.round(e*v[n].length-.5)]:null),h=S.filter((e,n)=>null!==x[n]),g=y.filter((e,n)=>null!==x[n]);x=x.filter(e=>null!==e);let b="".concat(x[0],"_").concat(x[1]);P({[b]:e}),D({[b]:{first:{name:h[0],loc:null!=(s=x[0])?s:0,units:g[0]},second:{name:h[1],loc:null!=(l=x[1])?l:0,units:g[1]},plot:{units:y[2-i[0]]}}});let C=[c,o,a].filter((e,n)=>null!=u[n]),k=[c,o,a].filter((e,n)=>null==u[n]),M=u.filter(e=>null!=e),j=z.filter((e,n)=>null!=u[n]),B=Math.round(M[0]*C[0]-.5),_=Math.round(M[1]*C[1]-.5),I=B*j[0]+_*j[1],O=z.filter((e,n)=>null==u[n]);p(k[0]),d(e=>[I,...e].slice(0,10)),m(O[0])}},children:[(0,r.jsx)("boxGeometry",{}),(0,r.jsx)("meshBasicMaterial",{transparent:!0,opacity:0})]})},h=e=>{let{textures:n,ZarrDS:t}=e,{texture:a,colormap:o}=n,c=(0,l.on)(e=>e.flipY),{scalePoints:d,scaleIntensity:m,pointSize:f,cScale:p,cOffset:h,valueRange:g,animProg:v,selectTS:y,timeScale:S,xRange:z,yRange:w,zRange:b}=(0,l.Ws)((0,u.k)(e=>({scalePoints:e.scalePoints,scaleIntensity:e.scaleIntensity,pointSize:e.pointSize,cScale:e.cScale,cOffset:e.cOffset,valueRange:e.valueRange,animProg:e.animProg,selectTS:e.selectTS,timeScale:e.timeScale,xRange:e.xRange,yRange:e.yRange,zRange:e.zRange}))),P=(0,l.$U)(e=>e.setOom),[C,D]=(0,s.useState)(Array(10).fill(-1)),[k,M]=(0,s.useState)(1),[j,B]=(0,s.useState)(0),{data:_,width:I,height:O,depth:A}=(0,s.useMemo)(()=>a instanceof i.dYF?{data:a.image.data,width:a.image.width,height:a.image.height,depth:a.image.depth}:(console.warn("Provided texture is not a Data3DTexture"),{data:[],width:0,height:0,depth:0}),[a]),U=(0,s.useMemo)(()=>I/O,[I,O]),Y=(0,s.useMemo)(()=>A/O,[A,O]),{positions:L,values:T}=(0,s.useMemo)(()=>{let e;try{e=new Float32Array(A*O*I*3)}catch(e){return P(!0),{positions:[],values:[]}}let n=new Uint8Array(A*O*I);for(let t=0;t<A;t++)for(let r=0;r<O;r++)for(let i=0;i<I;i++){let a=i+r*I+t*I*O,o=_[a]||0,s=i/(I-1)-.5,l=(r/(O-1)-.5)/U,u=(t/(A-1)-.5)*Y,c=3*a;e[c]=2*s,e[c+1]=2*l,e[c+2]=u,n[a]=o}return{positions:e,values:n}},[_,I,O,A]),V=(0,s.useMemo)(()=>{let e=new i.LoY;return e.setAttribute("position",new i.qtW(L,3)),e.setAttribute("value",new i.qtW(T,1)),e},[L,T]),R=(0,s.useMemo)(()=>new i.BKk({glslVersion:i.Wdf,uniforms:{pointSize:{value:f},cmap:{value:o},cOffset:{value:h},cScale:{value:p},valueRange:{value:new i.I9Y(g[0],g[1])},scalePoints:{value:d},scaleIntensity:{value:m},startIDs:{value:C},stride:{value:k},showTransect:{value:y},dimWidth:{value:j},timeScale:{value:S},animateProg:{value:v},depthRatio:{value:Y},flatBounds:{value:new i.IUQ(z[0],z[1],b[0]*Y/2,b[1]*Y/2)},vertBounds:{value:new i.I9Y(w[0]/U,w[1]/U)}},vertexShader:"attribute float value;\r\nout float vValue;\r\n\r\nflat out int highlight;\r\n\r\nuniform float pointSize;\r\nuniform bool scalePoints;\r\nuniform float scaleIntensity;\r\nuniform vec2 valueRange;\r\nuniform int[10] startIDs;\r\nuniform int stride;\r\nuniform int dimWidth;\r\nuniform bool showTransect;\r\nuniform float timeScale;\r\nuniform float animateProg;\r\nuniform float depthRatio;\r\nuniform vec4 flatBounds;\r\nuniform vec2 vertBounds;\r\n\r\nbool isValidPoint(){\r\n    for (int i = 0; i < 10; i++){\r\n        if (startIDs[i] == -1){\r\n            return false;\r\n        }\r\n        int rePos = gl_VertexID - startIDs[i];\r\n        bool isValid = rePos % stride == 0;\r\n        bool secondary = gl_VertexID < (startIDs[i] + dimWidth*stride) && gl_VertexID > startIDs[i];\r\n        isValid = isValid && secondary;\r\n        if (isValid){\r\n            return true;\r\n        }\r\n    }\r\n    return false;\r\n}\r\n\r\nvoid main() {\r\n    vValue = value/255.;\r\n    vec3 scaledPos = position;\r\n    scaledPos.z += depthRatio;\r\n    scaledPos.z = mod(scaledPos.z + animateProg*2.*depthRatio, 2.*depthRatio);\r\n    scaledPos.z -= depthRatio;\r\n\r\n    scaledPos.z *= timeScale;\r\n    gl_Position = projectionMatrix * modelViewMatrix * vec4(scaledPos, 1.0);\r\n    float pointScale = pointSize/gl_Position.w;\r\n    pointScale = scalePoints ? pointScale*pow(vValue,scaleIntensity) : pointScale;\r\n\r\n    bool isValid = isValidPoint();\r\n    highlight = isValid ? 1 : 0;\r\n    \r\n    if (value == 255. || (pointScale*gl_Position.w < 0.75 && scalePoints)){ //Hide points that are invisible or get too small when scalled\r\n        gl_Position = vec4(2.0, 2.0, 2.0, 1.0);\r\n    }\r\n\r\n    if (vValue < valueRange.x || vValue > valueRange.y){ //Hide points that are outside of value range\r\n        gl_Position = vec4(2.0, 2.0, 2.0, 1.0);\r\n    }\r\n\r\n    vec2 scaledZBounds = vec2(flatBounds.z,  flatBounds.w) * vec2(timeScale);\r\n    bool xCheck = scaledPos.x < flatBounds.x || scaledPos.x > flatBounds.y;\r\n    bool zCheck = scaledPos.z < scaledZBounds.x || scaledPos.z > scaledZBounds.y;\r\n    bool yCheck = scaledPos.y < vertBounds.x || scaledPos.y> vertBounds.y;\r\n\r\n    if (xCheck || zCheck || yCheck){ //Hide points that are clipped\r\n        gl_Position = vec4(2.0, 2.0, 2.0, 1.0);\r\n    }\r\n    \r\n    if (showTransect){\r\n        gl_PointSize = isValid ? max(pointScale*5. , pointScale+80./gl_Position.w) : pointScale;\r\n    }\r\n    else{\r\n        gl_PointSize =  pointScale;\r\n    }\r\n\r\n}\r\n",fragmentShader:"out vec4 Color;\r\n\r\nin float vValue;\r\nflat in int highlight;\r\n\r\n\r\nuniform sampler2D cmap;\r\nuniform float cScale;\r\nuniform float cOffset;\r\nuniform bool showTransect;\r\n\r\nvoid main() {\r\n\r\n    float sampLoc = vValue == 1. ? vValue : (vValue - 0.5)*cScale + 0.5;\r\n    sampLoc = vValue == 1. ? vValue : min(sampLoc+cOffset,0.99);\r\n    vec4 color = texture(cmap, vec2(sampLoc, 0.5));\r\n    color.a = 1.;\r\n    Color = color;\r\n    if (showTransect){\r\n        Color = highlight == 1 ? color : color * vec4(vec3(0.4),1.);\r\n    }\r\n    else{\r\n        Color = color;\r\n    }\r\n\r\n}\r\n",depthWrite:!0,transparent:!0,blending:i.NTi,side:i.$EB}),[f,o,h,p,g,d,m,C,k,y,v,S,Y,U,z,w,b]);return(0,r.jsxs)(r.Fragment,{children:[(0,r.jsx)("mesh",{scale:[1,c?-1:1,1],children:(0,r.jsx)("points",{geometry:V,material:R})}),(0,r.jsx)(x,{dimensions:{width:I,height:O,depth:A},ZarrDS:t,setters:{setPointIDs:D,setStride:M,setDimWidth:B}})]})};var g=t(5010),v=t(8896);t(9519);var y=t(1279);t(596);var S=t(5442),z=t(3964);function w(e){let{...n}=e;return(0,r.jsx)(S.bL,{"data-slot":"dropdown-menu",...n})}function b(e){let{...n}=e;return(0,r.jsx)(S.l9,{"data-slot":"dropdown-menu-trigger",...n})}function P(e){let{className:n,sideOffset:t=4,...i}=e;return(0,r.jsx)(S.ZL,{children:(0,r.jsx)(S.UC,{"data-slot":"dropdown-menu-content",sideOffset:t,className:(0,z.cn)("bg-popover text-popover-foreground data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0 data-[state=closed]:zoom-out-95 data-[state=open]:zoom-in-95 data-[side=bottom]:slide-in-from-top-2 data-[side=left]:slide-in-from-right-2 data-[side=right]:slide-in-from-left-2 data-[side=top]:slide-in-from-bottom-2 z-50 max-h-(--radix-dropdown-menu-content-available-height) min-w-[8rem] origin-(--radix-dropdown-menu-content-transform-origin) overflow-x-hidden overflow-y-auto rounded-md border p-1 shadow-md",n),...i})})}function C(e){let{...n}=e;return(0,r.jsx)(S.YJ,{"data-slot":"dropdown-menu-group",...n})}function D(e){let{className:n,inset:t,variant:i="default",...a}=e;return(0,r.jsx)(S.q7,{"data-slot":"dropdown-menu-item","data-inset":t,"data-variant":i,className:(0,z.cn)("focus:bg-accent focus:text-accent-foreground data-[variant=destructive]:text-destructive data-[variant=destructive]:focus:bg-destructive/10 dark:data-[variant=destructive]:focus:bg-destructive/20 data-[variant=destructive]:focus:text-destructive data-[variant=destructive]:*:[svg]:!text-destructive [&_svg:not([class*='text-'])]:text-muted-foreground relative flex cursor-default items-center gap-2 rounded-sm px-2 py-1.5 text-sm outline-hidden select-none data-[disabled]:pointer-events-none data-[disabled]:opacity-50 data-[inset]:pl-8 [&_svg]:pointer-events-none [&_svg]:shrink-0 [&_svg:not([class*='size-'])]:size-4",n),...a})}function k(e){let{className:n,...t}=e;return(0,r.jsx)(S.wv,{"data-slot":"dropdown-menu-separator",className:(0,z.cn)("bg-border -mx-1 my-1 h-px",n),...t})}let M=s.memo(function(){let{showPoints:e,linePointSize:n,pointColor:t,useCustomPointColor:i,setLinePointSize:a,setPointColor:o,setUseCustomPointColor:s}=(0,l.Ws)((0,u.k)(e=>({showPoints:e.showPoints,linePointSize:e.linePointSize,pointColor:e.pointColor,useCustomPointColor:e.useCustomPointColor,setLinePointSize:e.setLinePointSize,setPointColor:e.setPointColor,setUseCustomPointColor:e.setUseCustomPointColor})));return e?(0,r.jsxs)(r.Fragment,{children:[(0,r.jsxs)("div",{className:"w-full flex items-center",children:[(0,r.jsx)("div",{className:"w-[40%]",children:(0,r.jsx)("b",{children:"Point Size"})}),(0,r.jsx)("input",{type:"range",min:1,max:10,step:.1,value:n,onChange:e=>a(parseFloat(e.target.value))})]}),(0,r.jsxs)("div",{className:"w-full flex items-center",children:[(0,r.jsx)("div",{className:"w-[40%]",children:(0,r.jsx)("b",{children:"Point Color"})}),i&&(0,r.jsx)("input",{type:"color",title:"Point Color",value:t,onChange:e=>o(e.target.value)}),(0,r.jsxs)(y.$,{className:"h-8 px-2 py-1",variant:"outline",onClick:()=>s(!i),children:["Use",i?" Browzarr Color":" Custom Color"]})]})]}):null}),j=s.memo(function(){let{lineWidth:e,lineColor:n,useLineColor:t,lineResolution:i,useCustomColor:a,setLineWidth:o,setLineColor:s,setUseLineColor:c,setLineResolution:d,setUseCustomColor:m}=(0,l.Ws)((0,u.k)(e=>({lineWidth:e.lineWidth,lineColor:e.lineColor,useLineColor:e.useLineColor,lineResolution:e.lineResolution,useCustomColor:e.useCustomColor,setLineWidth:e.setLineWidth,setLineColor:e.setLineColor,setUseLineColor:e.setUseLineColor,setLineResolution:e.setLineResolution,setUseCustomColor:e.setUseCustomColor})));return(0,r.jsxs)(r.Fragment,{children:[(0,r.jsxs)("div",{className:"w-full flex items-center",children:[(0,r.jsx)("div",{className:"w-[40%]",children:(0,r.jsx)("b",{children:"Line Width"})}),(0,r.jsx)("input",{type:"range",min:1,max:10,step:.2,value:e,onChange:e=>o(parseFloat(e.target.value))})]}),(0,r.jsxs)("div",{className:"w-full flex items-center",children:[(0,r.jsx)("div",{className:"w-[40%]",children:(0,r.jsx)("b",{children:"Line Resolution"})}),(0,r.jsx)("input",{type:"range",min:1,max:10,step:1,value:i,onChange:e=>d(parseFloat(e.target.value))})]}),(0,r.jsxs)("div",{className:"w-full flex items-center",children:[(0,r.jsx)("div",{className:"w-[40%]",children:(0,r.jsx)("b",{children:"Line Color"})}),a&&(0,r.jsx)("input",{type:"color",title:"Line Color",value:n,onChange:e=>s(e.target.value)}),!a&&(0,r.jsxs)(y.$,{className:"h-8 px-2 py-5",variant:"outline",onClick:()=>c(!t),children:["Use ",(0,r.jsx)("br",{}),t?"Individual Color":"Plot Color"]}),(0,r.jsxs)(y.$,{className:"h-8 px-2 py-5",variant:"outline",onClick:()=>m(!a),children:["Use ",(0,r.jsx)("br",{}),a?"Browzarr Color":"Custom Color"]})]})]})}),B=s.memo(function(){let{showPoints:e,setShowPoints:n}=(0,l.Ws)((0,u.k)(e=>({showPoints:e.showPoints,setShowPoints:e.setShowPoints})));return(0,r.jsx)("div",{className:"plotline-options",children:(0,r.jsxs)(w,{children:[(0,r.jsx)(b,{asChild:!0,children:(0,r.jsx)(y.$,{className:"cursor-pointer",variant:"outline",children:"Line Options"})}),(0,r.jsxs)(P,{className:"w-80 items-center",align:"center",children:[(0,r.jsx)(C,{onClick:e=>e.preventDefault(),children:(0,r.jsx)(D,{children:(0,r.jsx)(y.$,{variant:"outline",onClick:t=>{t.preventDefault(),n(!e)},children:e?"Hide Points":"Show Points"})})}),(0,r.jsx)(M,{}),(0,r.jsx)(k,{}),(0,r.jsx)(j,{})]})]})})});var _=t(1252),I=t(9797);function O(e){let{pointID:n,pointLoc:t,showPointInfo:i,plotUnits:a}=e,{plotDim:o,dimArrays:c,dimNames:d,dimUnits:m,timeSeries:p}=(0,l.on)((0,u.k)(e=>({plotDim:e.plotDim,dimArrays:e.dimArrays,dimNames:e.dimNames,dimUnits:e.dimUnits,timeSeries:e.timeSeries}))),x=0,h=0;if(Object.entries(n).length>0&&Object.entries(p).length>0){let[e,t]=Object.entries(n)[0];x=p[e][t],h=c[o][t]}let[g,v]=t,[y,S]=(0,s.useState)(!1);return(0,s.useEffect)(()=>{if(!i){let e=setTimeout(()=>{S(!1)},100);return()=>clearTimeout(e)}S(!0)},[i]),(0,r.jsx)(r.Fragment,{children:y&&(0,r.jsxs)("div",{className:"point-info",style:{left:"".concat(g,"px"),top:"".concat(v,"px")},children:["".concat(x.toFixed(2)).concat(a),(0,r.jsx)("br",{}),"".concat(d[o],": ").concat((0,f.SB)(h,m[o]),"       \n        ")]})})}function A(){let{coords:e,timeSeries:n,setDimCoords:t,setTimeSeries:i}=(0,l.on)((0,u.k)(e=>({coords:e.dimCoords,timeSeries:e.timeSeries,setDimCoords:e.setDimCoords,setTimeSeries:e.setTimeSeries}))),[a,o]=(0,s.useState)(!1),c=(0,s.useRef)([0,Math.round(.255*window.innerHeight)]),d=(0,s.useRef)([0,Math.round(.255*window.innerHeight)]),[m,p]=(0,s.useState)([0,Math.round(.255*window.innerHeight)]);function x(e){if(a){let n=c.current[0]-e.clientX,t=c.current[1]-e.clientY,r=Math.min(Math.max(d.current[0]-n,10),window.innerWidth-120),i=Math.max(d.current[1]+t,0);p([Math.min(r,window.innerWidth-100),Math.min(i,window.innerHeight-100)])}}function h(){o(!1)}return(0,s.useEffect)(()=>(a&&(document.addEventListener("mousemove",x),document.addEventListener("mouseup",h)),()=>{document.removeEventListener("mousemove",x),document.removeEventListener("mouseup",h)}),[a]),(0,r.jsx)(r.Fragment,{children:(0,r.jsx)("div",{className:"coord-container",onPointerDown:function(e){c.current=[e.clientX,e.clientY],d.current=[...m],o(!0)},onPointerMove:x,onPointerUp:()=>o(!1),style:{left:"".concat(m[0],"px"),bottom:"".concat(m[1],"px")},children:Object.keys(e).length>0&&Object.keys(e).reverse().map((a,o)=>(0,r.jsxs)("div",{className:"plot-coords",style:{background:"rgb(".concat((0,_.md)(o/10,"Paired"),")"),justifyContent:"space-between"},children:[(0,r.jsx)("b",{children:"".concat(e[a].first.name,": ")}),"".concat((0,f.SB)(e[a].first.loc,e[a].first.units)),(0,r.jsx)("br",{}),(0,r.jsx)("b",{children:"".concat(e[a].second.name,": ")}),"".concat((0,f.SB)(e[a].second.loc,e[a].second.units)),(0,r.jsx)(I.Xr4,{onClick:()=>(function(r){let{[r]:a,...o}=e;t(o);let{[r]:s,...l}=n;i(l)})(a),color:"red",style:{cursor:"pointer",zIndex:3}})]},a))})})}function U(){let[e,n]=(0,s.useState)({}),[t,i]=(0,s.useState)([0,0]),[a,o]=(0,s.useState)(!1),[u,c]=(0,s.useState)(Math.round(window.innerHeight-.25*window.innerHeight)),d=(0,l.on)(e=>e.metadata),m=d?d.units:"Default",[f,p]=(0,s.useState)(1),[x,h]=(0,s.useState)(1);(0,s.useEffect)(()=>{let e=()=>{let e=Math.round(window.innerHeight-.25*window.innerHeight);c(e),document.documentElement.style.setProperty("--plot-height","".concat(e,"px"))};return window.addEventListener("orientationchange",e),window.addEventListener("resize",e),()=>{window.removeEventListener("orientationchange",e),window.removeEventListener("resize",e)}},[]),(0,s.useEffect)(()=>{document.documentElement.style.setProperty("--plot-height","".concat(u,"px"))},[u]);let y=window.innerHeight-u>=10;return(0,r.jsxs)(r.Fragment,{children:[!y&&(0,r.jsx)(v.de,{onClick:()=>{c(window.innerHeight-60)}}),y&&(0,r.jsxs)("div",{className:"plot-canvas",children:[(0,r.jsx)(B,{}),a&&(0,r.jsx)(O,{pointID:e,pointLoc:t,showPointInfo:a,plotUnits:m}),(0,r.jsx)(v.A,{height:u,setHeight:c}),(0,r.jsx)(v.gj,{scale:f,setScale:p}),(0,r.jsx)(v.LC,{scale:x,setScale:h}),(0,r.jsxs)(g.Hl,{orthographic:!0,camera:{position:[0,0,100]},frameloop:"demand",children:[(0,r.jsx)(en,{height:u,yScale:f,pointSetters:{setPointID:n,setPointLoc:i,setShowPointInfo:o},xScale:x}),(0,r.jsx)(V,{height:u,yScale:f,xScale:x})]}),(0,r.jsx)(A,{})]})]})}var Y=t(6350),L=t(3738),T=t(5102);function V(e){let{colorTicks:n="grey",tickSize:t=4,fontSize:i=14,showGrid:a=!0,gridOpacity:o=.5,height:c,yScale:d=1,xScale:m=1}=e,{camera:p}=(0,T.C)(),[x,h]=(0,s.useState)({left:0,right:0,top:0,bottom:0}),{dimCoords:g,dimArrays:v,plotDim:y,valueScales:S}=(0,l.on)((0,u.k)(e=>({dimCoords:e.dimCoords,dimArrays:e.dimArrays,plotDim:e.plotDim,valueScales:e.valueScales}))),z=v[y],w=z.length,b=S.maxVal-S.minVal,P=(0,s.useMemo)(()=>{let e=["Jan","Feb","Mar","Apr","May","Jun","Jul","Aug","Sep","Oct","Nov","Dec"];if(z){if(z.every(e=>"bigint"==typeof e)){let n=Object.keys(g).length>0?Object.keys(g)[0]:null,t=n?(0,f.lt)(g[n].plot.units):1,r=[];for(let n=0;n<z.length;n++){let i=new Date(Number(z[n])*t),a="".concat(i.getDate().toString().padStart(2,"0")," ").concat(e[i.getMonth()],"\n").concat(i.getFullYear());r.push(a)}return r}return z.map(e=>String(e))}},[z,g]),C=(0,s.useMemo)(()=>{let e=window.innerWidth,n=window.innerHeight-c;return{left:-e/2+p.position.x,right:e/2+p.position.x,top:n/2+p.position.y,bottom:-n/2+p.position.y}},[]),[D,k]=(0,s.useState)(p.zoom),M=(0,s.useMemo)(()=>{let e=1/p.zoom;return{tickSize:t*e,fontSize:i/e,labelOffset:t*e}},[p.zoom,t,i]);(0,T.D)(()=>{p.zoom!==D&&k(p.zoom);let e=window.innerWidth/p.zoom,n=(window.innerHeight-c)/p.zoom,t={left:-e/2+p.position.x,right:e/2+p.position.x,top:n/2+p.position.y,bottom:-n/2+p.position.y};JSON.stringify(x)!=JSON.stringify(t)&&h(t)});let j=(0,s.useRef)(null),B=(0,s.useRef)(null);(0,s.useEffect)(()=>(j.current&&clearTimeout(j.current),B.current&&(j.current=setTimeout(()=>{B.current&&B.current.reset()},100)),()=>{null!==j.current&&clearTimeout(j.current)}),[c]);let _=(x.top+x.bottom)/2,I=(x.left+x.right)/2;return(0,r.jsxs)("group",{children:[a&&(0,r.jsxs)(r.Fragment,{children:[Array.from({length:10},(e,t)=>{var i;if(0===t||9===t)return null;let a=+Math.round(x.left/1)+(Math.round(x.right/1)-Math.round(x.left/1))*(t/9),l=a/m/(C.right-C.left)+.5;return(0,r.jsxs)(s.Fragment,{children:[(0,r.jsx)("group",{position:[a,_,0],children:(0,r.jsxs)("line",{children:[(0,r.jsx)("bufferGeometry",{children:(0,r.jsx)("float32BufferAttribute",{attach:"attributes-position",args:[new Float32Array([0,x.top-_,0,0,x.bottom-_,0]),3]})}),(0,r.jsx)("lineDashedMaterial",{color:n,opacity:o,transparent:!0,dashSize:.5,gapSize:.5})]},"vgrid-".concat(t))}),(0,r.jsxs)("group",{position:[a,x.top,0],children:[(0,r.jsxs)("line",{children:[(0,r.jsx)("bufferGeometry",{children:(0,r.jsx)("float32BufferAttribute",{attach:"attributes-position",args:[new Float32Array([0,0,0,0,-M.tickSize,0]),3]})}),(0,r.jsx)("lineBasicMaterial",{color:n})]}),0!==t&&9!==t&&(0,r.jsx)(Y.E,{position:[0,M.tickSize/4-M.labelOffset,0],fontSize:M.fontSize/D**2,color:n,anchorX:"center",anchorY:"top",children:null!=(i=null==P?void 0:P[Math.round(l*w-.5)])?i:""})]},"top-tick-".concat(t))]},"vert-group-".concat(t))}),Array.from({length:8},(e,t)=>{if(0===t||7===t)return null;let i=x.bottom+(x.top-x.bottom)*(t/7),a=i/d/(x.top-x.bottom)/D+.5;return(0,r.jsxs)(s.Fragment,{children:[(0,r.jsx)("group",{position:[I,i,0],children:(0,r.jsxs)("line",{children:[(0,r.jsx)("bufferGeometry",{children:(0,r.jsx)("float32BufferAttribute",{attach:"attributes-position",args:[new Float32Array([x.left-I,0,0,x.right-I,0,0]),3]})}),(0,r.jsx)("lineDashedMaterial",{color:n,opacity:o,transparent:!0,dashSize:0,gapSize:.5,linewidth:1})]})},"hgrid-".concat(t)),(0,r.jsxs)("group",{position:[x.right,i,0],children:[(0,r.jsxs)("line",{children:[(0,r.jsx)("bufferGeometry",{children:(0,r.jsx)("float32BufferAttribute",{attach:"attributes-position",args:[new Float32Array([0,0,0,-M.tickSize,0,0]),3]})}),(0,r.jsx)("lineBasicMaterial",{color:n})]}),0!==t&&7!==t&&(0,r.jsx)(Y.E,{position:[-M.tickSize-M.labelOffset,0,0],fontSize:M.fontSize/D**2,color:n,anchorX:"right",anchorY:"middle",children:(S.minVal+a*b).toFixed(1)})]},"right-tick-".concat(t))]},"vert-group-".concat(t))})]}),(0,r.jsx)(L.N,{ref:B,enableRotate:!1,enablePan:!0,enableZoom:!0,zoomSpeed:.85,maxDistance:500,maxZoom:20,minZoom:.5})]})}var R=t(21);t(6469);let E=e=>{let{loc:n,show:t,info:i}=e,{dimNames:a,dimUnits:o}=(0,l.on)((0,u.k)(e=>({dimNames:e.dimNames,dimUnits:e.dimUnits}))),c=(0,l.r2)(e=>e.axis),d=(0,s.useMemo)(()=>a.length<3?[a[0],a[1]]:a.filter((e,n)=>n!=c),[a,c]),m=(0,s.useMemo)(()=>a.length<3?[o[0],o[1]]:o.filter((e,n)=>n!=c),[o,c]);return(0,r.jsxs)("div",{className:"analysis-overlay",style:{left:"".concat(n[0]+10,"px"),top:"".concat(n[1]+10,"px"),display:t?"":"none"},children:["".concat(d[0],": ").concat(t&&(0,f.SB)(i[0],m[0])),(0,r.jsx)("br",{}),"".concat(d[1],": ").concat(t&&(0,f.SB)(i[1],m[1])),(0,r.jsx)("br",{}),"Value: ".concat(Math.round(100*i[2])/100)]})};var G=t(7556);let F="\n    struct Params {\n        zStride: u32,\n        yStride: u32,\n        xStride: u32,\n        xSize: u32,\n        ySize: u32,\n        reduceDim: u32,\n        dimLength: u32,\n    };\n    @group(0) @binding(0) var<storage, read> inputData: array<f32>;\n    @group(0) @binding(1) var<storage, read_write> outputData: array<f32>;\n    @group(0) @binding(2) var<uniform> params: Params;\n\n    @compute @workgroup_size(16, 16, 1)\n    fn main(@builtin(global_invocation_id) global_id: vec3<u32>) {\n        let zStride = params.zStride;\n        let yStride = params.yStride;\n        let xStride = params.xStride;\n        let xSize = params.xSize;\n        let ySize = params.ySize;\n        let reduceDim = params.reduceDim;\n        let dimLength = params.dimLength;\n                        \n        let outX = global_id.y;\n        let outY = global_id.x;\n        \n        if (outX >= xSize || outY >= ySize) {\n            return;\n        }\n",N="\n    struct Params {\n        xStride: u32,\n        yStride: u32,\n        zStride: u32,\n        xSize: u32,\n        ySize: u32,\n        zSize: u32,\n        workGroups: vec3<u32>,\n        kernelSize: u32,\n        kernelDepth: u32\n    };\n    @group(0) @binding(0) var<storage, read> inputData: array<f32>;\n    @group(0) @binding(1) var<storage, read_write> outputData: array<f32>;\n    @group(0) @binding(2) var<uniform> params: Params;\n\n    @compute @workgroup_size(4, 4, 4)\n    fn main(@builtin(global_invocation_id) global_id: vec3<u32>) {\n        let zStride = params.zStride;\n        let yStride = params.yStride;\n        let xStride = params.xStride; \n        let xSize = params.xSize;\n        let ySize = params.ySize;\n        let zSize = params.zSize; \n        let workGroups = params.workGroups;\n        let kernelSize = params.kernelSize;\n        let kernelDepth = params.kernelDepth;\n\n        let outX = global_id.x; \n        let outY = global_id.y;\n        let outZ = global_id.z; \n\n        if (outX >= xSize || outY >= ySize || outZ >= zSize) {\n            return;\n        }\n\n        let total_threads_per_slice = workGroups.x * workGroups.y * 16;\n        let globalIdx = global_id.z * total_threads_per_slice + \n                        global_id.y * (workGroups.x * 4) + \n                        global_id.x;\n\n        let xy_radius: i32 = i32(kernelSize/2u);\n        let z_radius: i32 = i32(kernelDepth/2u);\n\n        var xyOffset: i32 = 0; //These offsets are for kernelsizes of 1. I didn't wanna rewrite everything else for that case\n        var zOffset: i32 = 0;\n        if (xy_radius == 0){\n            xyOffset = -1;\n        }\n        if (z_radius == 0){\n            zOffset = -1;\n        }\n",W={Mean:"\n    ".concat(F,"\n        var sum: f32 = 0.0;\n        \n        // Iterate along the dimension we're averaging\n        if (reduceDim == 0u) { // Average along Z\n            let cCoord = outX * xStride + outY * yStride;\n            for (var z: u32 = 0u; z < dimLength; z++) {\n                let inputIndex = cCoord + (z * zStride);\n                sum += inputData[inputIndex];\n            }\n        } else if (reduceDim == 1u) { // Average along Y\n            let cCoord = outX * xStride + outY * zStride;\n            for (var y: u32 = 0u; y < dimLength; y++) {\n                let inputIndex = cCoord + (y * yStride);\n                sum += inputData[inputIndex];\n            }\n        } else { // Average along X\n            let cCoord = outX * yStride + outY * zStride;\n            for (var x: u32 = 0u; x < dimLength; x++) {\n                let inputIndex = cCoord + (x * xStride);\n                sum += inputData[inputIndex];\n            }\n        }\n        \n        let outputIndex = outY * xSize + outX;\n        outputData[outputIndex] = sum / f32(dimLength);\n    }\n"),Min:"\n    ".concat(F,"\n        var min: f32 = 1e12;\n        \n        // Iterate along the dimension we're averaging\n        if (reduceDim == 0u) { // Average along Z\n            let cCoord = outX * xStride + outY * yStride;\n            for (var z: u32 = 0u; z < dimLength; z++) {\n                let inputIndex = cCoord + (z * zStride);\n                let newMin = inputData[inputIndex];\n                if (newMin < min) {\n                    min = newMin;\n                }\n            }\n        } else if (reduceDim == 1u) { // Average along Y\n            let cCoord = outX * xStride + outY * zStride;\n            for (var y: u32 = 0u; y < dimLength; y++) {\n                let inputIndex = cCoord + (y * yStride);\n                let newMin = inputData[inputIndex];\n                if (newMin < min) {\n                    min = newMin;\n                }\n            }\n        } else { // Average along X\n            let cCoord = outX * yStride + outY * zStride;\n            for (var x: u32 = 0u; x < dimLength; x++) {\n                let inputIndex = cCoord + (x * xStride);\n                let newMin = inputData[inputIndex];\n                if (newMin < min) {\n                    min = newMin;\n                }\n            }\n        }\n        \n        let outputIndex = outY * xSize + outX;\n        outputData[outputIndex] = min;\n    }\n"),Max:"\n    ".concat(F,"\n        \n        var max: f32 = -1e12;\n        \n        // Iterate along the dimension we're averaging\n        if (reduceDim == 0u) { // Average along Z\n            let cCoord = outX * xStride + outY * yStride;\n            for (var z: u32 = 0u; z < dimLength; z++) {\n                let inputIndex = cCoord + (z * zStride);\n                let newMax = inputData[inputIndex];\n                if (newMax > max) {\n                    max = newMax;\n                }\n            }\n        } else if (reduceDim == 1u) { // Average along Y\n            let cCoord = outX * xStride + outY * zStride;\n            for (var y: u32 = 0u; y < dimLength; y++) {\n                let inputIndex = cCoord + (y * yStride);\n                let newMax = inputData[inputIndex];\n                if (newMax > max) {\n                    max = newMax;\n                }\n            }\n        } else { // Average along X\n            let cCoord = outX * yStride + outY * zStride;\n            for (var x: u32 = 0u; x < dimLength; x++) {\n                let inputIndex = cCoord + (x * xStride);\n                let newMax = inputData[inputIndex];\n                if (newMax > max) {\n                    max = newMax;\n                }\n            }\n        }\n        \n        let outputIndex = outY * xSize + outX;\n        outputData[outputIndex] = max;\n    }\n"),StDev:"\n    ".concat(F,"\n        var sum: f32 = 0.0;\n        // Iterate along the dimension we're averaging\n        if (reduceDim == 0u) { // Average along Z\n            let cCoord = outX * xStride + outY * yStride;\n            for (var z: u32 = 0u; z < dimLength; z++) {\n                let inputIndex = cCoord + (z * zStride);\n                sum += inputData[inputIndex];\n            }\n        } else if (reduceDim == 1u) { // Average along Y\n            let cCoord = outX * xStride + outY * zStride;\n            for (var y: u32 = 0u; y < dimLength; y++) {\n                let inputIndex = cCoord + (y * yStride);\n                sum += inputData[inputIndex];\n            }\n        } else { // Average along X\n            let cCoord = outX * yStride + outY * zStride;\n            for (var x: u32 = 0u; x < dimLength; x++) {\n                let inputIndex = cCoord + (x * xStride);\n                sum += inputData[inputIndex];\n            }\n        }\n        \n        let mean: f32 = sum / f32(dimLength);\n\n        var squaredDiffSum: f32 = 0.0;\n\n        // Iterate along the dimension again\n        if (reduceDim == 0u) { // Average along Z\n            let cCoord = outX * xStride + outY * yStride;\n            for (var z: u32 = 0u; z < dimLength; z++) {\n                let inputIndex = cCoord + (z * zStride);\n                let diff: f32 = mean - inputData[inputIndex];\n                squaredDiffSum += diff*diff;\n            }\n        } else if (reduceDim == 1u) { // Average along Y\n            let cCoord = outX * xStride + outY * zStride;\n            for (var y: u32 = 0u; y < dimLength; y++) {\n                let inputIndex = cCoord + (y * yStride);\n                let diff: f32 = mean - inputData[inputIndex];\n                squaredDiffSum += diff*diff;\n            }\n        } else { // Average along X\n            let cCoord = outX * yStride + outY * zStride;\n            for (var x: u32 = 0u; x < dimLength; x++) {\n                let inputIndex = cCoord + (x * xStride);\n                let diff: f32 = mean - inputData[inputIndex];\n                squaredDiffSum += diff*diff;\n            }\n        }\n\n        let stDev: f32 = sqrt(squaredDiffSum / f32(dimLength));\n        let outputIndex = outY * xSize + outX;\n        outputData[outputIndex] = stDev;\n    }\n")},X={Mean:"\n        ".concat(N,"    \n        var sum: f32 = 0.0;\n        var count: u32 = 0u;\n        for (var kx: i32 = -xy_radius + xyOffset; kx < xy_radius; kx++) {\n            for (var ky: i32 = -xy_radius + xyOffset; ky < xy_radius; ky++) {\n                for (var kz: i32 = -z_radius + zOffset; kz < z_radius; kz++){\n                    let in_coord = vec3<i32>(global_id) + vec3<i32>(kx, ky, kz);\n\n                    if (in_coord.x >= 0 && in_coord.x < i32(xSize) &&\n                        in_coord.y >= 0 && in_coord.y < i32(ySize) &&\n                        in_coord.z >= 0 && in_coord.z < i32(zSize)) { //Ensure the sampled point is within 3D dataspace\n                        let xOffset = kx * i32(xStride);\n                        let yOffset = ky * i32(yStride);\n                        let zOffset = kz * i32(zStride);\n                        let newIdx = i32(globalIdx) + xOffset + yOffset + zOffset;\n\n                        sum += inputData[u32(newIdx)];\n                        count ++;\n                    }\n                }\n            }\n        }\n        \n        outputData[globalIdx] = sum / f32(count);\n    }\n"),Min:"\n    ".concat(N,"  \n        var minVal: f32 = 1e12;\n        var count: u32 = 0u;\n        for (var kx: i32 = -xy_radius + xyOffset; kx < xy_radius; kx++) {\n            for (var ky: i32 = -xy_radius + xyOffset; ky < xy_radius; ky++) {\n                for (var kz: i32 = -z_radius + zOffset; kz < z_radius; kz++){\n                    let in_coord = vec3<i32>(global_id) + vec3<i32>(kx, ky, kz);\n\n                    if (in_coord.x >= 0 && in_coord.x < i32(xSize) &&\n                        in_coord.y >= 0 && in_coord.y < i32(ySize) &&\n                        in_coord.z >= 0 && in_coord.z < i32(zSize)) { //Ensure the sampled point is within 3D dataspace\n                        let xOffset = kx * i32(xStride);\n                        let yOffset = ky * i32(yStride);\n                        let zOffset = kz * i32(zStride);\n                        let newIdx = i32(globalIdx) + xOffset + yOffset + zOffset;\n                        let sampledVal = inputData[u32(newIdx)];\n                        if (sampledVal < minVal){\n                            minVal = sampledVal;\n                        }\n                    }\n                }\n            }\n        }\n        \n        outputData[globalIdx] = minVal;\n    }\n"),Max:"\n    ".concat(N,"  \n\n        var maxVal: f32 = -1e12;\n        var count: u32 = 0u;\n        for (var kx: i32 = -xy_radius + xyOffset; kx < xy_radius; kx++) {\n            for (var ky: i32 = -xy_radius + xyOffset; ky < xy_radius; ky++) {\n                for (var kz: i32 = -z_radius + zOffset; kz < z_radius; kz++){\n                    let in_coord = vec3<i32>(global_id) + vec3<i32>(kx, ky, kz);\n\n                    if (in_coord.x >= 0 && in_coord.x < i32(xSize) &&\n                        in_coord.y >= 0 && in_coord.y < i32(ySize) &&\n                        in_coord.z >= 0 && in_coord.z < i32(zSize)) { //Ensure the sampled point is within 3D dataspace\n                        let xOffset = kx * i32(xStride);\n                        let yOffset = ky * i32(yStride);\n                        let zOffset = kz * i32(zStride);\n                        let newIdx = i32(globalIdx) + xOffset + yOffset + zOffset;\n                        let sampledVal = inputData[u32(newIdx)];\n                        if (sampledVal > maxVal){\n                            maxVal = sampledVal;\n                        }\n                    }\n                }\n            }\n        }\n        \n        outputData[globalIdx] = maxVal;\n    }\n"),StDev:"\n    ".concat(N,"  \n        var sum: f32 = 0.0;\n        var count: u32 = 0u;\n        for (var kx: i32 = -xy_radius + xyOffset; kx < xy_radius; kx++) {\n            for (var ky: i32 = -xy_radius + xyOffset; ky < xy_radius; ky++) {\n                for (var kz: i32 = -z_radius + zOffset; kz < z_radius; kz++){\n                    let in_coord = vec3<i32>(global_id) + vec3<i32>(kx, ky, kz);\n\n                    if (in_coord.x >= 0 && in_coord.x < i32(xSize) &&\n                        in_coord.y >= 0 && in_coord.y < i32(ySize) &&\n                        in_coord.z >= 0 && in_coord.z < i32(zSize)) { //Ensure the sampled point is within 3D dataspace\n                        let xOffset = kx * i32(xStride);\n                        let yOffset = ky * i32(yStride);\n                        let zOffset = kz * i32(zStride);\n                        let newIdx = i32(globalIdx) + xOffset + yOffset + zOffset;\n\n                        sum += inputData[u32(newIdx)];\n                        count ++;\n                    }\n                }\n            }\n        }\n        \n        let mean: f32 = sum / f32(count);\n\n        var squaredDiffSum: f32 = 0.0;\n\n        for (var kx: i32 = -xy_radius + xyOffset; kx < xy_radius; kx++) {\n            for (var ky: i32 = -xy_radius + xyOffset; ky < xy_radius; ky++) {\n                for (var kz: i32 = -z_radius + zOffset; kz < z_radius; kz++){\n                    let in_coord = vec3<i32>(global_id) + vec3<i32>(kx, ky, kz);\n\n                    if (in_coord.x >= 0 && in_coord.x < i32(xSize) &&\n                        in_coord.y >= 0 && in_coord.y < i32(ySize) &&\n                        in_coord.z >= 0 && in_coord.z < i32(zSize)) { //Ensure the sampled point is within 3D dataspace\n                        let xOffset = kx * i32(xStride);\n                        let yOffset = ky * i32(yStride);\n                        let zOffset = kz * i32(zStride);\n                        let newIdx = i32(globalIdx) + xOffset + yOffset + zOffset;\n\n                        let diff: f32 = mean - inputData[u32(newIdx)];\n                        squaredDiffSum += diff*diff;\n                    }\n                }\n            }\n        }\n\n        let stDev: f32 = sqrt(squaredDiffSum / f32(count));\n\n        outputData[globalIdx] = stDev;\n    }\n")};async function q(e,n,t,r){var i;let a=await (null==(i=navigator.gpu)?void 0:i.requestAdapter()),o=await (null==a?void 0:a.requestDevice());if(!o)return void Error("need a browser that supports WebGPU");let{strides:s,shape:l}=n,[u,c,d]=s,m=l.filter((e,n)=>n!=t),f=l[t],p=m[0]*m[1],x=m.map(e=>Math.ceil(e/16)),h=W[r],g=o.createShaderModule({label:"reduction compute module",code:h}),v=o.createComputePipeline({label:"reduction compute pipeline",layout:"auto",compute:{module:g}}),y=(0,G.Wu)(h),S=(0,G.FE)(y.uniforms.params);S.set({zStride:u,yStride:c,xStride:d,xSize:m[1],ySize:m[0],reduceDim:t,dimLength:f});let z=o.createBuffer({label:"Input Buffer",size:e.byteLength,usage:GPUBufferUsage.STORAGE|GPUBufferUsage.COPY_DST}),w=o.createBuffer({label:"Output Buffer",size:4*p,usage:GPUBufferUsage.STORAGE|GPUBufferUsage.COPY_SRC}),b=o.createBuffer({size:S.arrayBuffer.byteLength,usage:GPUBufferUsage.UNIFORM|GPUBufferUsage.COPY_DST}),P=o.createBuffer({label:"Output Buffer",size:4*p,usage:GPUBufferUsage.COPY_DST|GPUBufferUsage.MAP_READ});o.queue.writeBuffer(z,0,e),o.queue.writeBuffer(b,0,S.arrayBuffer);let C=o.createBindGroup({layout:v.getBindGroupLayout(0),entries:[{binding:0,resource:{buffer:z}},{binding:1,resource:{buffer:w}},{binding:2,resource:{buffer:b}}]}),D=o.createCommandEncoder({label:"reduction encoder"}),k=D.beginComputePass({label:"reduction compute pass"});k.setPipeline(v),k.setBindGroup(0,C),k.dispatchWorkgroups(x[0],x[1]),k.end(),D.copyBufferToBuffer(w,0,P,0,4*p),o.queue.submit([D.finish()]),await P.mapAsync(GPUMapMode.READ);let M=new Float32Array(P.getMappedRange().slice());return P.unmap(),M}async function Z(e,n,t,r){var i;let a=await (null==(i=navigator.gpu)?void 0:i.requestAdapter()),o=await (null==a?void 0:a.requestDevice({requiredLimits:{maxBufferSize:0x7a0a1efc,maxStorageBufferBindingSize:0x7a0a1efc}}));if(!o)return void Error("need a browser that supports WebGPU");let{kernelDepth:s,kernelSize:l}=r,{strides:u,shape:c}=n,d=c[0]*c[1]*c[2],[m,f,p]=u,x=c.map(e=>Math.ceil(e/4)),h=X[t],g=o.createShaderModule({label:"convolution compute module",code:h}),v=o.createComputePipeline({label:"convolution compute pipeline",layout:"auto",compute:{module:g}}),y=(0,G.Wu)(h),S=(0,G.FE)(y.uniforms.params);S.set({xStride:p,yStride:f,zStride:m,xSize:c[2],ySize:c[1],zSize:c[0],workGroups:[x[2],x[1],x[0]],kernelDepth:s,kernelSize:l});let z=o.createBuffer({label:"Input Buffer",size:e.byteLength,usage:GPUBufferUsage.STORAGE|GPUBufferUsage.COPY_DST}),w=o.createBuffer({label:"Output Buffer",size:4*d,usage:GPUBufferUsage.STORAGE|GPUBufferUsage.COPY_SRC}),b=o.createBuffer({label:"Uniform Buffer",size:S.arrayBuffer.byteLength,usage:GPUBufferUsage.UNIFORM|GPUBufferUsage.COPY_DST}),P=o.createBuffer({label:"Read Buffer",size:4*d,usage:GPUBufferUsage.COPY_DST|GPUBufferUsage.MAP_READ});o.queue.writeBuffer(z,0,e),o.queue.writeBuffer(b,0,S.arrayBuffer);let C=o.createBindGroup({layout:v.getBindGroupLayout(0),entries:[{binding:0,resource:{buffer:z}},{binding:1,resource:{buffer:w}},{binding:2,resource:{buffer:b}}]}),D=o.createCommandEncoder({label:"convolution encoder"}),k=D.beginComputePass({label:"convolution compute pass"});k.setPipeline(v),k.setBindGroup(0,C),k.dispatchWorkgroups(x[2],x[1],x[0]),k.end(),D.copyBufferToBuffer(w,0,P,0,4*d),o.queue.submit([D.finish()]),await P.mapAsync(GPUMapMode.READ);let M=new Float32Array(P.getMappedRange().slice());return P.unmap(),M}async function H(e,n,t,r){var i;let a=await (null==(i=navigator.gpu)?void 0:i.requestAdapter()),o=await (null==a?void 0:a.requestDevice({requiredLimits:{maxBufferSize:0x7a0a1efc,maxStorageBufferBindingSize:0x7a0a1efc}}));if(!o)return void Error("need a browser that supports WebGPU");let{strides:s,shape:l}=t,[u,c,d]=s,m=l.filter((e,n)=>n!=r),f=l[r],p=m[0]*m[1],x=m.map(e=>Math.ceil(e/16)),h="\n    struct Params {\n        zStride: u32,\n        yStride: u32,\n        xStride: u32,\n        xSize: u32,\n        ySize: u32,\n        reduceDim: u32,\n        dimLength: u32,\n    };\n    @group(0) @binding(0) var<storage, read> firstData: array<f32>;\n    @group(0) @binding(1) var<storage, read> secondData: array<f32>;\n    @group(0) @binding(2) var<storage, read_write> outputData: array<f32>;\n    @group(0) @binding(3) var<uniform> params: Params;\n\n    @compute @workgroup_size(16, 16, 1)\n    fn main(@builtin(global_invocation_id) global_id: vec3<u32>) {\n        let zStride = params.zStride;\n        let yStride = params.yStride;\n        let xStride = params.xStride;\n        let xSize = params.xSize;\n        let ySize = params.ySize;\n        let reduceDim = params.reduceDim;\n        let dimLength = params.dimLength;\n                        \n        let outX = global_id.y;\n        let outY = global_id.x;\n        \n        if (outX >= xSize || outY >= ySize) {\n            return;\n        }\n\n        var xSum: f32 = 0.0;\n        var xxSum: f32 = 0.0;\n        var ySum: f32 = 0.0;\n        var yySum: f32 = 0.0;\n        var xySum: f32 = 0.0;\n        // Iterate along the dimension we're averaging\n        if (reduceDim == 0u) { // Average along Z\n            let cCoord = outX * xStride + outY * yStride;\n            for (var z: u32 = 0u; z < dimLength; z++) {\n                let inputIndex = cCoord + (z * zStride);\n                let xI = firstData[inputIndex];\n                let yI = secondData[inputIndex];\n                xSum += xI;\n                xxSum += xI * xI;\n                ySum += yI;\n                yySum += yI * yI;\n                xySum += xI * yI;\n            }\n        } else if (reduceDim == 1u) { // Average along Y\n            let cCoord = outX * xStride + outY * zStride;\n            for (var y: u32 = 0u; y < dimLength; y++) {\n                let inputIndex = cCoord + (y * yStride);\n                let xI = firstData[inputIndex];\n                let yI = secondData[inputIndex];\n                xSum += xI;\n                xxSum += xI * xI;\n                ySum += yI;\n                yySum += yI * yI;\n                xySum += xI * yI;\n            }\n        } else { // Average along X\n            let cCoord = outX * yStride + outY * zStride;\n            for (var x: u32 = 0u; x < dimLength; x++) {\n                let inputIndex = cCoord + (x * xStride);\n                let xI = firstData[inputIndex];\n                let yI = secondData[inputIndex];\n                xSum += xI;\n                xxSum += xI * xI;\n                ySum += yI;\n                yySum += yI * yI;\n                xySum += xI * yI;\n            }\n        }\n\n        let N: f32 = f32(dimLength);\n        let meanX = xSum / N;\n        let meanY = ySum / N;\n        let varX = (xxSum / N) - (meanX * meanX);\n        let varY = (yySum / N) - (meanY * meanY);\n        let covXY = (xySum / N) - (meanX * meanY);\n        let sigmaX = sqrt(max(0.0, varX));\n        let sigmaY = sqrt(max(0.0, varY));\n        let epsilon = 1e-6;\n        let denominator = sigmaX * sigmaY + epsilon;\n        let correlation = covXY / denominator;\n\n        let outputIndex = outY * xSize + outX;\n        outputData[outputIndex] = correlation;\n    }\n",g=o.createShaderModule({label:"Correlation2D compute module",code:h}),v=o.createComputePipeline({label:"Correlation2D compute pipeline",layout:"auto",compute:{module:g}}),y=(0,G.Wu)(h),S=(0,G.FE)(y.uniforms.params);S.set({zStride:u,yStride:c,xStride:d,xSize:m[1],ySize:m[0],reduceDim:r,dimLength:f});let z=o.createBuffer({label:"First Input Buffer",size:e.byteLength,usage:GPUBufferUsage.STORAGE|GPUBufferUsage.COPY_DST}),w=o.createBuffer({label:"Second Input Buffer",size:n.byteLength,usage:GPUBufferUsage.STORAGE|GPUBufferUsage.COPY_DST}),b=o.createBuffer({label:"Output Buffer",size:4*p,usage:GPUBufferUsage.STORAGE|GPUBufferUsage.COPY_SRC}),P=o.createBuffer({size:S.arrayBuffer.byteLength,usage:GPUBufferUsage.UNIFORM|GPUBufferUsage.COPY_DST}),C=o.createBuffer({label:"Output Buffer",size:4*p,usage:GPUBufferUsage.COPY_DST|GPUBufferUsage.MAP_READ});o.queue.writeBuffer(z,0,e),o.queue.writeBuffer(w,0,n),o.queue.writeBuffer(P,0,S.arrayBuffer);let D=o.createBindGroup({layout:v.getBindGroupLayout(0),entries:[{binding:0,resource:{buffer:z}},{binding:1,resource:{buffer:w}},{binding:2,resource:{buffer:b}},{binding:3,resource:{buffer:P}}]}),k=o.createCommandEncoder({label:"Correlation2D encoder"}),M=k.beginComputePass({label:"Correlation2D compute pass"});M.setPipeline(v),M.setBindGroup(0,D),M.dispatchWorkgroups(x[0],x[1]),M.end(),k.copyBufferToBuffer(b,0,C,0,4*p),o.queue.submit([k.finish()]),await C.mapAsync(GPUMapMode.READ);let j=new Float32Array(C.getMappedRange().slice());return C.unmap(),j}async function Q(e,n,t,r){var i;let a=await (null==(i=navigator.gpu)?void 0:i.requestAdapter()),o=await (null==a?void 0:a.requestDevice({requiredLimits:{maxBufferSize:0x7a0a1efc,maxStorageBufferBindingSize:0x7a0a1efc}}));if(!o)return void Error("need a browser that supports WebGPU");let{kernelDepth:s,kernelSize:l}=r,{strides:u,shape:c}=t,[d,m,f]=u,p=c[0]*c[1]*c[2],x=c.map(e=>Math.ceil(e/4)),h="\n    struct Params {\n        xStride: u32,\n        yStride: u32,\n        zStride: u32,\n        xSize: u32,\n        ySize: u32,\n        zSize: u32,\n        workGroups: vec3<u32>,\n        kernelSize: u32,\n        kernelDepth: u32\n    };\n    @group(0) @binding(0) var<storage, read> firstData: array<f32>;\n    @group(0) @binding(1) var<storage, read> secondData: array<f32>;\n    @group(0) @binding(2) var<storage, read_write> outputData: array<f32>;\n    @group(0) @binding(3) var<uniform> params: Params;\n\n    @compute @workgroup_size(4, 4, 4)\n    fn main(@builtin(global_invocation_id) global_id: vec3<u32>) {\n        let zStride = params.zStride;\n        let yStride = params.yStride;\n        let xStride = params.xStride; \n        let xSize = params.xSize;\n        let ySize = params.ySize;\n        let zSize = params.zSize; \n        let workGroups = params.workGroups;\n        let kernelSize = params.kernelSize;\n        let kernelDepth = params.kernelDepth;\n\n        let outX = global_id.x; \n        let outY = global_id.y;\n        let outZ = global_id.z; \n\n        if (outX >= xSize || outY >= ySize || outZ >= zSize) {\n            return;\n        }\n\n        let total_threads_per_slice = workGroups.x * workGroups.y * 16;\n        let globalIdx = global_id.z * total_threads_per_slice + \n                        global_id.y * (workGroups.x * 4) + \n                        global_id.x;\n\n        let xy_radius: i32 = i32(kernelSize/2u);\n        let z_radius: i32 = i32(kernelDepth/2u);\n\n        var xyOffset: i32 = 0; //These offsets are for kernelsizes of 1. I didn't wanna rewrite everything else for that case\n        var zOffset: i32 = 0;\n        if (xy_radius == 0){\n            xyOffset = -1;\n        }\n        if (z_radius == 0){\n            zOffset = -1;\n        }\n\n        var xSum: f32 = 0.0;\n        var xxSum: f32 = 0.0;\n        var ySum: f32 = 0.0;\n        var yySum: f32 = 0.0;\n        var xySum: f32 = 0.0;\n\n        var count: u32 = 0u;\n        for (var kx: i32 = -xy_radius + xyOffset; kx < xy_radius; kx++) {\n            for (var ky: i32 = -xy_radius + xyOffset; ky < xy_radius; ky++) {\n                for (var kz: i32 = -z_radius + zOffset; kz < z_radius; kz++){\n                    let in_coord = vec3<i32>(global_id) + vec3<i32>(kx, ky, kz);\n                    if (in_coord.x >= 0 && in_coord.x < i32(xSize) &&\n                        in_coord.y >= 0 && in_coord.y < i32(ySize) &&\n                        in_coord.z >= 0 && in_coord.z < i32(zSize)) { //Ensure the sampled point is within 3D dataspace\n                        let xOffset = kx * i32(xStride);\n                        let yOffset = ky * i32(yStride);\n                        let zOffset = kz * i32(zStride);\n                        let newIdx = i32(globalIdx) + xOffset + yOffset + zOffset;\n\n                        let xI = firstData[newIdx];\n                        let yI = secondData[newIdx];\n                        xSum += xI;\n                        xxSum += xI * xI;\n                        ySum += yI;\n                        yySum += yI * yI;\n                        xySum += xI * yI;\n                        count ++;\n                    }\n                }\n            }\n        }\n\n        let N: f32 = f32(count);\n        let meanX = xSum / N;\n        let meanY = ySum / N;\n        let varX = (xxSum / N) - (meanX * meanX);\n        let varY = (yySum / N) - (meanY * meanY);\n        let covXY = (xySum / N) - (meanX * meanY);\n        let sigmaX = sqrt(max(0.0, varX));\n        let sigmaY = sqrt(max(0.0, varY));\n        let epsilon = 1e-6;\n        let denominator = sigmaX * sigmaY + epsilon;\n        let correlation = covXY / denominator;\n\n        outputData[globalIdx] = correlation;\n    }\n",g=o.createShaderModule({label:"Correlation3D compute module",code:h}),v=o.createComputePipeline({label:"Correlation3D compute pipeline",layout:"auto",compute:{module:g}}),y=(0,G.Wu)(h),S=(0,G.FE)(y.uniforms.params);S.set({xStride:f,yStride:m,zStride:d,xSize:c[2],ySize:c[1],zSize:c[0],workGroups:[x[2],x[1],x[0]],kernelDepth:s,kernelSize:l});let z=o.createBuffer({label:"First Input Buffer",size:e.byteLength,usage:GPUBufferUsage.STORAGE|GPUBufferUsage.COPY_DST}),w=o.createBuffer({label:"Second Input Buffer",size:n.byteLength,usage:GPUBufferUsage.STORAGE|GPUBufferUsage.COPY_DST}),b=o.createBuffer({label:"Output Buffer",size:4*p,usage:GPUBufferUsage.STORAGE|GPUBufferUsage.COPY_SRC}),P=o.createBuffer({size:S.arrayBuffer.byteLength,usage:GPUBufferUsage.UNIFORM|GPUBufferUsage.COPY_DST}),C=o.createBuffer({label:"Output Buffer",size:4*p,usage:GPUBufferUsage.COPY_DST|GPUBufferUsage.MAP_READ});o.queue.writeBuffer(z,0,e),o.queue.writeBuffer(w,0,n),o.queue.writeBuffer(P,0,S.arrayBuffer);let D=o.createBindGroup({layout:v.getBindGroupLayout(0),entries:[{binding:0,resource:{buffer:z}},{binding:1,resource:{buffer:w}},{binding:2,resource:{buffer:b}},{binding:3,resource:{buffer:P}}]}),k=o.createCommandEncoder({label:"Correlation3D encoder"}),M=k.beginComputePass({label:"Correlation3D compute pass"});M.setPipeline(v),M.setBindGroup(0,D),M.dispatchWorkgroups(x[2],x[1],x[0]),M.end(),k.copyBufferToBuffer(b,0,C,0,4*p),o.queue.submit([k.finish()]),await C.mapAsync(GPUMapMode.READ);let j=new Float32Array(C.getMappedRange().slice());return C.unmap(),j}let J=e=>{let{setTexture:n,ZarrDS:t}=e,{dataArray:r,strides:a,dataShape:o,valueScales:c,setIsFlat:d,setDownloading:m,setShowLoading:p,setValueScales:x}=(0,l.on)((0,u.k)(e=>({dataArray:e.dataArray,strides:e.strides,dataShape:e.dataShape,valueScales:e.valueScales,setIsFlat:e.setIsFlat,setDownloading:e.setDownloading,setShowLoading:e.setShowLoading,setValueScales:e.setValueScales}))),h=(0,l.Ws)(e=>e.setPlotType),{axis:g,execute:v,operation:y,useTwo:S,variable2:z,valueScalesOrig:w,kernelSize:b,kernelDepth:P,kernelOperation:C,setValueScalesOrig:D,setAnalysisArray:k}=(0,l.r2)((0,u.k)(e=>({axis:e.axis,execute:e.execute,operation:e.operation,useTwo:e.useTwo,variable2:e.variable2,valueScalesOrig:e.valueScalesOrig,kernelSize:e.kernelSize,kernelDepth:e.kernelDepth,kernelOperation:e.kernelOperation,setValueScalesOrig:e.setValueScalesOrig,setAnalysisArray:e.setAnalysisArray}))),M=(0,l.SZ)(e=>e.slice),j=(0,s.useRef)(new Float32Array(1));return(0,s.useEffect)(()=>{if(!(r.length<=1))if(p(!0),S)(async function(){if(m(!0),j.current=await t.GetArray(z,M),m(!1),"Correlation2D"==y){let e=o.filter((e,n)=>n!=g),t=await H(r,j.current.data,{shape:o,strides:a},g);w||D(c);let[s,l]=[-1,1];x({minVal:s,maxVal:l});let u=new Uint8Array(t.map(e=>(e-s)/(l-s)).map(e=>isNaN(e)?255:254*e)),m=new i.GYF(u,e[1],e[0],i.VT0,i.OUM);m.needsUpdate=!0,k(t),n(m),d(!0),h("flat")}else{let e=await Q(r,j.current.data,{shape:o,strides:a},{kernelDepth:P,kernelSize:b});w||D(c);let[t,s]=[-1,1];x({minVal:t,maxVal:s});let l=new Uint8Array(e.map(e=>(e-t)/(s-t)).map(e=>isNaN(e)?255:254*e)),u=new i.dYF(l,o[2],o[1],o[0]);u.format=i.VT0,u.minFilter=i.hxR,u.magFilter=i.hxR,u.needsUpdate=!0,k(e),n(u),d(!1),h("volume")}})().then(e=>p(!1));else if("Convolution"!=y){let e=o.filter((e,n)=>n!=g);q(r,{shape:o,strides:a},g,y).then(t=>{let r,a;if(!t)return;"StDev"==y?([r,a]=(0,f.Qt)(t),w||D(c),x({minVal:r,maxVal:a})):w?(r=w.minVal,a=w.maxVal,x(w),D(null)):(r=c.minVal,a=c.maxVal);let o=new Uint8Array(t.map(e=>(e-r)/(a-r)).map(e=>isNaN(e)?255:254*e)),s=new i.GYF(o,e[1],e[0],i.VT0,i.OUM);s.needsUpdate=!0,k(t),n(s),d(!0),h("flat")}).then(e=>p(!1))}else Z(r,{shape:o,strides:a},C,{kernelDepth:P,kernelSize:b}).then(e=>{let t,r;if(!e)return;"StDev"==C?([t,r]=(0,f.Qt)(e),w||D(c),x({minVal:t,maxVal:r})):w?(t=w.minVal,r=w.maxVal,x(w),D(null)):(t=c.minVal,r=c.maxVal);let a=new Uint8Array(e.map(e=>(e-t)/(r-t)).map(e=>isNaN(e)?255:254*e)),s=new i.dYF(a,o[2],o[1],o[0]);s.format=i.VT0,s.minFilter=i.hxR,s.magFilter=i.hxR,s.needsUpdate=!0,k(e),n(s),d(!1),h("volume")}).then(e=>p(!1))},[v]),null},$=e=>{let{isFlat:n}=e,{resetCamera:t}=(0,l.Ws)((0,u.k)(e=>({resetCamera:e.resetCamera}))),a=(0,s.useRef)(null),o=(0,s.useRef)(!1);return(0,s.useEffect)(()=>{if(!o.current){o.current=!0;return}if(a.current){let e,t=a.current,r=performance.now(),o=t.object.position.clone(),s=t.position0.clone(),l=t.target.clone(),u=t.target0.clone(),c=t.object.zoom,d=a=>{(0,T.m)();let m=Math.min((a-r)/1e3,1);t.object.position.lerpVectors(o,s,m),t.target.lerpVectors(l,u,m),n&&(t.object.zoom=i.cj9.lerp(c,1e3,m),t.object.updateProjectionMatrix(),t.update()),m<1&&(e=requestAnimationFrame(d))};return e=requestAnimationFrame(d),()=>cancelAnimationFrame(e)}},[t]),(0,r.jsxs)(r.Fragment,{children:[n&&(0,r.jsx)(L.N,{ref:a,enableRotate:!1,enablePan:!0,maxDistance:50,minZoom:50,maxZoom:3e3}),!n&&(0,r.jsx)(L.N,{ref:a,enableRotate:!0,enablePan:!0,maxDistance:50})]})},K=e=>{let{ZarrDS:n}=e,{setShape:t,setDataShape:a,setFlipY:o,setValueScales:c,setMetadata:d,setDimArrays:x,setDimNames:y,setDimUnits:S,setPlotOn:z,setShowLoading:w}=(0,l.on)((0,u.k)(e=>({setShape:e.setShape,setDataShape:e.setDataShape,setFlipY:e.setFlipY,setValueScales:e.setValueScales,setMetadata:e.setMetadata,setDimArrays:e.setDimArrays,setDimNames:e.setDimNames,setDimUnits:e.setDimUnits,setPlotOn:e.setPlotOn,setShowLoading:e.setShowLoading}))),{colormap:b,variable:P,isFlat:C,metadata:D,valueScales:k,is4D:M,setIsFlat:j,setDataArray:B}=(0,l.on)((0,u.k)(e=>({colormap:e.colormap,variable:e.variable,isFlat:e.isFlat,metadata:e.metadata,valueScales:e.valueScales,is4D:e.is4D,setIsFlat:e.setIsFlat,setDataArray:e.setDataArray}))),{plotType:_}=(0,l.Ws)((0,u.k)(e=>({plotType:e.plotType}))),{slice:I,reFetch:O}=(0,l.SZ)((0,u.k)(e=>({slice:e.slice,reFetch:e.reFetch}))),A=(0,s.useRef)([0,0]),U=(0,s.useRef)(0),[Y,L]=(0,s.useState)(!1),[T,V]=(0,s.useState)([0,0]),[G,F]=(0,s.useState)(null),[N,W]=(0,s.useState)(!0);(0,s.useEffect)(()=>{if("Default"!=P){w(!0),W(!1);try{n.GetArray(P,I).then(e=>{let[n,r]=(0,R.oW)({data:e.data,shape:e.shape});n instanceof i.GYF||n instanceof i.dYF?F(n):(console.error("Invalid texture type returned from ArrayToTexture"),F(null)),"object"==typeof r&&"maxVal"in r&&"minVal"in r&&c(r),2==e.shape.length?j(!0):j(!1),B(e.data);let o=e.shape[1]/e.shape[2]*2;t(new i.Pq0(2,o,2)),a(e.shape)})}catch(e){w(!1);return}n.GetAttributes(P).then(e=>{d(e);let[t,r,i]=n.GetDimArrays();M&&(t=t.slice(1),r=r.slice(1),i=i.slice(1)),x(t),y(i),t.length>2?t[1][1]<t[1][0]?o(!0):o(!1):t[0][1]<t[0][0]?o(!0):o(!1);let a=[];for(let e of r)a.push(e.units);S(a),(0,f.QB)(a,t),w(!1),W(!0),z(!0)})}else d(null)},[P,O]);let X=(0,s.useMemo)(()=>({setLoc:V,setShowInfo:L,coords:A,val:U}),[]),q=(0,s.useMemo)(()=>v.Fp,[]);return(0,r.jsxs)("div",{className:"main-canvas",style:{width:"100vw"},children:[(0,r.jsx)(J,{setTexture:F,ZarrDS:n}),N&&(0,r.jsx)(v.PL,{units:null==D?void 0:D.units,valueScales:k}),(0,r.jsx)(q,{}),(C||"flat"==_)&&(0,r.jsx)(E,{loc:T,show:Y,info:[...A.current,U.current]}),(!C&&"flat"!=_||C&&"sphere"===_)&&(0,r.jsx)(r.Fragment,{children:(0,r.jsxs)(g.Hl,{id:"main-canvas",camera:{position:C?[0,0,5]:[-4.5,3,4.5],fov:50},frameloop:"demand",children:[(0,r.jsx)(el,{}),!C&&N&&(0,r.jsx)(ef,{}),"volume"==_&&N&&(0,r.jsxs)(r.Fragment,{children:[(0,r.jsx)(m,{volTexture:G}),(0,r.jsx)(p,{ZarrDS:n})]}),"point-cloud"==_&&N&&(0,r.jsx)(r.Fragment,{children:(0,r.jsx)(h,{textures:{texture:G,colormap:b},ZarrDS:n})}),"sphere"==_&&N&&(0,r.jsx)(ei,{texture:G,ZarrDS:n}),(0,r.jsx)($,{isFlat:!1})]})}),(C||"flat"==_)&&(0,r.jsx)(r.Fragment,{children:(0,r.jsxs)(g.Hl,{id:"main-canvas",camera:{position:[0,0,5],zoom:1e3},orthographic:!0,frameloop:"demand",children:[(0,r.jsx)(el,{}),(0,r.jsx)(et,{texture:G,infoSetters:X}),(0,r.jsx)($,{isFlat:!0})]})})]})};function ee(e){let{points:n,tsID:t,pointSetters:a,colIDX:o,scalers:c}=e,d=(0,s.useRef)(null),m=n.length,f=(0,s.useRef)(null),[p,x]=(0,s.useState)(!1),{setPointID:h,setPointLoc:g,setShowPointInfo:v}=a,[y,S]=(0,s.useState)(1),{pointColor:z,pointSize:w,useCustomPointColor:b}=(0,l.Ws)((0,u.k)(e=>({pointColor:e.pointColor,pointSize:e.linePointSize,showPoints:e.showPoints,useCustomPointColor:e.useCustomPointColor}))),{xScale:P,yScale:C}=c,[D,k,M]=(0,s.useMemo)(()=>(0,_.md)(o/10,"Paired"),[o]),j=(0,s.useMemo)(()=>new i.Gu$(w),[w]),B=(0,s.useMemo)(()=>new i.V9B({color:b?z:new i.Q1f().setRGB(D/500,k/500,M/500)}),[z,b]);return(0,s.useEffect)(()=>{if(d.current){let e=new i.B69;for(let t=0;t<m;t++){let r=n[t].toArray();e.position.set(r[0]*(P/2),r[1]*C,1),e.scale.set(w/y,w/y,w/y),e.updateMatrix(),d.current.setMatrixAt(t,e.matrix)}d.current.instanceMatrix.needsUpdate=!0}},[n,y,j,B,P,C,w]),(0,T.D)(e=>{let{camera:n}=e;n.zoom!==y&&S(n.zoom)}),(0,r.jsx)(r.Fragment,{children:(0,r.jsx)("mesh",{position:[0,0,5],onPointerEnter:function(e){if(d.current){let n=e.instanceId,r=new i.B69,a=new i.kn4,o=new i.Pq0;n!=f.current&&f.current&&(d.current.getMatrixAt(f.current,a),o.setFromMatrixPosition(a),r.scale.set(w/y,w/y,w/y),r.position.copy(o),r.updateMatrix(),d.current.setMatrixAt(f.current,r.matrix)),f.current=n,d.current.getMatrixAt(n,a),o.setFromMatrixPosition(a),r.scale.set(3*w/y,3*w/y,3/y),r.position.copy(o),r.updateMatrix(),d.current.setMatrixAt(e.instanceId,r.matrix),d.current.instanceMatrix.needsUpdate=!0,x(e=>!e),h({[t]:e.instanceId}),g([e.clientX,e.clientY]),v(!0)}},onPointerLeave:function(e){let n=e.instanceId;if(d.current){let e=new i.B69,t=new i.kn4,r=new i.Pq0;f.current&&(d.current.getMatrixAt(n,t),r.setFromMatrixPosition(t),e.scale.set(w/y,w/y,w/y),e.position.copy(r),e.updateMatrix(),d.current.setMatrixAt(n,e.matrix),d.current.instanceMatrix.needsUpdate=!0,x(e=>!e),v(n!=f.current))}},children:(0,r.jsx)("instancedMesh",{ref:d,args:[j,B,m]})})})}let en=e=>{let{height:n,xScale:t,yScale:a,pointSetters:o}=e,{valueScales:c,timeSeries:d,colormap:m}=(0,l.on)((0,u.k)(e=>({valueScales:e.valueScales,timeSeries:e.timeSeries,colormap:e.colormap}))),{lineWidth:f,useLineColor:p,lineColor:x,showPoints:h,lineResolution:g,useCustomColor:v}=(0,l.Ws)((0,u.k)(e=>({lineWidth:e.lineWidth,linePointSize:e.linePointSize,showPoints:e.showPoints,useLineColor:e.useLineColor,lineColor:e.lineColor,lineResolution:e.lineResolution,useCustomColor:e.useCustomColor})));(0,s.useRef)([]);let{camera:y}=(0,T.C)(),{maxVal:S,minVal:z}=c,w=(0,s.useMemo)(()=>{let e={};return Object.keys(d).reverse().map((n,r)=>{let[o,s,l]=(0,_.md)(r/10,"Paired");e[n]=new i.BKk({glslVersion:i.Wdf,uniforms:{cmap:{value:m},xScale:{value:t},yScale:{value:a},aspect:{value:window.innerWidth/window.innerHeight},thickness:{value:f},miter:{value:1},useLineColor:{value:v},useMapColors:{value:p},lineColor:{value:new i.Q1f().setRGB(o/255,s/255,l/255)},userColor:{value:new i.Q1f(x)},zoom:{value:y.zoom}},vertexShader:"attribute float direction; \nattribute vec3 next;\nattribute vec3 previous;\nattribute float normed;\n\nvarying float vNormed;\n\nuniform float zoom;\nuniform float thickness;\nuniform int miter;\nuniform float xScale; \nuniform float yScale;\n\nfloat getOrthographicZoom(mat4 projectionMatrix, float referenceWidth) {\n    float m0 = projectionMatrix[0][0]; // Scaling factor: 2/(right-left)\n    float viewWidth = 2.0 / m0; // Viewable width\n    return referenceWidth / viewWidth; // Zoom level\n}\n\nvoid main() {\n    vec3 pos = position;\n    vec3 prev = previous;\n    vec3 nex = next;\n    pos.x *= xScale/2.0;\n    pos.y *= yScale;\n    prev.x *= xScale/2.0;\n    prev.y *= yScale;\n    nex.x *= xScale/2.0;\n    nex.y *= yScale;\n\n    // Transform positions to view space (before projection)\n    float zoom = getOrthographicZoom(projectionMatrix, 2.);\n    float zoomLevel = 2. / projectionMatrix[0][0]; // Extract vertical scale\n    vec4 currentView = modelViewMatrix * vec4(pos, 1.0);\n    vec4 prevView = modelViewMatrix * vec4(prev, 1.0);\n    vec4 nextView = modelViewMatrix * vec4(nex, 1.0);\n\n    // Compute directions in view space\n    vec3 dir = vec3(0.0);\n    if (currentView.xyz == prevView.xyz) {\n        dir = normalize(nextView.xyz - currentView.xyz);\n    } else if (currentView.xyz == nextView.xyz) {\n        dir = normalize(currentView.xyz - prevView.xyz);\n    } else {\n        vec3 dirA = normalize(currentView.xyz - prevView.xyz);\n        if (miter == 1) {\n            vec3 dirB = normalize(nextView.xyz - currentView.xyz);\n            vec3 tangent = normalize(dirA + dirB);\n            vec3 perp = vec3(-dirA.y, dirA.x, 0.0); // Perpendicular in view space\n            vec3 miterVec = vec3(-tangent.y, tangent.x, 0.0);\n            float miterLen = dot(miterVec, perp);\n            miterLen = max(miterLen, 0.5); // Avoid division by zero\n            dir = tangent;\n        } else {\n            dir = dirA;\n        }\n    }\n\n    // Compute normal in view space\n    vec3 normal = vec3(-dir.y, dir.x, 0.0); // Perpendicular to direction\n    float len = thickness / zoom/500.; // Thickness in world/view space units\n    normal *= 0.5 * len * direction; // Apply thickness and direction\n\n    // Apply offset in view space\n    currentView.xyz += normal;\n\n    // Project to clip space\n    gl_Position = projectionMatrix * currentView;\n\n\n    vNormed = normed;\n    gl_PointSize = 1.0;\n}",fragmentShader:"\n                out vec4 Color;\n                uniform sampler2D cmap;\n                uniform bool useLineColor;\n                uniform bool useMapColors;\n                uniform vec3 lineColor;\n                uniform vec3 userColor;\n                varying float vNormed;\n\n                void main() {\n                    vec4 texColor = texture(cmap, vec2(vNormed, 0.1));\n                    texColor.a = 1.;\n                    Color = useLineColor ? vec4(userColor, 1.0) : useMapColors ? texColor : vec4(lineColor, 1.0) ;\n                }\n                ",depthWrite:!1})}),e},[m,f,t,a,window.innerWidth,window.innerHeight,p,x,y.zoom,v,d]),b=(0,s.useMemo)(()=>window.innerWidth,[window.innerWidth]),P=(0,s.useMemo)(()=>window.innerHeight-n,[window.innerWidth,n]),[C,D]=(0,s.useState)({}),k=(0,s.useMemo)(()=>{let e={},n={};return Object.keys(d).map((t,r)=>{let a=d[t],o=a.map(e=>(e-z)/(S-z)),s=function(e,n,t){let r=(n-e)/(t-1);return Array.from({length:t},(n,t)=>e+r*t)}(-b,b,a.length),l=o.map((e,n)=>new i.Pq0(s[n],(e-.5)*P,5));n[t]=l;let u=new i.B6O(l).getPoints(l.length*g-1),c=[];for(let e=0;e<u.length;e++){let n=e/(u.length-1)*(o.length-1),t=Math.floor(n),r=Math.min(o.length-1,Math.ceil(n)),i=n-t;c.push(o[t]*(1-i)+o[r]*i)}let m=u.length,f=[],p=[],x=[],h=[],v=[],y=[];for(let e=0;e<m;e++){let n=u[e],t=u[Math.max(0,e-1)],r=u[Math.min(m-1,e+1)];f.push(...n,...n),p.push(1,-1),x.push(...t,...t),h.push(...r,...r),v.push(c[e],c[e])}for(let e=0;e<m-1;e++){let n=2*e,t=n+1,r=n+2,i=n+3;y.push(n,t,r),y.push(t,i,r)}let w=new i.LoY;w.setAttribute("position",new i.qtW(f,3)),w.setAttribute("direction",new i.qtW(p,1)),w.setAttribute("previous",new i.qtW(x,3)),w.setAttribute("next",new i.qtW(h,3)),w.setAttribute("normed",new i.qtW(v,1)),w.setIndex(new i.A$4(y,1)),e[t]=w}),D(n),e},[d,g]);return(0,s.useEffect)(()=>{(0,T.m)()},[h]),(0,r.jsx)(r.Fragment,{children:(0,r.jsxs)("group",{children:[Object.keys(d).map((e,n)=>(0,r.jsx)("mesh",{geometry:k[e],material:w[e]},"lineMesh_".concat(n))),h&&Object.keys(d).map((e,n)=>(0,r.jsx)(ee,{points:C[e],tsID:e,colIDX:n,pointSetters:o,scalers:{xScale:t,yScale:a}},"plotPoints_".concat(n)))]})})},et=e=>{let{texture:n,infoSetters:t}=e,{setLoc:a,setShowInfo:o,val:c,coords:d}=t,{flipY:m,colormap:f,dataArray:p,valueScales:x,dimArrays:h,isFlat:g}=(0,l.on)((0,u.k)(e=>({flipY:e.flipY,colormap:e.colormap,dataArray:e.dataArray,valueScales:e.valueScales,dimArrays:e.dimArrays,isFlat:e.isFlat}))),{cScale:v,cOffset:y,animProg:S}=(0,l.Ws)((0,u.k)(e=>({cOffset:e.cOffset,cScale:e.cScale,resetAnim:e.resetAnim,animate:e.animate,animProg:e.animProg}))),{axis:z,analysisMode:w,analysisArray:b}=(0,l.r2)((0,u.k)(e=>({axis:e.axis,analysisMode:e.analysisMode,analysisArray:e.analysisArray}))),P=n.source.data,C=(0,s.useMemo)(()=>P.height/P.width,[P]),D=(0,s.useMemo)(()=>new i.bdM(2,2*C),[C]),k=(0,s.useRef)(!1),M=(0,s.useRef)(new i.I9Y(0,0)),j=w&&2==z,B=(0,s.useMemo)(()=>w?b:p,[w,p,b]),_=(0,s.useMemo)(()=>h.filter((e,n)=>n!=z),[h,z]),I=(0,s.useMemo)(()=>new i.BKk({glslVersion:i.Wdf,uniforms:{cScale:{value:v},cOffset:{value:y},data:{value:n},cmap:{value:f},animateProg:{value:S}},vertexShader:" // by Jeran Poehls\r\nvarying vec2 vUv;\r\n\r\nvoid main() {\r\n    vUv = uv;\r\n    gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);\r\n}",fragmentShader:g?"uniform sampler2D data;\r\nuniform sampler2D cmap;\r\n\r\nuniform float cOffset;\r\nuniform float cScale;\r\n\r\nvarying vec2 vUv;\r\nout vec4 Color;\r\n\r\nvoid main() {\r\n    vec4 val = texture(data,vUv);\r\n    float d = val.x;\r\n    float sampLoc = d == 1. ? d : (d - 0.5)*cScale + 0.5;\r\n    sampLoc = d == 1. ? d : min(sampLoc+cOffset,0.99);\r\n    vec4 color = texture(cmap, vec2(sampLoc,0.5));\r\n    color.a = val.x > 0.999 ? 0. : 1.;\r\n\r\n    Color = color;\r\n}":"//This is for Flat Textures but with 3D textures to sample from i,e; animation\r\n\r\nuniform sampler3D data;\r\nuniform sampler2D cmap;\r\n\r\nuniform float cOffset;\r\nuniform float cScale;\r\nuniform float animateProg;\r\n\r\nvarying vec2 vUv;\r\nout vec4 Color;\r\n\r\nvoid main() {\r\n    vec4 val = texture(data,vec3(vUv, animateProg));\r\n    float d = val.x;\r\n    float sampLoc = d == 1. ? d : (d - 0.5)*cScale + 0.5;\r\n    sampLoc = d == 1. ? d : min(sampLoc+cOffset,0.99);\r\n    vec4 color = texture(cmap, vec2(sampLoc,0.5));\r\n    color.a = val.x > 0.999 ? 0. : 1.;\r\n\r\n    Color = color;\r\n}",side:i.$EB}),[v,y,n,f,S]);(0,s.useEffect)(()=>{D.dispose()},[D]);let O=(0,s.useRef)(null),A=(0,s.useCallback)(e=>{if(k.current&&e.uv){O.current=e,a([e.clientX,e.clientY]),M.current=e.uv;let{x:n,y:t}=e.uv,r=g?w?_[1].length:h[1].length:h[2].length,i=g?w?_[0].length:h[0].length:h[1].length,o=Math.round(n*r-.5),s=Math.round(t*i-.5),l=r*s+o;l+=g?0:Math.round(h[0].length*S)*r*i;let u=B?B[l]:0;c.current=g&&!w?function(e,n){return e*(n.maxVal-n.minVal)+n.minVal}(u,x):u,d.current=g?w?[_[0][s],_[1][o]]:[h[0][s],h[1][o]]:[h[1][s],h[2][o]]}},[B,h,S]);return(0,r.jsx)(r.Fragment,{children:(0,r.jsx)("mesh",{material:I,geometry:D,scale:[1,m?-1:1,1],rotation:[0,0,j?Math.PI/2:0],onPointerEnter:()=>{o(!0),k.current=!0},onPointerLeave:()=>{o(!1),k.current=!1},onPointerMove:A})})};function er(e){return e*Math.PI/180}let ei=e=>{let{texture:n,ZarrDS:t}=e,{colormap:a,flipY:o,isFlat:c}=(0,l.on)((0,u.k)(e=>({colormap:e.colormap,flipY:e.flipY,isFlat:e.isFlat}))),{setPlotDim:m,updateDimCoords:p,updateTimeSeries:x}=(0,l.on)((0,u.k)(e=>({setPlotDim:e.setPlotDim,updateDimCoords:e.updateDimCoords,updateTimeSeries:e.updateTimeSeries}))),{dimArrays:h,dimNames:g,dimUnits:v}=(0,l.on)((0,u.k)(e=>({shape:e.shape,dimArrays:e.dimArrays,dimNames:e.dimNames,dimUnits:e.dimUnits}))),{animate:y,animProg:S,cOffset:z,cScale:w,selectTS:b,lonExtent:P,latExtent:C,lonResolution:D,latResolution:k}=(0,l.Ws)((0,u.k)(e=>({animate:e.animate,animProg:e.animProg,cOffset:e.cOffset,cScale:e.cScale,selectTS:e.selectTS,lonExtent:e.lonExtent,latExtent:e.latExtent,lonResolution:e.lonResolution,latResolution:e.latResolution}))),[M,j]=(0,s.useState)(Array(10).fill(new i.IUQ(-1,-1,-1,-1))),{height:B,width:_}=(0,s.useMemo)(()=>null==n?void 0:n.source.data,[n]),[I,O]=(0,s.useMemo)(()=>{let e=k/2,n=D/2;return[[Math.max(P[0]-n,-180),Math.min(P[1]+n,180)],[Math.max(C[0]-e,-90),Math.min(C[1]+e,90)]]},[C,P,D,k]),[A,U]=(0,s.useMemo)(()=>[(I[1]-I[0])/360,(O[1]-O[0])/180],[I,O]),Y=(0,s.useMemo)(()=>new i.WBB(1,9),[]),L=(0,s.useMemo)(()=>new i.BKk({glslVersion:i.Wdf,uniforms:{map:{value:n},selectTS:{value:b},selectBounds:{value:M},cmap:{value:a},cOffset:{value:z},cScale:{value:w},animateProg:{value:S},latBounds:{value:new i.I9Y(er(O[0]),er(O[1]))},lonBounds:{value:new i.I9Y(er(I[0]),er(I[1]))}},vertexShader:d,fragmentShader:c?" // by Jeran Poehls\nprecision highp float;\nprecision highp sampler2D;\n\nout vec4 color;\n\nin vec3 aPosition;\n\nuniform sampler2D map;\nuniform sampler2D cmap;\n\nuniform float cOffset;\nuniform float cScale;\nuniform float animateProg;\nuniform bool selectTS;\nuniform vec2 latBounds;\nuniform vec2 lonBounds;\n\n#define pi 3.141592653\n\nvec2 giveUV(vec3 position){\n    vec3 n = normalize(position);\n    float latitude = asin(n.y);\n    float longitude = atan(n.z, n.x);\n    latitude = (latitude - latBounds.x)/(latBounds.y - latBounds.x);\n    longitude = (longitude - lonBounds.x)/(lonBounds.y - lonBounds.x);\n\n    return vec2(1.-longitude, latitude);\n}\n\nvoid main(){\n    vec2 sampleCoord = giveUV(aPosition);\n    float strength = texture(map, sampleCoord).r;\n    strength = strength == 1. ? strength : (strength - 0.5)*cScale + 0.5;\n    strength = strength == 1. ? strength : min(strength+cOffset,0.99);\n    color = texture(cmap, vec2(strength, 0.5));\n    color.a = 1.;\n    // color = vec4(sampleCoord, 0., 1.0);\n\n}":" // by Jeran Poehls\nprecision highp float;\nprecision highp sampler3D;\n\nout vec4 color;\n\nin vec3 aPosition;\n\nuniform sampler3D map;\nuniform sampler2D cmap;\n\nuniform float cOffset;\nuniform float cScale;\nuniform float animateProg;\nuniform vec4[10] selectBounds; \nuniform bool selectTS;\nuniform vec2 latBounds;\nuniform vec2 lonBounds;\n\n#define pi 3.141592653\n\nvec2 giveUV(vec3 position){\n    vec3 n = normalize(position);\n    float latitude = asin(n.y);\n    float longitude = atan(n.z, n.x);\n    latitude = (latitude - latBounds.x)/(latBounds.y - latBounds.x);\n    longitude = (longitude - lonBounds.x)/(lonBounds.y - lonBounds.x);\n\n    return vec2(1.-longitude, latitude);\n}\n\nbool isValid(vec2 sampleCoord){\n    for (int i = 0; i < 10; i++){\n        vec4 thisBound = selectBounds[i];\n        if (thisBound.x == -1.){\n            return false;\n        }\n        bool cond = (sampleCoord.x < thisBound.r || sampleCoord.x > thisBound.g || sampleCoord.y < thisBound.b ||  sampleCoord.y > thisBound.a);\n        if (!cond){\n            return true;\n        }\n    }\n    return false;\n}\n\nvoid main(){\n    vec2 sampleCoord = giveUV(aPosition);\n    bool inBounds = all(greaterThanEqual(sampleCoord, vec2(0.0))) && \n                all(lessThanEqual(sampleCoord, vec2(1.0)));\n    \n    if (inBounds) {\n    float strength = texture(map, vec3(sampleCoord, animateProg)).r;\n    strength = strength == 1. ? strength : (strength - 0.5)*cScale + 0.5;\n    strength = strength == 1. ? strength : min(strength+cOffset,0.99);\n    color = texture(cmap, vec2(strength, 0.5));\n    \n    bool cond = isValid(sampleCoord);\n    if (!cond && selectTS){\n        color.rgb *= 0.65;\n    }\n    } else {\n        color = vec4(0.0, 0.0, 0.0, 1.0); // Black\n    }\n    color.a = 1.;\n    // color = vec4(sampleCoord, 0., 1.0);\n\n}",blending:i.NTi}),[n,S,a,z,w,y,M,b,I,O]);return(0,r.jsx)(r.Fragment,{children:(0,r.jsx)("mesh",{geometry:Y,material:L,onClick:e=>b&&function(e){let n=function(e,n,t){let r=Math.atan2(e.z,e.x),a=Math.asin(e.y),o=(r-er(t[0]))/(er(t[1])-er(t[0])),s=(a-er(n[0]))/(er(n[1])-er(n[0]));return new i.I9Y(1-o,s)}(e.point.normalize(),O,I),r=new i.Pq0(0,0,1);if(t){var a,o;let e=t.GetTimeSeries({uv:n,normal:r}),i=r.toArray().map((e,n)=>Math.abs(e)>0?n:null).filter(e=>null!==e);m(2-i[0]);let s=(0,f.jT)({normal:r,uv:n}).map((e,n)=>e?h[n][Math.round(e*h[n].length)]:null),l=g.filter((e,n)=>null!==s[n]),u=v.filter((e,n)=>null!==s[n]);s=s.filter(e=>null!==e);let c="".concat(s[0],"_").concat(s[1]);x({[c]:e}),p({[c]:{first:{name:l[0],loc:null!=(a=s[0])?a:0,units:u[0]},second:{name:l[1],loc:null!=(o=s[1])?o:0,units:u[1]},plot:{units:v[2-i[0]]}}})}!function(e){let n=Math.floor(e.x*_)+.5;console.log(e.x*_);let t=Math.ceil(e.y*B)-.5,r=1/_,a=1/B,o=new i.IUQ(...[n/_-r/2,n/_+r/2],...[t/B-a/2,t/B+a/2]);j(e=>[o,...e].slice(0,10))}(n)}(e)})})};function ea(e){let[n,t]=e;return[n/180,t/180,0]}function eo(e){let[n,t]=e,r=t*Math.PI/180,i=n*Math.PI/180;return[Math.cos(r)*Math.cos(i)*1.001,1.001*Math.sin(r),Math.cos(r)*Math.sin(i)*1.001]}function es(e){let{features:n}=e,{xRange:t,yRange:a,plotType:o,borderColor:c}=(0,l.Ws)((0,u.k)(e=>({xRange:e.xRange,yRange:e.yRange,plotType:e.plotType,borderColor:e.borderColor}))),{flipY:m,shape:f}=(0,l.on)((0,u.k)(e=>({flipY:e.flipY,shape:e.shape}))),[p,x]=(0,s.useState)(!1);(0,s.useEffect)(()=>{"sphere"===o?x(!0):x(!1)},[o]);let h=(0,s.useMemo)(()=>new i.BKk({glslVersion:i.Wdf,vertexShader:d,fragmentShader:"precision highp float;\r\nprecision highp sampler3D;\r\n\r\nout vec4 color;\r\n\r\nin vec3 aPosition;\r\n\r\nuniform vec2 xBounds;\r\nuniform vec2 yBounds;\r\nuniform vec3 borderColor;\r\nuniform bool trim;\r\n\r\nvoid main() {\r\n\r\n    if ((aPosition.x < xBounds.x || aPosition.x > xBounds.y || aPosition.y < yBounds.x || aPosition.y > yBounds.y) && trim){\r\n        discard;\r\n    }\r\n\r\n    color = vec4(borderColor, 1.0);\r\n}",uniforms:{xBounds:{value:new i.I9Y(t[0],t[1])},yBounds:{value:new i.I9Y(a[0]/f.x,a[1]/f.x)},borderColor:{value:new i.Q1f(c)},trim:{value:!p}}}),[t,a,c,p]),g=(0,s.useMemo)(()=>n.flatMap((e,n)=>{let t=[];if("LineString"===e.geometry.type){let n=[];e.geometry.coordinates.forEach(e=>{let[t,r]=e,[a,o,s]=p?eo([-t,r]):ea([t,r]);n.push(new i.Pq0(a,o,s))});let r=new Float32Array(3*n.length);n.forEach((e,n)=>{r.set([e.x,e.y,e.z],3*n)});let a=new i.LoY;a.setAttribute("position",new i.THS(r,3)),t.push(a)}else"MultiPolygon"===e.geometry.type?e.geometry.coordinates.forEach((e,n)=>{let r=n,a=e[0],o=[];a.forEach(e=>{let[n,t]=e;r++;let[a,s,l]=p?eo([-n,t]):ea([n,t]);o.push(new i.Pq0(a,s,l))});let s=new Float32Array(3*o.length);o.forEach((e,n)=>{s.set([e.x,e.y,e.z],3*n)});let l=new i.LoY;l.setAttribute("position",new i.THS(s,3)),t.push(l)}):("Polygon"===e.geometry.type?[e.geometry.coordinates]:e.geometry.coordinates).forEach(e=>{let n=[];e.forEach(e=>{e.forEach(e=>{let[t,r]=e,[a,o,s]=p?eo([-t,r]):ea([t,r]);n.push(new i.Pq0(a,o,s))})});let r=new Float32Array(3*n.length);n.forEach((e,n)=>{r.set([e.x,e.y,e.z],3*n)});let a=new i.LoY;a.setAttribute("position",new i.THS(r,3)),t.push(a)});return t}),[n,p,m]),v=(0,s.useMemo)(()=>g.map((e,n)=>{let t=new i.N1A(e,h);return(0,r.jsx)("primitive",{object:t},"border-".concat(n))}),[g,h]);return(0,r.jsx)(r.Fragment,{children:v})}let el=()=>{let[e,n]=(0,s.useState)(null),[t,i]=(0,s.useState)(null),[a,o]=(0,s.useState)(!1),{zRange:c,plotType:d,showBorders:m}=(0,l.Ws)((0,u.k)(e=>({zRange:e.zRange,plotType:e.plotType,showBorders:e.showBorders}))),[f,p]=(0,s.useState)(!1);return(0,s.useEffect)(()=>{"sphere"===d?p(!0):p(!1)},[d]),(0,T.D)(e=>{let{camera:n}=e;!f&&(Math.abs(n.rotation.z)>Math.PI/2?o(!0):a&&o(!1))}),(0,s.useEffect)(()=>{fetch("./ne_110m_coastline.json").then(e=>e.json()).then(e=>n(e.features)),fetch("./ne_110m_admin_0_countries.json").then(e=>e.json()).then(e=>i(e.features))},[]),(0,r.jsxs)("group",{visible:m&&"point-cloud"!=d,position:f?[0,0,0]:[0,0,a?c[0]:c[1]],children:[e&&(0,r.jsx)(es,{features:e}),t&&(0,r.jsx)(es,{features:t})]})};var eu=t(2349),ec=t(3571),ed=t(9385);let em=e=>{let{flipX:n,flipY:t}=e,{dimArrays:i,dimNames:a,dimUnits:o}=(0,l.on)((0,u.k)(e=>({dimArrays:e.dimArrays,dimNames:e.dimNames,dimUnits:e.dimUnits}))),{xRange:c,yRange:d,zRange:m,plotType:p,timeScale:x,animProg:h}=(0,l.Ws)((0,u.k)(e=>({xRange:e.xRange,yRange:e.yRange,zRange:e.zRange,plotType:e.plotType,timeScale:e.timeScale,animProg:e.animProg}))),g=[i[0].length,i[1].length,i[2].length],{shape:v,dataShape:y}=(0,l.on)((0,u.k)(e=>({shape:e.shape,dataShape:e.dataShape}))),S=(0,s.useMemo)(()=>"point-cloud"==p,[p]),z=(0,s.useMemo)(()=>y[0]/y[1]*x/2,[y,x]),w=(0,s.useMemo)(()=>v.y/v.x,[v]),b=(0,s.useMemo)(()=>new ed.G({color:"orange",linewidth:5}),[]),P=(0,s.useMemo)(()=>{let e=new eu.n().setPositions([c[0],0,0,c[1],0,0]);return new ec.b(e,b)},[c]),C=(0,s.useMemo)(()=>{let e=new eu.n().setPositions([0,d[0]*w,0,0,d[1]*w,0]);return new ec.b(e,b)},[d,w]),D=(0,s.useMemo)(()=>{let e=new eu.n().setPositions([0,0,S?m[0]*z:m[0],0,0,S?m[1]*z:m[1]]);return new ec.b(e,b)},[m,z,S]),k=(0,s.useMemo)(()=>{let e=new eu.n().setPositions([0,0,0,0,0,.05]);return new ec.b(e,b)},[]);return(0,r.jsxs)("group",{visible:"sphere"!=p,children:[(0,r.jsxs)("group",{position:[0,w*d[0],0],children:[(0,r.jsxs)("group",{position:[0,0,n?S?m[0]*z:m[0]:S?m[1]*z:m[1]],children:[(0,r.jsx)("primitive",{object:P},"xLine"),Array(7).fill(null).map((e,t)=>(c[0]+1)/2<=1.1666666666666667*t/7&&(c[1]+1)/2>=1.1666666666666667*t/7&&(0,r.jsxs)("group",{position:[-1+1.1666666666666667*t/3.5,0,0],children:[(0,r.jsx)("primitive",{object:k.clone(),rotation:[0,n?Math.PI:0,0]},t),(0,r.jsx)(Y.E,{anchorX:0==t?n?"right":"left":6==t?n?"left":"right":"center",anchorY:"top",fontSize:.05,color:"black","material-depthTest":!1,rotation:[-Math.PI/2,0,n?Math.PI:0],position:[0,0,n?-.05:.05],children:(0,f.SB)(i[2][Math.floor((g[2]-1)*t*.16666666666666666)],o[2])},"textX_".concat(t))]},"xGroup_".concat(t))),(0,r.jsx)(Y.E,{anchorX:"center",anchorY:"top",fontSize:.1,color:"black","material-depthTest":!1,rotation:[-Math.PI/2,0,n?Math.PI:0],position:[(c[0]+c[1])/2,0,n?-.2:.2],children:a[2]},"xTitle")]}),(0,r.jsxs)("group",{position:[t?c[1]:c[0],0,0],children:[(0,r.jsx)("primitive",{object:D},"zLine"),Array(7).fill(null).map((e,n)=>(m[0]+1)/2<=1.1666666666666667*n/7&&(m[1]+1)/2>=1.1666666666666667*n/7&&(0,r.jsxs)("group",{position:[0,0,S?-z+1.1666666666666667*n/3.5*z:-1+1.1666666666666667*n/3.5],children:[(0,r.jsx)("primitive",{object:k.clone(),rotation:[0,t?Math.PI/2:-Math.PI/2,0]},n),(0,r.jsx)(Y.E,{anchorX:0==n?t?"right":"left":6==n?t?"left":"right":"center",anchorY:"top",fontSize:.04,color:"black","material-depthTest":!1,rotation:[-Math.PI/2,0,t?Math.PI/2:-Math.PI/2],position:[t?.05:-.05,0,0],children:(0,f.SB)(i[0][(Math.floor((g[0]-1)*n*.16666666666666666)+Math.floor(g[0]*h))%g[0]],o[0])},"textY_".concat(n))]},"zGroup_".concat(n))),(0,r.jsx)(Y.E,{anchorX:"center",anchorY:"top",fontSize:.1,color:"black","material-depthTest":!1,rotation:[-Math.PI/2,0,t?Math.PI/2:-Math.PI/2],position:[t?.2:-.2,0,(m[0]+m[1])/2],children:a[0]},"xTitle")]})]}),(0,r.jsxs)("group",{position:[t?c[0]:c[1],0,n?S?m[0]*z:m[0]:S?m[1]*z:m[1]],children:[(0,r.jsx)("primitive",{object:C},"yLine"),Array(7).fill(null).map((e,a)=>(d[0]+1)/2<=1.1666666666666667*a/7&&(d[1]+1)/2>=1.1666666666666667*a/7&&(0,r.jsxs)("group",{position:[0,-v.y/2+1.1666666666666667*a/3.5*w,0],children:[(0,r.jsx)("primitive",{object:k.clone(),rotation:[0,t?-Math.PI/2:Math.PI/2,0]},a),(0,r.jsx)(Y.E,{anchorX:t?n?"left":"right":n?"right":"left",anchorY:"middle",fontSize:.05,color:"black","material-depthTest":!1,rotation:[0,n?Math.PI:0,0],position:[t?-.07:.07,0,0],children:(0,f.SB)(i[1][Math.floor((g[1]-1)*a*.16666666666666666)],o[1])},"text_".concat(a))]},"yGroup_".concat(a))),(0,r.jsx)(Y.E,{anchorX:t?n?"left":"right":n?"right":"left",anchorY:"middle",fontSize:.1,color:"black","material-depthTest":!1,rotation:[0,n?Math.PI:0,0],position:[t?-.25:.25,(d[0]+d[1])/2*w,0],children:a[1]},"xTitle")]})]})},ef=()=>{let[e,n]=(0,s.useState)(!1),[t,i]=(0,s.useState)(!1);return(0,T.D)(r=>{let{camera:a}=r,o=Math.abs(a.rotation.z)>Math.PI/2;e!==o&&n(o);let s=a.rotation.z>0&&a.rotation.x<0||a.rotation.z<=0&&a.rotation.x>0;t!==s&&i(s)}),(0,r.jsx)(r.Fragment,{children:(0,r.jsx)(em,{flipX:e,flipY:t})})};i.l2R.enabled=!0;let ep=function(){let{initStore:e,setZMeta:n}=(0,l.on)((0,u.k)(e=>({initStore:e.initStore,setZMeta:e.setZMeta}))),{currentStore:t,setCurrentStore:i}=(0,l.SZ)((0,u.k)(e=>({currentStore:e.currentStore,setCurrentStore:e.setCurrentStore})));(0,s.useEffect)(()=>{i((0,o.Oe)(e))},[e]);let d=(0,s.useMemo)(()=>new o.Y5(t),[t]),[m,f]=(0,s.useState)({});(0,s.useEffect)(()=>{let e=!0;(0,a.tz)(t).then(n=>{e&&f(n)});let r=(0,a.Tk)(t),i=(0,a.Bi)(r);return r.then(e=>n(e)),i.then(e=>{p(e)}),()=>{e=!1}},[t]);let{setVariables:p,setPlotOn:x,timeSeries:h,variable:g,metadata:y,plotOn:S}=(0,l.on)((0,u.k)(e=>({setVariables:e.setVariables,setPlotOn:e.setPlotOn,timeSeries:e.timeSeries,variable:e.variable,metadata:e.metadata,plotOn:e.plotOn})));return(0,s.useEffect)(()=>{"Default"===g&&x(!1)},[g]),(0,r.jsxs)(r.Fragment,{children:[(0,r.jsx)(v.oU,{}),(0,r.jsx)(v.$D,{}),!S&&(0,r.jsx)(v.Fp,{}),(0,r.jsx)(v.Rh,{}),"Default"===g&&(0,r.jsx)(c,{}),"Default"!=g&&(0,r.jsx)(K,{ZarrDS:d}),y&&(0,r.jsx)(v.OS,{data:y}),Object.keys(h).length>=1&&(0,r.jsx)(U,{})]})}},1894:(e,n,t)=>{Promise.resolve().then(t.bind(t,885))},3143:()=>{},6469:()=>{},9519:()=>{}},e=>{e.O(0,[62,503,577,197,669,813,755,858,56,667,645,812,959,152,195,17,100,970,800,984,65,748,562,896,212,246,358],()=>e(e.s=1894)),_N_E=e.O()}]);