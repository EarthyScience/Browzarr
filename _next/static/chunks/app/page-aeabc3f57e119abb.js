(self.webpackChunk_N_E=self.webpackChunk_N_E||[]).push([[974],{596:()=>{},1894:(e,n,t)=>{Promise.resolve().then(t.bind(t,3010))},3010:(e,n,t)=>{"use strict";t.d(n,{default:()=>eA});var r=t(9564),i=t(7510),a=t(1197),o=t(6431),l=t(9901),s=t(7776);let u=" // by Jeran Poehls\r\n\r\nout vec3 vOrigin;\r\nout vec3 vDirection;\r\nout vec3 aPosition;\r\n\r\nout vec2 Vuv;\r\n\r\nvoid main() {\r\n    vec4 worldPos = modelViewMatrix * vec4( position, 1.0 );\r\n\r\n    aPosition = position; //Pass out position for sphere frag\r\n    vOrigin = vec3( inverse( modelMatrix ) * vec4( cameraPosition, 1.0 ) ).xyz;\r\n    vDirection = position - vOrigin;\r\n    Vuv = uv;\r\n    gl_Position = projectionMatrix * worldPos;\r\n}";var d=t(4155),c=t(2911);let f=e=>{let{volTexture:n}=e,{shape:t,colormap:a,flipY:o}=(0,d.on)((0,c.k)(e=>({shape:e.shape,colormap:e.colormap,flipY:e.flipY}))),{valueRange:l,xRange:f,yRange:m,zRange:x,quality:p,animProg:h,cScale:g,cOffset:y,useFragOpt:S,transparency:v,nanTransparency:z,nanColor:b}=(0,d.Ws)((0,c.k)(e=>({valueRange:e.valueRange,xRange:e.xRange,yRange:e.yRange,zRange:e.zRange,quality:e.quality,animProg:e.animProg,cScale:e.cScale,cOffset:e.cOffset,useFragOpt:e.useFragOpt,transparency:e.transparency,nanTransparency:e.nanTransparency,nanColor:e.nanColor}))),w=t.y/t.x,_=(0,s.useMemo)(()=>new i.BKk({glslVersion:i.Wdf,uniforms:{map:{value:n},cmap:{value:a},cOffset:{value:y},cScale:{value:g},threshold:{value:new i.I9Y(l[0],l[1])},scale:{value:t},flatBounds:{value:new i.IUQ(-f[1],-f[0],x[0],x[1])},vertBounds:{value:new i.I9Y(m[0]*w,m[1]*w)},steps:{value:p},animateProg:{value:h},transparency:{value:v},nanAlpha:{value:1-z},nanColor:{value:new i.Q1f(b)}},vertexShader:u,fragmentShader:S?"// This is an optimized version of the original Volumetric shader\r\n\r\nprecision highp float;\r\nprecision highp sampler3D;\r\n\r\nin vec3 vOrigin;\r\nin vec3 vDirection;\r\n\r\nout vec4 color;\r\n\r\nuniform sampler3D map;\r\nuniform sampler2D cmap;\r\n\r\nuniform float cOffset;\r\nuniform float cScale;\r\nuniform vec3 scale;\r\nuniform vec2 threshold;\r\nuniform float steps;\r\nuniform vec4 flatBounds;\r\nuniform vec2 vertBounds;\r\nuniform float animateProg;\r\nuniform float transparency;\r\nuniform float nanAlpha;\r\nuniform vec3 nanColor;\r\n\r\nvec2 hitBox(vec3 orig, vec3 dir) {\r\n    vec3 box_min = vec3(-(scale * 0.5));\r\n    vec3 box_max = vec3(scale * 0.5);\r\n    vec3 inv_dir = 1.0 / dir;\r\n    vec3 tmin_tmp = (box_min - orig) * inv_dir;\r\n    vec3 tmax_tmp = (box_max - orig) * inv_dir;\r\n    vec3 tmin = min(tmin_tmp, tmax_tmp);\r\n    vec3 tmax = max(tmin_tmp, tmax_tmp);\r\n    float t0 = max(tmin.x, max(tmin.y, tmin.z));\r\n    float t1 = min(tmax.x, min(tmax.y, tmax.z));\r\n    return vec2(t0, t1);\r\n}\r\n\r\nfloat sample1( vec3 p ) {\r\n    return texture( map, p ).r;\r\n}\r\n\r\n#define epsilon 0.0001\r\n\r\nvoid main() {\r\n    vec3 rayDir = normalize(vDirection);\r\n    vec2 bounds = hitBox(vOrigin, rayDir);\r\n\r\n    if (bounds.x > bounds.y) discard;\r\n\r\n    bounds.x = max(bounds.x, 0.0);\r\n\r\n    vec3 p = vOrigin + bounds.x * rayDir;\r\n    vec3 inc = 1.0 / abs(rayDir);\r\n\r\n    //Step Sizes\r\n    float fineDelta = min(inc.x, min(inc.y, inc.z)) / steps;\r\n\r\n    float coarseDelta = min(inc.x, min(inc.y, inc.z))/50.;\r\n\r\n    float delta = fineDelta;\r\n\r\n    vec4 accumColor = vec4(0.0);\r\n    float alphaAcc = 0.0;\r\n\r\n    float t = bounds.x;\r\n    int countdown = 0;\r\n    bool useCoarseStep = false;\r\n\r\n    while (t < bounds.y) {\r\n        vec3 p = vOrigin + rayDir * t;\r\n        \r\n        // --- Boundary checks ---\r\n        if (p.x < flatBounds.x || p.x > flatBounds.y ||\r\n            p.z < flatBounds.z || p.z > flatBounds.w ||\r\n            p.y < vertBounds.x || p.y > vertBounds.y) {\r\n\r\n            t += useCoarseStep ? coarseDelta : fineDelta;\r\n            continue;\r\n        }\r\n\r\n        vec3 texCoord = p / scale + 0.5;\r\n        texCoord.z = mod(texCoord.z + animateProg, 1.0001);\r\n        float d = sample1(texCoord);\r\n\r\n        bool cond = nanAlpha == 0. ? (d > threshold.x) && (d < threshold.y) : (d > threshold.x) && (d < threshold.y+.01); //We skip over nans if the transparency is enabled\r\n        \r\n        if (cond) {\r\n            // Hit something interesting - switch to fine stepping\r\n            if (useCoarseStep) {\r\n                useCoarseStep = false;\r\n                countdown = 40;\r\n                // Step back to ensure we don't miss the boundary\r\n                t -= coarseDelta;\r\n                continue;\r\n            }\r\n            if (d == 1.){\r\n                accumColor.rgb += (1.0 - alphaAcc) * pow(nanAlpha, 5.) * nanColor.rgb;\r\n                alphaAcc += pow(nanAlpha, 5.);\r\n            }\r\n            else{\r\n                float sampLoc = (d - 0.5)*cScale + 0.5;\r\n                sampLoc = min(sampLoc+cOffset,0.99);\r\n                vec4 col = texture(cmap, vec2(sampLoc, 0.5));\r\n                float alpha = pow(max(sampLoc, 0.001), transparency);\r\n                accumColor.rgb += (1.0 - alphaAcc) * alpha * col.rgb;\r\n                alphaAcc += alpha * (1.0 - alphaAcc);\r\n            }      \r\n\r\n            if (alphaAcc >= 1.0) break;\r\n            \r\n            t += fineDelta;\r\n        }\r\n        else {\r\n            // Nothing interesting here\r\n            if (countdown > 0) {\r\n                countdown--;\r\n                t += fineDelta; // Continue with fine steps while countdown > 0\r\n            } else {\r\n                useCoarseStep = true;\r\n                t += coarseDelta; // Switch to coarse steps\r\n            }\r\n        }\r\n    }\r\n    accumColor.a = alphaAcc; // Set the final accumulated alpha\r\n    color = accumColor;\r\n    if (color.a == 0.0) discard;\r\n}\r\n":"// by Jeran Poehls\r\nprecision highp float;\r\nprecision highp sampler3D;\r\n\r\nin vec3 vOrigin;\r\nin vec3 vDirection;\r\n\r\nout vec4 color;\r\n\r\nuniform sampler3D map;\r\nuniform sampler2D cmap;\r\n\r\nuniform float cOffset;\r\nuniform float cScale;\r\nuniform vec3 scale;\r\nuniform vec2 threshold;\r\nuniform float steps;\r\nuniform vec4 flatBounds;\r\nuniform vec2 vertBounds;\r\nuniform float animateProg;\r\nuniform float transparency;\r\nuniform float nanAlpha;\r\nuniform vec3 nanColor;\r\n\r\n\r\nvec2 hitBox(vec3 orig, vec3 dir) {\r\n    vec3 box_min = vec3(-(scale * 0.5));\r\n    vec3 box_max = vec3(scale * 0.5);\r\n    vec3 inv_dir = 1.0 / dir;\r\n    vec3 tmin_tmp = (box_min - orig) * inv_dir;\r\n    vec3 tmax_tmp = (box_max - orig) * inv_dir;\r\n    vec3 tmin = min(tmin_tmp, tmax_tmp);\r\n    vec3 tmax = max(tmin_tmp, tmax_tmp);\r\n    float t0 = max(tmin.x, max(tmin.y, tmin.z));\r\n    float t1 = min(tmax.x, min(tmax.y, tmax.z));\r\n    return vec2(t0, t1);\r\n}\r\n\r\nfloat sample1( vec3 p ) {\r\n    return texture( map, p ).r;\r\n}\r\n\r\n#define epsilon 0.0001\r\n\r\nvoid main() {\r\n    vec3 rayDir = normalize(vDirection);\r\n    vec2 bounds = hitBox(vOrigin, rayDir);\r\n\r\n    if (bounds.x > bounds.y) discard;\r\n\r\n    bounds.x = max(bounds.x, 0.0);\r\n\r\n    vec3 p = vOrigin + bounds.x * rayDir;\r\n    vec3 inc = 1.0 / abs(rayDir);\r\n    float delta = min(inc.x, min(inc.y, inc.z));\r\n    delta /= steps;\r\n    vec4 accumColor = vec4(0.0);\r\n    float alphaAcc = 0.0;\r\n\r\n    for (float t = bounds.x; t < bounds.y; t += delta) {\r\n        p = vOrigin + rayDir * t;\r\n        if (p.x > -flatBounds.x || p.x < -flatBounds.y) { \r\n            continue;\r\n        }\r\n        if (-p.z > -flatBounds.z || -p.z < -flatBounds.w) {\r\n            continue;\r\n        }\r\n        if (p.y < vertBounds.x || p.y > vertBounds.y) {\r\n            continue;\r\n        }\r\n\r\n        vec3 texCoord = p / scale + 0.5;\r\n        texCoord.z = mod(texCoord.z + animateProg, 1.0001);\r\n        float d = sample1(texCoord);\r\n\r\n        bool cond = nanAlpha == 0. ? (d >= threshold.x) && (d <= threshold.y) : (d >= threshold.x) && (d <= threshold.y); //We skip over nans if the transparency is enabled\r\n        \r\n        if (cond) {\r\n            if (d == 1.){\r\n                accumColor.rgb += (1.0 - alphaAcc) * pow(nanAlpha, 5.) * nanColor.rgb;\r\n                alphaAcc += pow(nanAlpha, 5.);\r\n            }\r\n            else{\r\n                float sampLoc = (d - 0.5)*cScale + 0.5;\r\n                sampLoc = min(sampLoc+cOffset,0.99);\r\n                vec4 col = texture(cmap, vec2(sampLoc, 0.5));\r\n                float alpha = pow(max(sampLoc, 0.001), transparency);\r\n                accumColor.rgb += (1.0 - alphaAcc) * alpha * col.rgb;\r\n                alphaAcc += alpha * (1.0 - alphaAcc);\r\n            }      \r\n\r\n            if (alphaAcc >= 1.0) break;\r\n        }\r\n    }\r\n\r\n    accumColor.a = alphaAcc; // Set the final accumulated alpha\r\n    color = accumColor;\r\n    if (color.a == 0.0) discard;\r\n}\r\n",transparent:!0,blending:i.NTi,depthWrite:!1,side:i.hsX}),[n,t,a,y,g,l,f,m,x,p,h,S,v,z,b]),k=(0,s.useMemo)(()=>new i.WBB(2,4),[]);return(0,s.useEffect)(()=>()=>{k.dispose()},[]),(0,r.jsx)(r.Fragment,{children:(0,r.jsx)("mesh",{geometry:k,scale:[1,o?-1:1,1],children:(0,r.jsx)("primitive",{attach:"material",object:_})})})};var m=t(8804),x=t(1252);let p=e=>{let{ZarrDS:n}=e,{setTimeSeries:t,setPlotDim:a,setDimCoords:o,updateTimeSeries:l,updateDimCoords:u}=(0,d.on)((0,c.k)(e=>({setTimeSeries:e.setTimeSeries,setPlotDim:e.setPlotDim,setDimCoords:e.setDimCoords,updateTimeSeries:e.updateTimeSeries,updateDimCoords:e.updateDimCoords}))),{analysisMode:f,analysisArray:p}=(0,d.r2)((0,c.k)(e=>({analysisMode:e.analysisMode,analysisArray:e.analysisArray}))),{shape:h,dataShape:g,strides:y,dimArrays:S,dimNames:v,dimUnits:z}=(0,d.on)((0,c.k)(e=>({shape:e.shape,dataShape:e.dataShape,strides:e.strides,dimArrays:e.dimArrays,dimNames:e.dimNames,dimUnits:e.dimUnits}))),{selectTS:b,getColorIdx:w,incrementColorIdx:_}=(0,d.Ws)((0,c.k)(e=>({selectTS:e.selectTS,getColorIdx:e.getColorIdx,incrementColorIdx:e.incrementColorIdx}))),k=(0,s.useRef)(0),D=(0,s.useMemo)(()=>new i.iNn(1,1,1),[]);return(0,s.useEffect)(()=>()=>{D.dispose()},[]),(0,r.jsx)(r.Fragment,{children:(0,r.jsx)("mesh",{geometry:D,scale:h,onClick:e=>{e.stopPropagation(),e.intersections.length>0&&b&&function(e){e.point;let r=e.uv,i=e.normal,s=(0,m._8)(i);if(s!=k.current&&(t({}),o({})),k.current=s,n){var d,c;let e=(0,m.PE)({data:f?p:(0,m.Td)(),shape:g,stride:y},{uv:r,normal:i}),n=i.toArray().map((e,n)=>Math.abs(e)>0?n:null).filter(e=>null!==e);a(2-n[0]);let t=(0,m.jT)({normal:i,uv:r}).map((e,n)=>e?S[n][Math.round(e*S[n].length)]:null),o=v.filter((e,n)=>null!==t[n]),s=z.filter((e,n)=>null!==t[n]);t=t.filter(e=>null!==e);let h="".concat(t[0],"_").concat(t[1]);l({[h]:{color:(0,x.md)(w()/10,"Paired"),data:e}}),_(),u({[h]:{first:{name:o[0],loc:null!=(d=t[0])?d:0,units:s[0]},second:{name:o[1],loc:null!=(c=t[1])?c:0,units:s[1]},plot:{units:z[2-n[0]]}}})}}(e.intersections[0])},children:(0,r.jsx)("meshBasicMaterial",{transparent:!0,opacity:0})})})},h=e=>{let{dimensions:n,ZarrDS:t,setters:i}=e,{width:a,height:o,depth:l}=n,{setPoints:u,setStride:f,setDimWidth:p}=i,h=(0,d.Ws)(e=>e.selectTS),g=a/o,y=l/o,{dimArrays:S,dimUnits:v,dimNames:z,strides:b,dataShape:w,setPlotDim:_,setTimeSeries:k,updateTimeSeries:D,setDimCoords:C,updateDimCoords:P}=(0,d.on)((0,c.k)(e=>({dimArrays:e.dimArrays,dimUnits:e.dimUnits,dimNames:e.dimNames,strides:e.strides,dataShape:e.dataShape,setPlotDim:e.setPlotDim,setTimeSeries:e.setTimeSeries,updateTimeSeries:e.updateTimeSeries,setDimCoords:e.setDimCoords,updateDimCoords:e.updateDimCoords}))),{analysisMode:I,analysisArray:M}=(0,d.r2)((0,c.k)(e=>({analysisMode:e.analysisMode,analysisArray:e.analysisArray}))),j=(0,s.useRef)(null),{timeScale:B,getColorIdx:O,incrementColorIdx:A}=(0,d.Ws)((0,c.k)(e=>({timeScale:e.timeScale,getColorIdx:e.getColorIdx,incrementColorIdx:e.incrementColorIdx})));return(0,r.jsxs)("mesh",{scale:[g,1,y*B],onClick:function(e){if(!h)return;let n=e.uv,r=e.normal,i=(0,m._8)(r);if(i!=j.current&&(k({}),C({}),u({})),j.current=i,t){var s,d;let e=(0,m.PE)({data:I?M:(0,m.Td)(),shape:w,stride:b},{uv:n,normal:r}),t=r.toArray().map((e,n)=>Math.abs(e)>0?n:null).filter(e=>null!==e);_(2-t[0]);let i=(0,m.jT)({normal:r,uv:n}),c=i.map((e,n)=>e?S[n][Math.round(e*S[n].length-.5)]:null),h=z.filter((e,n)=>null!==c[n]),g=v.filter((e,n)=>null!==c[n]);c=c.filter(e=>null!==e);let y="".concat(c[0],"_").concat(c[1]),k={color:(0,x.md)(O()/10,"Paired"),data:e};A(),D({[y]:k}),P({[y]:{first:{name:h[0],loc:null!=(s=c[0])?s:0,units:g[0]},second:{name:h[1],loc:null!=(d=c[1])?d:0,units:g[1]},plot:{units:v[2-t[0]]}}});let C=[l,o,a].filter((e,n)=>null!=i[n]),j=[l,o,a].filter((e,n)=>null==i[n]),B=i.filter(e=>null!=e),U=b.filter((e,n)=>null!=i[n]),Y=Math.round(B[0]*C[0]-.5),L=Math.round(B[1]*C[1]-.5),T=Y*U[0]+L*U[1],N=b.filter((e,n)=>null==i[n]);p(j[0]),u(e=>({...{[y]:T},...e})),f(N[0])}},children:[(0,r.jsx)("boxGeometry",{}),(0,r.jsx)("meshBasicMaterial",{transparent:!0,opacity:0})]})},g=e=>{let{textures:n,ZarrDS:t}=e,{texture:a,colormap:o}=n,{timeSeries:l,flipY:u}=(0,d.on)((0,c.k)(e=>({timeSeries:e.timeSeries,flipY:e.flipY}))),{scalePoints:f,scaleIntensity:m,pointSize:x,cScale:p,cOffset:g,valueRange:y,animProg:S,selectTS:v,timeScale:z,xRange:b,yRange:w,zRange:_}=(0,d.Ws)((0,c.k)(e=>({scalePoints:e.scalePoints,scaleIntensity:e.scaleIntensity,pointSize:e.pointSize,cScale:e.cScale,cOffset:e.cOffset,valueRange:e.valueRange,animProg:e.animProg,selectTS:e.selectTS,timeScale:e.timeScale,xRange:e.xRange,yRange:e.yRange,zRange:e.zRange}))),k=(0,d.$U)(e=>e.setError),[D,C]=(0,s.useState)({}),[P,I]=(0,s.useState)(Array(10).fill(-1)),[M,j]=(0,s.useState)(1),[B,O]=(0,s.useState)(0);(0,s.useEffect)(()=>{let e=Object.keys(D),n=Object.keys(l),t=(e=e.filter(e=>n.includes(e))).map(e=>D[e]);I([...t,...Array(Math.max(0,10-t.length)).fill(-1)])},[l,D]);let{data:A,width:U,height:Y,depth:L}=(0,s.useMemo)(()=>a instanceof i.dYF?{data:a.image.data,width:a.image.width,height:a.image.height,depth:a.image.depth}:(console.warn("Provided texture is not a Data3DTexture"),{data:[],width:0,height:0,depth:0}),[a]),T=(0,s.useMemo)(()=>U/Y,[U,Y]),N=(0,s.useMemo)(()=>L/Y,[L,Y]),{positions:V,values:E}=(0,s.useMemo)(()=>{let e;try{e=new Float32Array(L*Y*U*3)}catch(e){return k("oom"),{positions:[],values:[]}}let n=new Uint8Array(L*Y*U);for(let t=0;t<L;t++)for(let r=0;r<Y;r++)for(let i=0;i<U;i++){let a=i+r*U+t*U*Y,o=A[a]||0,l=i/(U-1)-.5,s=(r/(Y-1)-.5)/T,u=(t/(L-1)-.5)*N,d=3*a;e[d]=2*l,e[d+1]=2*s,e[d+2]=u,n[a]=o}return{positions:e,values:n}},[A,U,Y,L]),G=(0,s.useMemo)(()=>{let e=new i.LoY;return e.setAttribute("position",new i.qtW(V,3)),e.setAttribute("value",new i.qtW(E,1)),e},[V,E]),X=(0,s.useMemo)(()=>new i.BKk({glslVersion:i.Wdf,uniforms:{pointSize:{value:x},cmap:{value:o},cOffset:{value:g},cScale:{value:p},valueRange:{value:new i.I9Y(y[0],y[1])},scalePoints:{value:f},scaleIntensity:{value:m},startIDs:{value:P},stride:{value:M},showTransect:{value:v},dimWidth:{value:B},timeScale:{value:z},animateProg:{value:S},depthRatio:{value:N},flatBounds:{value:new i.IUQ(b[0],b[1],_[0]*N/2,_[1]*N/2)},vertBounds:{value:new i.I9Y(w[0]/T,w[1]/T)}},vertexShader:"attribute float value;\r\nout float vValue;\r\n\r\nflat out int highlight;\r\n\r\nuniform float pointSize;\r\nuniform bool scalePoints;\r\nuniform float scaleIntensity;\r\nuniform vec2 valueRange;\r\nuniform int[10] startIDs;\r\nuniform int stride;\r\nuniform int dimWidth;\r\nuniform bool showTransect;\r\nuniform float timeScale;\r\nuniform float animateProg;\r\nuniform float depthRatio;\r\nuniform vec4 flatBounds;\r\nuniform vec2 vertBounds;\r\n\r\nbool isValidPoint(){\r\n    for (int i = 0; i < 10; i++){\r\n        if (startIDs[i] == -1){\r\n            return false;\r\n        }\r\n        int rePos = gl_VertexID - startIDs[i];\r\n        bool isValid = rePos % stride == 0;\r\n        bool secondary = gl_VertexID < (startIDs[i] + dimWidth*stride) && gl_VertexID > startIDs[i];\r\n        isValid = isValid && secondary;\r\n        if (isValid){\r\n            return true;\r\n        }\r\n    }\r\n    return false;\r\n}\r\n\r\nvoid main() {\r\n    vValue = value/255.;\r\n    vec3 scaledPos = position;\r\n    scaledPos.z += depthRatio/2.;\r\n    scaledPos.z = mod(scaledPos.z + animateProg*depthRatio, depthRatio);\r\n    scaledPos.z -= depthRatio/2.;\r\n\r\n    scaledPos.z *= timeScale;\r\n    gl_Position = projectionMatrix * modelViewMatrix * vec4(scaledPos, 1.0);\r\n    float pointScale = pointSize/gl_Position.w;\r\n    pointScale = scalePoints ? pointScale*pow(vValue,scaleIntensity) : pointScale;\r\n\r\n    bool isValid = isValidPoint();\r\n    highlight = isValid ? 1 : 0;\r\n    \r\n    if (value == 255. || (pointScale*gl_Position.w < 0.75 && scalePoints)){ //Hide points that are invisible or get too small when scalled\r\n        gl_Position = vec4(2.0, 2.0, 2.0, 1.0);\r\n    }\r\n\r\n    if (vValue < valueRange.x || vValue > valueRange.y){ //Hide points that are outside of value range\r\n        gl_Position = vec4(2.0, 2.0, 2.0, 1.0);\r\n    }\r\n\r\n    vec2 scaledZBounds = vec2(flatBounds.z,  flatBounds.w) * vec2(timeScale);\r\n    bool xCheck = scaledPos.x < flatBounds.x || scaledPos.x > flatBounds.y;\r\n    bool zCheck = scaledPos.z < scaledZBounds.x || scaledPos.z > scaledZBounds.y;\r\n    bool yCheck = scaledPos.y < vertBounds.x || scaledPos.y> vertBounds.y;\r\n\r\n    if (xCheck || zCheck || yCheck){ //Hide points that are clipped\r\n        gl_Position = vec4(2.0, 2.0, 2.0, 1.0);\r\n    }\r\n    \r\n    if (showTransect){\r\n        gl_PointSize = isValid ? max(pointScale*5. , pointScale+80./gl_Position.w) : pointScale;\r\n    }\r\n    else{\r\n        gl_PointSize =  pointScale;\r\n    }\r\n\r\n}\r\n",fragmentShader:"out vec4 Color;\r\n\r\nin float vValue;\r\nflat in int highlight;\r\n\r\n\r\nuniform sampler2D cmap;\r\nuniform float cScale;\r\nuniform float cOffset;\r\nuniform bool showTransect;\r\n\r\nvoid main() {\r\n\r\n    float sampLoc = vValue == 1. ? vValue : (vValue - 0.5)*cScale + 0.5;\r\n    sampLoc = vValue == 1. ? vValue : min(sampLoc+cOffset,0.99);\r\n    vec4 color = texture(cmap, vec2(sampLoc, 0.5));\r\n    color.a = 1.;\r\n    Color = color;\r\n    if (showTransect){\r\n        Color = highlight == 1 ? color : color * vec4(vec3(0.4),1.);\r\n    }\r\n    else{\r\n        Color = color;\r\n    }\r\n\r\n}\r\n",depthWrite:!0,transparent:!0,blending:i.NTi,side:i.$EB}),[x,o,g,p,y,f,m,P,M,v,S,z,N,T,b,w,_]);return(0,r.jsxs)(r.Fragment,{children:[(0,r.jsx)("mesh",{scale:[1,u?-1:1,1],children:(0,r.jsx)("points",{geometry:G,material:X})}),(0,r.jsx)(h,{dimensions:{width:U,height:Y,depth:L},ZarrDS:t,setters:{setPoints:C,setStride:j,setDimWidth:O}})]})};var y=t(6668),S=t(4434);t(9519);var v=t(1279);t(596);var z=t(450),b=t(3964);function w(e){let{...n}=e;return(0,r.jsx)(z.bL,{"data-slot":"dropdown-menu",...n})}function _(e){let{...n}=e;return(0,r.jsx)(z.l9,{"data-slot":"dropdown-menu-trigger",...n})}function k(e){let{className:n,sideOffset:t=4,...i}=e;return(0,r.jsx)(z.ZL,{children:(0,r.jsx)(z.UC,{"data-slot":"dropdown-menu-content",sideOffset:t,className:(0,b.cn)("bg-popover text-popover-foreground data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0 data-[state=closed]:zoom-out-95 data-[state=open]:zoom-in-95 data-[side=bottom]:slide-in-from-top-2 data-[side=left]:slide-in-from-right-2 data-[side=right]:slide-in-from-left-2 data-[side=top]:slide-in-from-bottom-2 z-50 max-h-(--radix-dropdown-menu-content-available-height) min-w-[8rem] origin-(--radix-dropdown-menu-content-transform-origin) overflow-x-hidden overflow-y-auto rounded-md border p-1 shadow-md",n),...i})})}function D(e){let{...n}=e;return(0,r.jsx)(z.YJ,{"data-slot":"dropdown-menu-group",...n})}function C(e){let{className:n,inset:t,variant:i="default",...a}=e;return(0,r.jsx)(z.q7,{"data-slot":"dropdown-menu-item","data-inset":t,"data-variant":i,className:(0,b.cn)("focus:bg-accent focus:text-accent-foreground data-[variant=destructive]:text-destructive data-[variant=destructive]:focus:bg-destructive/10 dark:data-[variant=destructive]:focus:bg-destructive/20 data-[variant=destructive]:focus:text-destructive data-[variant=destructive]:*:[svg]:!text-destructive [&_svg:not([class*='text-'])]:text-muted-foreground relative flex cursor-default items-center gap-2 rounded-sm px-2 py-1.5 text-sm outline-hidden select-none data-[disabled]:pointer-events-none data-[disabled]:opacity-50 data-[inset]:pl-8 [&_svg]:pointer-events-none [&_svg]:shrink-0 [&_svg:not([class*='size-'])]:size-4",n),...a})}function P(e){let{className:n,...t}=e;return(0,r.jsx)(z.wv,{"data-slot":"dropdown-menu-separator",className:(0,b.cn)("bg-border -mx-1 my-1 h-px",n),...t})}var I=t(3656);let M=s.memo(function(){let{showPoints:e,linePointSize:n,pointColor:t,useCustomPointColor:i,setLinePointSize:a,setPointColor:o,setUseCustomPointColor:l}=(0,d.Ws)((0,c.k)(e=>({showPoints:e.showPoints,linePointSize:e.linePointSize,pointColor:e.pointColor,useCustomPointColor:e.useCustomPointColor,setLinePointSize:e.setLinePointSize,setPointColor:e.setPointColor,setUseCustomPointColor:e.setUseCustomPointColor})));return e?(0,r.jsxs)(r.Fragment,{children:[(0,r.jsxs)("div",{className:"w-full flex items-center mb-2",children:[(0,r.jsx)("div",{className:"w-[40%]",children:(0,r.jsx)("b",{children:"Point Size"})}),(0,r.jsx)(I.A,{min:1,max:10,step:.1,value:[n],className:"flex-1 my-2",onValueChange:e=>a(e[0])})]}),(0,r.jsxs)("div",{className:"w-full flex items-center mb-2",children:[(0,r.jsx)("div",{className:"w-[40%]",children:(0,r.jsx)("b",{children:"Point Color"})}),i&&(0,r.jsx)("input",{type:"color",title:"Point Color",value:t,onChange:e=>o(e.target.value)}),(0,r.jsxs)(v.$,{className:"h-8 px-2 py-1",variant:"outline",onClick:()=>l(!i),children:["Use",i?" Browzarr Color":" Custom Color"]})]})]}):null}),j=s.memo(function(){let{lineWidth:e,lineColor:n,useLineColor:t,lineResolution:i,useCustomColor:a,setLineWidth:o,setLineColor:l,setUseLineColor:s,setLineResolution:u,setUseCustomColor:f}=(0,d.Ws)((0,c.k)(e=>({lineWidth:e.lineWidth,lineColor:e.lineColor,useLineColor:e.useLineColor,lineResolution:e.lineResolution,useCustomColor:e.useCustomColor,setLineWidth:e.setLineWidth,setLineColor:e.setLineColor,setUseLineColor:e.setUseLineColor,setLineResolution:e.setLineResolution,setUseCustomColor:e.setUseCustomColor})));return(0,r.jsxs)(r.Fragment,{children:[(0,r.jsxs)("div",{className:"w-full flex items-center mb-2",children:[(0,r.jsx)("div",{className:"w-[40%]",children:(0,r.jsx)("b",{children:"Line Width"})}),(0,r.jsx)(I.A,{min:1,max:10,step:.2,value:[e],className:"flex-1 my-2",onValueChange:e=>o(e[0])})]}),(0,r.jsxs)("div",{className:"w-full flex items-center mb-2",children:[(0,r.jsx)("div",{className:"w-[40%]",children:(0,r.jsx)("b",{children:"Line Resolution"})}),(0,r.jsx)(I.A,{min:1,max:10,step:1,value:[i],className:"flex-1 my-2",onValueChange:e=>u(e[0])})]}),(0,r.jsxs)("div",{className:"w-full flex items-center",children:[(0,r.jsx)("div",{className:"w-[40%]",children:(0,r.jsx)("b",{children:"Line Color"})}),a&&(0,r.jsx)("input",{type:"color",title:"Line Color",value:n,onChange:e=>l(e.target.value)}),!a&&(0,r.jsxs)(v.$,{className:"h-8 px-2 py-5",variant:"outline",onClick:()=>s(!t),children:["Use ",(0,r.jsx)("br",{}),t?"Individual Color":"Plot Color"]}),(0,r.jsxs)(v.$,{className:"h-8 px-2 py-5",variant:"outline",onClick:()=>f(!a),children:["Use ",(0,r.jsx)("br",{}),a?"Browzarr Color":"Custom Color"]})]})]})}),B=s.memo(function(){let{showPoints:e,setShowPoints:n}=(0,d.Ws)((0,c.k)(e=>({showPoints:e.showPoints,setShowPoints:e.setShowPoints})));return(0,r.jsx)("div",{className:"plotline-options",children:(0,r.jsxs)(w,{children:[(0,r.jsx)(_,{asChild:!0,children:(0,r.jsx)(v.$,{className:"cursor-pointer",variant:"outline",children:"Line Options"})}),(0,r.jsxs)(k,{className:"w-80 items-center",align:"center",children:[(0,r.jsx)(D,{onClick:e=>e.preventDefault(),children:(0,r.jsx)(C,{children:(0,r.jsx)(v.$,{variant:"outline",onClick:t=>{t.preventDefault(),n(!e)},children:e?"Hide Points":"Show Points"})})}),(0,r.jsx)(M,{}),(0,r.jsx)(P,{}),(0,r.jsx)(j,{})]})]})})});var O=t(9797);function A(e){let{pointID:n,pointLoc:t,showPointInfo:i,plotUnits:a}=e,{plotDim:o,dimArrays:l,dimNames:u,dimUnits:f,timeSeries:x}=(0,d.on)((0,c.k)(e=>({plotDim:e.plotDim,dimArrays:e.dimArrays,dimNames:e.dimNames,dimUnits:e.dimUnits,timeSeries:e.timeSeries}))),p=0,h=0;if(Object.entries(n).length>0&&Object.entries(x).length>0){let[e,t]=n;p=x[e].data[t],h=l[o][t]}let[g,y]=t,[S,v]=(0,s.useState)(!1);return(0,s.useEffect)(()=>{if(!i){let e=setTimeout(()=>{v(!1)},100);return()=>clearTimeout(e)}v(!0)},[i]),(0,r.jsx)(r.Fragment,{children:S&&(0,r.jsxs)("div",{className:"point-info",style:{left:"".concat(g,"px"),top:"".concat(y,"px")},children:["".concat(p.toFixed(2)).concat(a),(0,r.jsx)("br",{}),"".concat(u[o],": ").concat((0,m.SB)(h,f[o]),"       \n        ")]})})}function U(){let{coords:e,timeSeries:n,setDimCoords:t,setTimeSeries:i}=(0,d.on)((0,c.k)(e=>({coords:e.dimCoords,timeSeries:e.timeSeries,setDimCoords:e.setDimCoords,setTimeSeries:e.setTimeSeries}))),[a,o]=(0,s.useState)(!1),l=(0,s.useRef)([0,Math.round(.255*window.innerHeight)]),u=(0,s.useRef)([0,Math.round(.255*window.innerHeight)]),[f,x]=(0,s.useState)([0,Math.round(.255*window.innerHeight)]);function p(e){if(a){let n=l.current[0]-e.clientX,t=l.current[1]-e.clientY,r=Math.min(Math.max(u.current[0]-n,10),window.innerWidth-120),i=Math.max(u.current[1]+t,0);x([Math.min(r,window.innerWidth-100),Math.min(i,window.innerHeight-100)])}}function h(){o(!1)}return(0,s.useEffect)(()=>(a&&(document.addEventListener("mousemove",p),document.addEventListener("mouseup",h)),()=>{document.removeEventListener("mousemove",p),document.removeEventListener("mouseup",h)}),[a]),(0,r.jsx)(r.Fragment,{children:(0,r.jsx)("div",{className:"coord-container",onPointerDown:function(e){l.current=[e.clientX,e.clientY],u.current=[...f],o(!0)},onPointerMove:p,onPointerUp:()=>o(!1),style:{left:"".concat(f[0],"px"),bottom:"".concat(f[1],"px")},children:Object.keys(e).length>0&&Object.keys(e).reverse().map((a,o)=>(0,r.jsxs)("div",{className:"plot-coords",style:{background:"rgb(".concat(n[a].color,")"),justifyContent:"space-between"},children:[(0,r.jsx)("b",{children:"".concat(e[a].first.name,": ")}),"".concat((0,m.SB)(e[a].first.loc,e[a].first.units)),(0,r.jsx)("br",{}),(0,r.jsx)("b",{children:"".concat(e[a].second.name,": ")}),"".concat((0,m.SB)(e[a].second.loc,e[a].second.units)),(0,r.jsx)(O.Xr4,{onClick:()=>(function(r){let{[r]:a,...o}=e;t(o);let{[r]:l,...s}=n;i(s)})(a),color:"red",style:{cursor:"pointer",zIndex:3}})]},a))})})}function Y(){let[e,n]=(0,s.useState)(["",0]),[t,i]=(0,s.useState)([0,0]),[a,o]=(0,s.useState)(!1),[l,u]=(0,s.useState)(Math.round(window.innerHeight-.25*window.innerHeight)),c=(0,d.on)(e=>e.metadata),f=c?c.units:"Default",[m,x]=(0,s.useState)(1),[p,h]=(0,s.useState)(1);(0,s.useEffect)(()=>{let e=()=>{let e=Math.round(window.innerHeight-.25*window.innerHeight);u(e),document.documentElement.style.setProperty("--plot-height","".concat(e,"px"))};return window.addEventListener("orientationchange",e),window.addEventListener("resize",e),()=>{window.removeEventListener("orientationchange",e),window.removeEventListener("resize",e)}},[]),(0,s.useEffect)(()=>{document.documentElement.style.setProperty("--plot-height","".concat(l,"px"))},[l]);let g=window.innerHeight-l>=10;return(0,r.jsxs)(r.Fragment,{children:[!g&&(0,r.jsx)(S.de,{onClick:()=>{u(window.innerHeight-60)}}),g&&(0,r.jsxs)("div",{className:"plot-canvas",children:[(0,r.jsx)(B,{}),a&&(0,r.jsx)(A,{pointID:e,pointLoc:t,showPointInfo:a,plotUnits:f}),(0,r.jsx)(S.A,{height:l,setHeight:u}),(0,r.jsx)(S.gj,{scale:m,setScale:x}),(0,r.jsx)(S.LC,{scale:p,setScale:h}),(0,r.jsxs)(y.Hl,{orthographic:!0,camera:{position:[0,0,100]},frameloop:"demand",children:[(0,r.jsx)(es,{height:l,yScale:m,pointSetters:{setPointID:n,setPointLoc:i,setShowPointInfo:o},xScale:p}),(0,r.jsx)(V,{height:l,yScale:m,xScale:p})]}),(0,r.jsx)(U,{})]})]})}var L=t(823),T=t(7039),N=t(1485);function V(e){let{colorTicks:n="grey",tickSize:t=4,fontSize:i=14,showGrid:a=!0,gridOpacity:o=.5,height:l,yScale:u=1,xScale:f=1}=e,{camera:x}=(0,N.C)(),[p,h]=(0,s.useState)({left:0,right:0,top:0,bottom:0}),{dimCoords:g,dimArrays:y,plotDim:S,valueScales:v}=(0,d.on)((0,c.k)(e=>({dimCoords:e.dimCoords,dimArrays:e.dimArrays,plotDim:e.plotDim,valueScales:e.valueScales}))),z=y[S],b=z.length,w=v.maxVal-v.minVal,_=(0,s.useMemo)(()=>{let e=["Jan","Feb","Mar","Apr","May","Jun","Jul","Aug","Sep","Oct","Nov","Dec"];if(z){if(z.every(e=>"bigint"==typeof e)){let n=Object.keys(g).length>0?Object.keys(g)[0]:null,t=n?(0,m.lt)(g[n].plot.units):1,r=[];for(let n=0;n<z.length;n++){let i=new Date(Number(z[n])*t),a="".concat(i.getDate().toString().padStart(2,"0")," ").concat(e[i.getMonth()],"\n").concat(i.getFullYear());r.push(a)}return r}return z.map(e=>String(e))}},[z,g]),k=(0,s.useMemo)(()=>{let e=window.innerWidth,n=window.innerHeight-l;return{left:-e/2+x.position.x,right:e/2+x.position.x,top:n/2+x.position.y,bottom:-n/2+x.position.y}},[]),[D,C]=(0,s.useState)(x.zoom),P=(0,s.useMemo)(()=>{let e=1/x.zoom;return{tickSize:t*e,fontSize:i/e,labelOffset:t*e}},[x.zoom,t,i]);(0,N.D)(()=>{x.zoom!==D&&C(x.zoom);let e=window.innerWidth/x.zoom,n=(window.innerHeight-l)/x.zoom,t={left:-e/2+x.position.x,right:e/2+x.position.x,top:n/2+x.position.y,bottom:-n/2+x.position.y};JSON.stringify(p)!=JSON.stringify(t)&&h(t)});let I=(0,s.useRef)(null),M=(0,s.useRef)(null);(0,s.useEffect)(()=>(I.current&&clearTimeout(I.current),M.current&&(I.current=setTimeout(()=>{M.current&&M.current.reset()},100)),()=>{null!==I.current&&clearTimeout(I.current)}),[l]);let j=(p.top+p.bottom)/2,B=(p.left+p.right)/2;return(0,r.jsxs)("group",{children:[a&&(0,r.jsxs)(r.Fragment,{children:[Array.from({length:10},(e,t)=>{var i;if(0===t||9===t)return null;let a=+Math.round(p.left/1)+(Math.round(p.right/1)-Math.round(p.left/1))*(t/9),l=a/f/(k.right-k.left)+.5;return(0,r.jsxs)(s.Fragment,{children:[(0,r.jsx)("group",{position:[a,j,0],children:(0,r.jsxs)("line",{children:[(0,r.jsx)("bufferGeometry",{children:(0,r.jsx)("float32BufferAttribute",{attach:"attributes-position",args:[new Float32Array([0,p.top-j,0,0,p.bottom-j,0]),3]})}),(0,r.jsx)("lineDashedMaterial",{color:n,opacity:o,transparent:!0,dashSize:.5,gapSize:.5})]},"vgrid-".concat(t))}),(0,r.jsxs)("group",{position:[a,p.top,0],children:[(0,r.jsxs)("line",{children:[(0,r.jsx)("bufferGeometry",{children:(0,r.jsx)("float32BufferAttribute",{attach:"attributes-position",args:[new Float32Array([0,0,0,0,-P.tickSize,0]),3]})}),(0,r.jsx)("lineBasicMaterial",{color:n})]}),0!==t&&9!==t&&(0,r.jsx)(L.E,{position:[0,P.tickSize/4-P.labelOffset,0],fontSize:P.fontSize/D**2,color:n,anchorX:"center",anchorY:"top",children:null!=(i=null==_?void 0:_[Math.round(l*b-.5)])?i:""})]},"top-tick-".concat(t))]},"vert-group-".concat(t))}),Array.from({length:8},(e,t)=>{if(0===t||7===t)return null;let i=p.bottom+(p.top-p.bottom)*(t/7),a=i/u/(p.top-p.bottom)/D+.5;return(0,r.jsxs)(s.Fragment,{children:[(0,r.jsx)("group",{position:[B,i,0],children:(0,r.jsxs)("line",{children:[(0,r.jsx)("bufferGeometry",{children:(0,r.jsx)("float32BufferAttribute",{attach:"attributes-position",args:[new Float32Array([p.left-B,0,0,p.right-B,0,0]),3]})}),(0,r.jsx)("lineDashedMaterial",{color:n,opacity:o,transparent:!0,dashSize:0,gapSize:.5,linewidth:1})]})},"hgrid-".concat(t)),(0,r.jsxs)("group",{position:[p.right,i,0],children:[(0,r.jsxs)("line",{children:[(0,r.jsx)("bufferGeometry",{children:(0,r.jsx)("float32BufferAttribute",{attach:"attributes-position",args:[new Float32Array([0,0,0,-P.tickSize,0,0]),3]})}),(0,r.jsx)("lineBasicMaterial",{color:n})]}),0!==t&&7!==t&&(0,r.jsx)(L.E,{position:[-P.tickSize-P.labelOffset,0,0],fontSize:P.fontSize/D**2,color:n,anchorX:"right",anchorY:"middle",children:(v.minVal+a*w).toFixed(1)})]},"right-tick-".concat(t))]},"vert-group-".concat(t))})]}),(0,r.jsx)(T.N,{ref:M,enableRotate:!1,enablePan:!0,enableZoom:!0,zoomSpeed:.85,maxDistance:500,maxZoom:20,minZoom:.5})]})}var E=t(21);t(6469);let G=e=>{let{loc:n,show:t,info:i}=e,{dimNames:a,dimUnits:o}=(0,d.on)((0,c.k)(e=>({dimNames:e.dimNames,dimUnits:e.dimUnits}))),l=(0,d.r2)(e=>e.axis),u=(0,s.useMemo)(()=>a.length<3?[a[0],a[1]]:a.filter((e,n)=>n!=l),[a,l]),f=(0,s.useMemo)(()=>a.length<3?[o[0],o[1]]:o.filter((e,n)=>n!=l),[o,l]);return(0,r.jsxs)("div",{className:"analysis-overlay",style:{left:"".concat(n[0]+10,"px"),top:"".concat(n[1]+10,"px"),display:t?"":"none"},children:["".concat(u[0],": ").concat(t&&(0,m.SB)(i[0],f[0])),(0,r.jsx)("br",{}),"".concat(u[1],": ").concat(t&&(0,m.SB)(i[1],f[1])),(0,r.jsx)("br",{}),"Value: ".concat(Math.round(100*i[2])/100)]})};var X=t(7556);let R="\n    struct Params {\n        zStride: u32,\n        yStride: u32,\n        xStride: u32,\n        xSize: u32,\n        ySize: u32,\n        reduceDim: u32,\n        dimLength: u32,\n    };\n    @group(0) @binding(0) var<storage, read> inputData: array<f32>;\n    @group(0) @binding(1) var<storage, read_write> outputData: array<f32>;\n    @group(0) @binding(2) var<uniform> params: Params;\n\n    @compute @workgroup_size(16, 16, 1)\n    fn main(@builtin(global_invocation_id) global_id: vec3<u32>) {\n        let zStride = params.zStride;\n        let yStride = params.yStride;\n        let xStride = params.xStride;\n        let xSize = params.xSize;\n        let ySize = params.ySize;\n        let reduceDim = params.reduceDim;\n        let dimLength = params.dimLength;\n                        \n        let outX = global_id.y;\n        let outY = global_id.x;\n        \n        if (outX >= xSize || outY >= ySize) {\n            return;\n        }\n",F="\n    struct Params {\n        xStride: u32,\n        yStride: u32,\n        zStride: u32,\n        xSize: u32,\n        ySize: u32,\n        zSize: u32,\n        workGroups: vec3<u32>,\n        kernelSize: u32,\n        kernelDepth: u32\n    };\n    @group(0) @binding(0) var<storage, read> inputData: array<f32>;\n    @group(0) @binding(1) var<storage, read_write> outputData: array<f32>;\n    @group(0) @binding(2) var<uniform> params: Params;\n\n    @compute @workgroup_size(4, 4, 4)\n    fn main(@builtin(global_invocation_id) global_id: vec3<u32>) {\n        let zStride = params.zStride;\n        let yStride = params.yStride;\n        let xStride = params.xStride; \n        let xSize = params.xSize;\n        let ySize = params.ySize;\n        let zSize = params.zSize; \n        let workGroups = params.workGroups;\n        let kernelSize = params.kernelSize;\n        let kernelDepth = params.kernelDepth;\n\n        let outX = global_id.x; \n        let outY = global_id.y;\n        let outZ = global_id.z; \n\n        if (outX >= xSize || outY >= ySize || outZ >= zSize) {\n            return;\n        }\n\n        let total_threads_per_slice = workGroups.x * workGroups.y * 16;\n        let globalIdx = global_id.z * total_threads_per_slice + \n                        global_id.y * (workGroups.x * 4) + \n                        global_id.x;\n\n        let xy_radius: i32 = i32(kernelSize/2u);\n        let z_radius: i32 = i32(kernelDepth/2u);\n\n        var xyOffset: i32 = 0; //These offsets are for kernelsizes of 1. I didn't wanna rewrite everything else for that case\n        var zOffset: i32 = 0;\n        if (xy_radius == 0){\n            xyOffset = -1;\n        }\n        if (z_radius == 0){\n            zOffset = -1;\n        }\n",W="\n    struct Params {\n        xStride: u32,\n        yStride: u32,\n        xSize: u32,\n        ySize: u32,\n        kernelSize: u32,\n        kernelDepth: u32\n    };\n    @group(0) @binding(0) var<storage, read> inputData: array<f32>;\n    @group(0) @binding(1) var<storage, read_write> outputData: array<f32>;\n    @group(0) @binding(2) var<uniform> params: Params;\n\n    @compute @workgroup_size(16, 16, 1)\n    fn main(@builtin(global_invocation_id) global_id: vec3<u32>,) {\n        let xStride = params.xStride; \n        let yStride = params.yStride;\n        let xSize = params.xSize;\n        let ySize = params.ySize;\n        let kernelSize = params.kernelSize;\n\n        let outX = global_id.x; \n        let outY = global_id.y;\n\n        if (outX >= xSize|| outY >= ySize) {\n            return;\n        }\n\n        let globalIdx = outY * xSize + outX;\n        let thisVal = inputData[globalIdx];\n        let isNaN: bool = thisVal != thisVal;\n        if (isNaN){\n            outputData[globalIdx] = thisVal;\n            return;\n        }   \n\n        let xy_radius: i32 = i32(kernelSize/2u);\n\n",q={Mean:"\n    ".concat(R,"\n        var sum: f32 = 0.0;\n        \n        // Iterate along the dimension we're averaging\n        if (reduceDim == 0u) { // Average along Z\n            let cCoord = outX * xStride + outY * yStride;\n            for (var z: u32 = 0u; z < dimLength; z++) {\n                let inputIndex = cCoord + (z * zStride);\n                sum += inputData[inputIndex];\n            }\n        } else if (reduceDim == 1u) { // Average along Y\n            let cCoord = outX * xStride + outY * zStride;\n            for (var y: u32 = 0u; y < dimLength; y++) {\n                let inputIndex = cCoord + (y * yStride);\n                sum += inputData[inputIndex];\n            }\n        } else { // Average along X\n            let cCoord = outX * yStride + outY * zStride;\n            for (var x: u32 = 0u; x < dimLength; x++) {\n                let inputIndex = cCoord + (x * xStride);\n                sum += inputData[inputIndex];\n            }\n        }\n        \n        let outputIndex = outY * xSize + outX;\n        outputData[outputIndex] = sum / f32(dimLength);\n    }\n"),Min:"\n    ".concat(R,"\n        var min: f32 = 1e12;\n        \n        // Iterate along the dimension we're averaging\n        if (reduceDim == 0u) { // Average along Z\n            let cCoord = outX * xStride + outY * yStride;\n            for (var z: u32 = 0u; z < dimLength; z++) {\n                let inputIndex = cCoord + (z * zStride);\n                let newMin = inputData[inputIndex];\n                if (newMin < min) {\n                    min = newMin;\n                }\n            }\n        } else if (reduceDim == 1u) { // Average along Y\n            let cCoord = outX * xStride + outY * zStride;\n            for (var y: u32 = 0u; y < dimLength; y++) {\n                let inputIndex = cCoord + (y * yStride);\n                let newMin = inputData[inputIndex];\n                if (newMin < min) {\n                    min = newMin;\n                }\n            }\n        } else { // Average along X\n            let cCoord = outX * yStride + outY * zStride;\n            for (var x: u32 = 0u; x < dimLength; x++) {\n                let inputIndex = cCoord + (x * xStride);\n                let newMin = inputData[inputIndex];\n                if (newMin < min) {\n                    min = newMin;\n                }\n            }\n        }\n        \n        let outputIndex = outY * xSize + outX;\n        outputData[outputIndex] = min;\n    }\n"),Max:"\n    ".concat(R,"\n        \n        var max: f32 = -1e12;\n        \n        // Iterate along the dimension we're averaging\n        if (reduceDim == 0u) { // Average along Z\n            let cCoord = outX * xStride + outY * yStride;\n            for (var z: u32 = 0u; z < dimLength; z++) {\n                let inputIndex = cCoord + (z * zStride);\n                let newMax = inputData[inputIndex];\n                if (newMax > max) {\n                    max = newMax;\n                }\n            }\n        } else if (reduceDim == 1u) { // Average along Y\n            let cCoord = outX * xStride + outY * zStride;\n            for (var y: u32 = 0u; y < dimLength; y++) {\n                let inputIndex = cCoord + (y * yStride);\n                let newMax = inputData[inputIndex];\n                if (newMax > max) {\n                    max = newMax;\n                }\n            }\n        } else { // Average along X\n            let cCoord = outX * yStride + outY * zStride;\n            for (var x: u32 = 0u; x < dimLength; x++) {\n                let inputIndex = cCoord + (x * xStride);\n                let newMax = inputData[inputIndex];\n                if (newMax > max) {\n                    max = newMax;\n                }\n            }\n        }\n        \n        let outputIndex = outY * xSize + outX;\n        outputData[outputIndex] = max;\n    }\n"),StDev:"\n    ".concat(R,"\n        var sum: f32 = 0.0;\n        // Iterate along the dimension we're averaging\n        if (reduceDim == 0u) { // Average along Z\n            let cCoord = outX * xStride + outY * yStride;\n            for (var z: u32 = 0u; z < dimLength; z++) {\n                let inputIndex = cCoord + (z * zStride);\n                sum += inputData[inputIndex];\n            }\n        } else if (reduceDim == 1u) { // Average along Y\n            let cCoord = outX * xStride + outY * zStride;\n            for (var y: u32 = 0u; y < dimLength; y++) {\n                let inputIndex = cCoord + (y * yStride);\n                sum += inputData[inputIndex];\n            }\n        } else { // Average along X\n            let cCoord = outX * yStride + outY * zStride;\n            for (var x: u32 = 0u; x < dimLength; x++) {\n                let inputIndex = cCoord + (x * xStride);\n                sum += inputData[inputIndex];\n            }\n        }\n        \n        let mean: f32 = sum / f32(dimLength);\n\n        var squaredDiffSum: f32 = 0.0;\n\n        // Iterate along the dimension again\n        if (reduceDim == 0u) { // Average along Z\n            let cCoord = outX * xStride + outY * yStride;\n            for (var z: u32 = 0u; z < dimLength; z++) {\n                let inputIndex = cCoord + (z * zStride);\n                let diff: f32 = mean - inputData[inputIndex];\n                squaredDiffSum += diff*diff;\n            }\n        } else if (reduceDim == 1u) { // Average along Y\n            let cCoord = outX * xStride + outY * zStride;\n            for (var y: u32 = 0u; y < dimLength; y++) {\n                let inputIndex = cCoord + (y * yStride);\n                let diff: f32 = mean - inputData[inputIndex];\n                squaredDiffSum += diff*diff;\n            }\n        } else { // Average along X\n            let cCoord = outX * yStride + outY * zStride;\n            for (var x: u32 = 0u; x < dimLength; x++) {\n                let inputIndex = cCoord + (x * xStride);\n                let diff: f32 = mean - inputData[inputIndex];\n                squaredDiffSum += diff*diff;\n            }\n        }\n\n        let stDev: f32 = sqrt(squaredDiffSum / f32(dimLength));\n        let outputIndex = outY * xSize + outX;\n        outputData[outputIndex] = stDev;\n    }\n"),CUMSUM:"\n    ".concat(R,"\n        \n        var accum: f32 = 0;\n        \n        // Iterate along the dimension we're averaging\n        if (reduceDim == 0u) { // Average along Z\n            let cCoord = outX * xStride + outY * yStride;\n            for (var z: u32 = 0u; z < dimLength; z++) {\n                let inputIndex = cCoord + (z * zStride);\n                accum += inputData[inputIndex];\n                \n            }\n        } else if (reduceDim == 1u) { // Average along Y\n            let cCoord = outX * xStride + outY * zStride;\n            for (var y: u32 = 0u; y < dimLength; y++) {\n                let inputIndex = cCoord + (y * yStride);\n                accum += inputData[inputIndex];\n            }\n        } else { // Average along X\n            let cCoord = outX * yStride + outY * zStride;\n            for (var x: u32 = 0u; x < dimLength; x++) {\n                let inputIndex = cCoord + (x * xStride);\n                accum += inputData[inputIndex];\n            }\n        }\n        \n        let outputIndex = outY * xSize + outX;\n        outputData[outputIndex] = accum;\n    }\n"),LinearSlope:"\n    ".concat(R,"\n        let meanY: f32 = f32(dimLength)/2;\n        var sum: f32 = 0.0;\n\n\n        // Iterate along the dimension we're averaging\n        if (reduceDim == 0u) { // Average along Z\n            let cCoord = outX * xStride + outY * yStride;\n            for (var z: u32 = 0u; z < dimLength; z++) {\n                let inputIndex = cCoord + (z * zStride);\n                sum += inputData[inputIndex];\n            }\n        } else if (reduceDim == 1u) { // Average along Y\n            let cCoord = outX * xStride + outY * zStride;\n            for (var y: u32 = 0u; y < dimLength; y++) {\n                let inputIndex = cCoord + (y * yStride);\n                sum += inputData[inputIndex];\n            }\n        } else { // Average along X\n            let cCoord = outX * yStride + outY * zStride;\n            for (var x: u32 = 0u; x < dimLength; x++) {\n                let inputIndex = cCoord + (x * xStride);\n                sum += inputData[inputIndex];\n            }\n        }\n        \n        let meanX: f32 = sum / f32(dimLength);\n        var numSum: f32 = 0;\n        var denomSum: f32 = 0;\n\n        if (reduceDim == 0u) { // Average along Z\n            let cCoord = outX * xStride + outY * yStride;\n            for (var z: u32 = 0u; z < dimLength; z++) {\n                let inputIndex = cCoord + (z * zStride);\n                let xi: f32 = inputData[inputIndex];\n                numSum += (xi - meanX)*(f32(z) - meanY);\n                denomSum += (f32(z) - meanY)*(f32(z) - meanY);\n            }\n        } else if (reduceDim == 1u) { // Average along Y\n            let cCoord = outX * xStride + outY * zStride;\n            for (var y: u32 = 0u; y < dimLength; y++) {\n                let inputIndex = cCoord + (y * yStride);\n                let xi: f32 = inputData[inputIndex];\n                numSum += (xi - meanX)*(f32(y) - meanY);\n                denomSum += (f32(y) - meanY)*(f32(y) - meanY);\n            }\n        } else { // Average along X\n            let cCoord = outX * yStride + outY * zStride;\n            for (var x: u32 = 0u; x < dimLength; x++) {\n                let inputIndex = cCoord + (x * xStride);\n                let xi: f32 = inputData[inputIndex];\n                numSum += (xi - meanX)*(f32(x) - meanY);\n                denomSum += (f32(x) - meanY)*(f32(x) - meanY);\n            }\n        }\n        \n        let outputIndex = outY * xSize + outX;\n        outputData[outputIndex] = numSum/denomSum;\n    }\n")},Z={Mean:"\n        ".concat(F,"    \n        var sum: f32 = 0.0;\n        var count: u32 = 0u;\n        for (var kx: i32 = -xy_radius + xyOffset; kx < xy_radius; kx++) {\n            for (var ky: i32 = -xy_radius + xyOffset; ky < xy_radius; ky++) {\n                for (var kz: i32 = -z_radius + zOffset; kz < z_radius; kz++){\n                    let in_coord = vec3<i32>(global_id) + vec3<i32>(kx, ky, kz);\n\n                    if (in_coord.x >= 0 && in_coord.x < i32(xSize) &&\n                        in_coord.y >= 0 && in_coord.y < i32(ySize) &&\n                        in_coord.z >= 0 && in_coord.z < i32(zSize)) { //Ensure the sampled point is within 3D dataspace\n                        let xOffset = kx * i32(xStride);\n                        let yOffset = ky * i32(yStride);\n                        let zOffset = kz * i32(zStride);\n                        let newIdx = i32(globalIdx) + xOffset + yOffset + zOffset;\n\n                        sum += inputData[u32(newIdx)];\n                        count ++;\n                    }\n                }\n            }\n        }\n        \n        outputData[globalIdx] = sum / f32(count);\n    }\n"),Min:"\n    ".concat(F,"  \n        var minVal: f32 = 1e12;\n        var count: u32 = 0u;\n        for (var kx: i32 = -xy_radius + xyOffset; kx < xy_radius; kx++) {\n            for (var ky: i32 = -xy_radius + xyOffset; ky < xy_radius; ky++) {\n                for (var kz: i32 = -z_radius + zOffset; kz < z_radius; kz++){\n                    let in_coord = vec3<i32>(global_id) + vec3<i32>(kx, ky, kz);\n\n                    if (in_coord.x >= 0 && in_coord.x < i32(xSize) &&\n                        in_coord.y >= 0 && in_coord.y < i32(ySize) &&\n                        in_coord.z >= 0 && in_coord.z < i32(zSize)) { //Ensure the sampled point is within 3D dataspace\n                        let xOffset = kx * i32(xStride);\n                        let yOffset = ky * i32(yStride);\n                        let zOffset = kz * i32(zStride);\n                        let newIdx = i32(globalIdx) + xOffset + yOffset + zOffset;\n                        let sampledVal = inputData[u32(newIdx)];\n                        if (sampledVal < minVal){\n                            minVal = sampledVal;\n                        }\n                    }\n                }\n            }\n        }\n        \n        outputData[globalIdx] = minVal;\n    }\n"),Max:"\n    ".concat(F,"  \n\n        var maxVal: f32 = -1e12;\n        var count: u32 = 0u;\n        for (var kx: i32 = -xy_radius + xyOffset; kx < xy_radius; kx++) {\n            for (var ky: i32 = -xy_radius + xyOffset; ky < xy_radius; ky++) {\n                for (var kz: i32 = -z_radius + zOffset; kz < z_radius; kz++){\n                    let in_coord = vec3<i32>(global_id) + vec3<i32>(kx, ky, kz);\n\n                    if (in_coord.x >= 0 && in_coord.x < i32(xSize) &&\n                        in_coord.y >= 0 && in_coord.y < i32(ySize) &&\n                        in_coord.z >= 0 && in_coord.z < i32(zSize)) { //Ensure the sampled point is within 3D dataspace\n                        let xOffset = kx * i32(xStride);\n                        let yOffset = ky * i32(yStride);\n                        let zOffset = kz * i32(zStride);\n                        let newIdx = i32(globalIdx) + xOffset + yOffset + zOffset;\n                        let sampledVal = inputData[u32(newIdx)];\n                        if (sampledVal > maxVal){\n                            maxVal = sampledVal;\n                        }\n                    }\n                }\n            }\n        }\n        \n        outputData[globalIdx] = maxVal;\n    }\n"),StDev:"\n    ".concat(F,"  \n        var sum: f32 = 0.0;\n        var count: u32 = 0u;\n        for (var kx: i32 = -xy_radius + xyOffset; kx < xy_radius; kx++) {\n            for (var ky: i32 = -xy_radius + xyOffset; ky < xy_radius; ky++) {\n                for (var kz: i32 = -z_radius + zOffset; kz < z_radius; kz++){\n                    let in_coord = vec3<i32>(global_id) + vec3<i32>(kx, ky, kz);\n\n                    if (in_coord.x >= 0 && in_coord.x < i32(xSize) &&\n                        in_coord.y >= 0 && in_coord.y < i32(ySize) &&\n                        in_coord.z >= 0 && in_coord.z < i32(zSize)) { //Ensure the sampled point is within 3D dataspace\n                        let xOffset = kx * i32(xStride);\n                        let yOffset = ky * i32(yStride);\n                        let zOffset = kz * i32(zStride);\n                        let newIdx = i32(globalIdx) + xOffset + yOffset + zOffset;\n\n                        sum += inputData[u32(newIdx)];\n                        count ++;\n                    }\n                }\n            }\n        }\n        \n        let mean: f32 = sum / f32(count);\n\n        var squaredDiffSum: f32 = 0.0;\n\n        for (var kx: i32 = -xy_radius + xyOffset; kx < xy_radius; kx++) {\n            for (var ky: i32 = -xy_radius + xyOffset; ky < xy_radius; ky++) {\n                for (var kz: i32 = -z_radius + zOffset; kz < z_radius; kz++){\n                    let in_coord = vec3<i32>(global_id) + vec3<i32>(kx, ky, kz);\n\n                    if (in_coord.x >= 0 && in_coord.x < i32(xSize) &&\n                        in_coord.y >= 0 && in_coord.y < i32(ySize) &&\n                        in_coord.z >= 0 && in_coord.z < i32(zSize)) { //Ensure the sampled point is within 3D dataspace\n                        let xOffset = kx * i32(xStride);\n                        let yOffset = ky * i32(yStride);\n                        let zOffset = kz * i32(zStride);\n                        let newIdx = i32(globalIdx) + xOffset + yOffset + zOffset;\n\n                        let diff: f32 = mean - inputData[u32(newIdx)];\n                        squaredDiffSum += diff*diff;\n                    }\n                }\n            }\n        }\n\n        let stDev: f32 = sqrt(squaredDiffSum / f32(count));\n\n        outputData[globalIdx] = stDev;\n    }\n")},H={Mean:"\n        ".concat(W,"    \n        var sum: f32 = 0;\n        var count: u32 = 0u;\n        for (var kx: i32 = -xy_radius; kx <= xy_radius; kx++) {\n            for (var ky: i32 = -xy_radius; ky <= xy_radius; ky++) {\n                let in_coord = vec2<i32>(i32(global_id.x), i32(global_id.y)) + vec2<i32>(kx, ky);\n                if (in_coord.x >= 0 && in_coord.x < i32(xSize) &&\n                    in_coord.y >= 0 && in_coord.y < i32(ySize)) { //Ensure the sampled point is within 3D dataspace\n                    let xOffset = kx * i32(xStride);\n                    let yOffset = ky * i32(yStride);\n                    let newIdx = i32(globalIdx) + xOffset + yOffset;\n                    let newVal = inputData[u32(newIdx)];\n                    if (newVal != newVal){ //This only evaluates if newVal is NaN\n                        continue;\n                    }\n                    sum += newVal;\n                    count ++;\n                }\n            }\n        }\n        outputData[globalIdx] = sum / f32(count);\n    }\n"),Min:"\n    ".concat(W,"   \n        var minVal: f32 = 1e12;\n        for (var kx: i32 = -xy_radius; kx <= xy_radius; kx++) {\n            for (var ky: i32 = -xy_radius; ky <= xy_radius; ky++) {\n                let in_coord = vec2<i32>(i32(global_id.x), i32(global_id.y)) + vec2<i32>(kx, ky);\n                if (in_coord.x >= 0 && in_coord.x < i32(xSize) &&\n                    in_coord.y >= 0 && in_coord.y < i32(ySize)) { //Ensure the sampled point is within 3D dataspace\n                    let xOffset = kx * i32(xStride);\n                    let yOffset = ky * i32(yStride);\n                    let newIdx = i32(globalIdx) + xOffset + yOffset;\n                    let newVal = inputData[u32(newIdx)];\n                    if (newVal != newVal){ //This only evaluates if newVal is NaN\n                        continue;\n                    }\n                    if (newVal < minVal){\n                        minVal = newVal;\n                    }\n                }\n            }\n        }\n        outputData[globalIdx] = minVal;\n    }\n"),Max:"\n    ".concat(W,"  \n        var maxVal: f32 = -1e12;\n        for (var kx: i32 = -xy_radius; kx <= xy_radius; kx++) {\n            for (var ky: i32 = -xy_radius; ky <= xy_radius; ky++) {\n                let in_coord = vec2<i32>(i32(global_id.x), i32(global_id.y)) + vec2<i32>(kx, ky);\n                if (in_coord.x >= 0 && in_coord.x < i32(xSize) &&\n                    in_coord.y >= 0 && in_coord.y < i32(ySize)) { //Ensure the sampled point is within 3D dataspace\n                    let xOffset = kx * i32(xStride);\n                    let yOffset = ky * i32(yStride);\n                    let newIdx = i32(globalIdx) + xOffset + yOffset;\n                    let newVal = inputData[u32(newIdx)];\n                    if (newVal != newVal){ //This only evaluates if newVal is NaN\n                        continue;\n                    }\n                    if (newVal > maxVal){\n                        maxVal = newVal;\n                    }\n                }\n            }\n        }\n        outputData[globalIdx] = maxVal;\n    }\n"),StDev:"\n     ".concat(W,"  \n        var sum: f32 = 1e12;\n        var count: u32 = 0u;\n        for (var kx: i32 = -xy_radius; kx <= xy_radius; kx++) {\n            for (var ky: i32 = -xy_radius; ky <= xy_radius; ky++) {\n                let in_coord = vec2<i32>(i32(global_id.x), i32(global_id.y)) + vec2<i32>(kx, ky);\n                if (in_coord.x >= 0 && in_coord.x < i32(xSize) &&\n                    in_coord.y >= 0 && in_coord.y < i32(ySize)) { //Ensure the sampled point is within 3D dataspace\n                    let xOffset = kx * i32(xStride);\n                    let yOffset = ky * i32(yStride);\n                    let newIdx = i32(globalIdx) + xOffset + yOffset;\n                    let newVal = inputData[u32(newIdx)];\n                    if (newVal != newVal){ //This only evaluates if newVal is NaN\n                        continue;\n                    }\n                    sum += newVal;\n                    count ++;\n                }\n            }\n        }\n        \n        let mean: f32 = sum / f32(count);\n\n        var squaredDiffSum: f32 = 0.0;\n\n        for (var kx: i32 = -xy_radius; kx <= xy_radius; kx++) {\n            for (var ky: i32 = -xy_radius; ky <= xy_radius; ky++) {\n                let in_coord = vec2<i32>(i32(global_id.x), i32(global_id.y)) + vec2<i32>(kx, ky);\n                if (in_coord.x >= 0 && in_coord.x < i32(xSize) &&\n                    in_coord.y >= 0 && in_coord.y < i32(ySize)) { //Ensure the sampled point is within 3D dataspace\n                    let xOffset = kx * i32(xStride);\n                    let yOffset = ky * i32(yStride);\n                    let newIdx = i32(globalIdx) + xOffset + yOffset;\n                    let newVal = inputData[u32(newIdx)];\n                    if (newVal != newVal){ //This only evaluates if newVal is NaN\n                        continue;\n                    }\n                    let diff: f32 = mean - newVal;\n                    squaredDiffSum += diff*diff;\n                }\n            }\n        }\n        let stDev: f32 = sqrt(squaredDiffSum / f32(count));\n\n        outputData[globalIdx] = stDev;\n    }\n")},Q={Correlation2D:"\n    struct Params {\n        zStride: u32,\n        yStride: u32,\n        xStride: u32,\n        xSize: u32,\n        ySize: u32,\n        reduceDim: u32,\n        dimLength: u32,\n    };\n    @group(0) @binding(0) var<storage, read> firstData: array<f32>;\n    @group(0) @binding(1) var<storage, read> secondData: array<f32>;\n    @group(0) @binding(2) var<storage, read_write> outputData: array<f32>;\n    @group(0) @binding(3) var<uniform> params: Params;\n\n    @compute @workgroup_size(16, 16, 1)\n    fn main(@builtin(global_invocation_id) global_id: vec3<u32>) {\n        let zStride = params.zStride;\n        let yStride = params.yStride;\n        let xStride = params.xStride;\n        let xSize = params.xSize;\n        let ySize = params.ySize;\n        let reduceDim = params.reduceDim;\n        let dimLength = params.dimLength;\n                        \n        let outX = global_id.y;\n        let outY = global_id.x;\n        \n        if (outX >= xSize || outY >= ySize) {\n            return;\n        }\n\n        var xSum: f32 = 0.0;\n        var xxSum: f32 = 0.0;\n        var ySum: f32 = 0.0;\n        var yySum: f32 = 0.0;\n        var xySum: f32 = 0.0;\n        // Iterate along the dimension we're averaging\n        if (reduceDim == 0u) { // Average along Z\n            let cCoord = outX * xStride + outY * yStride;\n            for (var z: u32 = 0u; z < dimLength; z++) {\n                let inputIndex = cCoord + (z * zStride);\n                let xI = firstData[inputIndex];\n                let yI = secondData[inputIndex];\n                xSum += xI;\n                xxSum += xI * xI;\n                ySum += yI;\n                yySum += yI * yI;\n                xySum += xI * yI;\n            }\n        } else if (reduceDim == 1u) { // Average along Y\n            let cCoord = outX * xStride + outY * zStride;\n            for (var y: u32 = 0u; y < dimLength; y++) {\n                let inputIndex = cCoord + (y * yStride);\n                let xI = firstData[inputIndex];\n                let yI = secondData[inputIndex];\n                xSum += xI;\n                xxSum += xI * xI;\n                ySum += yI;\n                yySum += yI * yI;\n                xySum += xI * yI;\n            }\n        } else { // Average along X\n            let cCoord = outX * yStride + outY * zStride;\n            for (var x: u32 = 0u; x < dimLength; x++) {\n                let inputIndex = cCoord + (x * xStride);\n                let xI = firstData[inputIndex];\n                let yI = secondData[inputIndex];\n                xSum += xI;\n                xxSum += xI * xI;\n                ySum += yI;\n                yySum += yI * yI;\n                xySum += xI * yI;\n            }\n        }\n\n        let N: f32 = f32(dimLength);\n        let meanX = xSum / N;\n        let meanY = ySum / N;\n        let varX = (xxSum / N) - (meanX * meanX);\n        let varY = (yySum / N) - (meanY * meanY);\n        let covXY = (xySum / N) - (meanX * meanY);\n        let sigmaX = sqrt(max(0.0, varX));\n        let sigmaY = sqrt(max(0.0, varY));\n        let epsilon = 1e-6;\n        let denominator = sigmaX * sigmaY + epsilon;\n        let correlation = covXY / denominator;\n\n        let outputIndex = outY * xSize + outX;\n        outputData[outputIndex] = correlation;\n    }\n",Correlation3D:"\n    struct Params {\n        xStride: u32,\n        yStride: u32,\n        zStride: u32,\n        xSize: u32,\n        ySize: u32,\n        zSize: u32,\n        workGroups: vec3<u32>,\n        kernelSize: u32,\n        kernelDepth: u32\n    };\n    @group(0) @binding(0) var<storage, read> firstData: array<f32>;\n    @group(0) @binding(1) var<storage, read> secondData: array<f32>;\n    @group(0) @binding(2) var<storage, read_write> outputData: array<f32>;\n    @group(0) @binding(3) var<uniform> params: Params;\n\n    @compute @workgroup_size(4, 4, 4)\n    fn main(@builtin(global_invocation_id) global_id: vec3<u32>) {\n        let zStride = params.zStride;\n        let yStride = params.yStride;\n        let xStride = params.xStride; \n        let xSize = params.xSize;\n        let ySize = params.ySize;\n        let zSize = params.zSize; \n        let workGroups = params.workGroups;\n        let kernelSize = params.kernelSize;\n        let kernelDepth = params.kernelDepth;\n\n        let outX = global_id.x; \n        let outY = global_id.y;\n        let outZ = global_id.z; \n\n        if (outX >= xSize || outY >= ySize || outZ >= zSize) {\n            return;\n        }\n\n        let total_threads_per_slice = workGroups.x * workGroups.y * 16;\n        let globalIdx = global_id.z * total_threads_per_slice + \n                        global_id.y * (workGroups.x * 4) + \n                        global_id.x;\n\n        let xy_radius: i32 = i32(kernelSize/2u);\n        let z_radius: i32 = i32(kernelDepth/2u);\n\n        var xyOffset: i32 = 0; //These offsets are for kernelsizes of 1. I didn't wanna rewrite everything else for that case\n        var zOffset: i32 = 0;\n        if (xy_radius == 0){\n            xyOffset = -1;\n        }\n        if (z_radius == 0){\n            zOffset = -1;\n        }\n\n        var xSum: f32 = 0.0;\n        var xxSum: f32 = 0.0;\n        var ySum: f32 = 0.0;\n        var yySum: f32 = 0.0;\n        var xySum: f32 = 0.0;\n\n        var count: u32 = 0u;\n        for (var kx: i32 = -xy_radius + xyOffset; kx < xy_radius; kx++) {\n            for (var ky: i32 = -xy_radius + xyOffset; ky < xy_radius; ky++) {\n                for (var kz: i32 = -z_radius + zOffset; kz < z_radius; kz++){\n                    let in_coord = vec3<i32>(global_id) + vec3<i32>(kx, ky, kz);\n                    if (in_coord.x >= 0 && in_coord.x < i32(xSize) &&\n                        in_coord.y >= 0 && in_coord.y < i32(ySize) &&\n                        in_coord.z >= 0 && in_coord.z < i32(zSize)) { //Ensure the sampled point is within 3D dataspace\n                        let xOffset = kx * i32(xStride);\n                        let yOffset = ky * i32(yStride);\n                        let zOffset = kz * i32(zStride);\n                        let newIdx = i32(globalIdx) + xOffset + yOffset + zOffset;\n\n                        let xI = firstData[newIdx];\n                        let yI = secondData[newIdx];\n                        xSum += xI;\n                        xxSum += xI * xI;\n                        ySum += yI;\n                        yySum += yI * yI;\n                        xySum += xI * yI;\n                        count ++;\n                    }\n                }\n            }\n        }\n\n        let N: f32 = f32(count);\n        let meanX = xSum / N;\n        let meanY = ySum / N;\n        let varX = (xxSum / N) - (meanX * meanX);\n        let varY = (yySum / N) - (meanY * meanY);\n        let covXY = (xySum / N) - (meanX * meanY);\n        let sigmaX = sqrt(max(0.0, varX));\n        let sigmaY = sqrt(max(0.0, varY));\n        let epsilon = 1e-6;\n        let denominator = sigmaX * sigmaY + epsilon;\n        let correlation = covXY / denominator;\n\n        outputData[globalIdx] = correlation;\n    }\n",TwoVarLinearSlope2D:"\n    struct Params {\n    zStride: u32,\n    yStride: u32,\n    xStride: u32,\n    xSize: u32,\n    ySize: u32,\n    reduceDim: u32,\n    dimLength: u32,\n    };\n    @group(0) @binding(0) var<storage, read> firstData: array<f32>;\n    @group(0) @binding(1) var<storage, read> secondData: array<f32>;\n    @group(0) @binding(2) var<storage, read_write> outputData: array<f32>;\n    @group(0) @binding(3) var<uniform> params: Params;\n\n    @compute @workgroup_size(16, 16, 1)\n    fn main(@builtin(global_invocation_id) global_id: vec3<u32>) {\n        let zStride = params.zStride;\n        let yStride = params.yStride;\n        let xStride = params.xStride;\n        let xSize = params.xSize;\n        let ySize = params.ySize;\n        let reduceDim = params.reduceDim;\n        let dimLength = params.dimLength;\n                        \n        let outX = global_id.y;\n        let outY = global_id.x;\n        \n        if (outX >= xSize || outY >= ySize) {\n            return;\n        }\n\n        var ySum: f32 = 0;\n        var xSum: f32 = 0.0;\n\n        // Iterate along the dimension we're averaging\n        if (reduceDim == 0u) { \n            let cCoord = outX * xStride + outY * yStride;\n            for (var z: u32 = 0u; z < dimLength; z++) {\n                let inputIndex = cCoord + (z * zStride);\n                xSum += firstData[inputIndex];\n                ySum += secondData[inputIndex];\n            }\n        } else if (reduceDim == 1u) { \n            let cCoord = outX * xStride + outY * zStride;\n            for (var y: u32 = 0u; y < dimLength; y++) {\n                let inputIndex = cCoord + (y * yStride);\n                xSum += firstData[inputIndex];\n                ySum += secondData[inputIndex];\n            }\n        } else { \n            let cCoord = outX * yStride + outY * zStride;\n            for (var x: u32 = 0u; x < dimLength; x++) {\n                let inputIndex = cCoord + (x * xStride);\n                xSum += firstData[inputIndex];\n                ySum += secondData[inputIndex];\n            }\n        }\n        \n        let xMean: f32 = xSum / f32(dimLength);\n        let yMean: f32 = ySum / f32(dimLength);\n        var numSum: f32 = 0;\n        var denomSum: f32 = 0;\n\n        if (reduceDim == 0u) { // Average along Z\n            let cCoord = outX * xStride + outY * yStride;\n            for (var z: u32 = 0u; z < dimLength; z++) {\n                let inputIndex = cCoord + (z * zStride);\n                let xi: f32 = firstData[inputIndex];\n                let yi: f32 = secondData[inputIndex];\n                numSum += (xi - xMean)*(f32(yi) - yMean);\n                denomSum += (f32(yi) - yMean)*(f32(yi) - yMean);\n            }\n        } else if (reduceDim == 1u) { // Average along Y\n            let cCoord = outX * xStride + outY * zStride;\n            for (var y: u32 = 0u; y < dimLength; y++) {\n                let inputIndex = cCoord + (y * yStride);\n                let xi: f32 = firstData[inputIndex];\n                let yi: f32 = secondData[inputIndex];\n                numSum += (xi - xMean)*(f32(yi) - yMean);\n                denomSum += (f32(yi) - yMean)*(f32(yi) - yMean);\n            }\n        } else { // Average along X\n            let cCoord = outX * yStride + outY * zStride;\n            for (var x: u32 = 0u; x < dimLength; x++) {\n                let inputIndex = cCoord + (x * xStride);\n                let xi: f32 = firstData[inputIndex];\n                let yi: f32 = secondData[inputIndex];\n                numSum += (xi - xMean)*(f32(yi) - yMean);\n                denomSum += (f32(yi) - yMean)*(f32(yi) - yMean);\n            }\n        }\n        \n        let outputIndex = outY * xSize + outX;\n        outputData[outputIndex] = numSum/denomSum;\n    }\n",TwoVarLinearSlope3D:"\n    struct Params {\n        xStride: u32,\n        yStride: u32,\n        zStride: u32,\n        xSize: u32,\n        ySize: u32,\n        zSize: u32,\n        workGroups: vec3<u32>,\n        kernelSize: u32,\n        kernelDepth: u32\n    };\n    @group(0) @binding(0) var<storage, read> firstData: array<f32>;\n    @group(0) @binding(1) var<storage, read> secondData: array<f32>;\n    @group(0) @binding(2) var<storage, read_write> outputData: array<f32>;\n    @group(0) @binding(3) var<uniform> params: Params;\n\n    @compute @workgroup_size(4, 4, 4)\n    fn main(@builtin(global_invocation_id) global_id: vec3<u32>) {\n        let zStride = params.zStride;\n        let yStride = params.yStride;\n        let xStride = params.xStride; \n        let xSize = params.xSize;\n        let ySize = params.ySize;\n        let zSize = params.zSize; \n        let workGroups = params.workGroups;\n        let kernelSize = params.kernelSize;\n        let kernelDepth = params.kernelDepth;\n\n        let outX = global_id.x; \n        let outY = global_id.y;\n        let outZ = global_id.z; \n\n        if (outX >= xSize || outY >= ySize || outZ >= zSize) {\n            return;\n        }\n\n        let total_threads_per_slice = workGroups.x * workGroups.y * 16;\n        let globalIdx = global_id.z * total_threads_per_slice + \n                        global_id.y * (workGroups.x * 4) + \n                        global_id.x;\n\n        let xy_radius: i32 = i32(kernelSize/2u);\n        let z_radius: i32 = i32(kernelDepth/2u);\n\n        var xyOffset: i32 = 0; //These offsets are for kernelsizes of 1. I didn't wanna rewrite everything else for that case\n        var zOffset: i32 = 0;\n        if (xy_radius == 0){\n            xyOffset = -1;\n        }\n        if (z_radius == 0){\n            zOffset = -1;\n        }\n\n        var xSum: f32 = 0.0;\n        var ySum: f32 = 0.0;\n\n        var count: u32 = 0u;\n        for (var kx: i32 = -xy_radius + xyOffset; kx < xy_radius; kx++) {\n            for (var ky: i32 = -xy_radius + xyOffset; ky < xy_radius; ky++) {\n                for (var kz: i32 = -z_radius + zOffset; kz < z_radius; kz++){\n                    let in_coord = vec3<i32>(global_id) + vec3<i32>(kx, ky, kz);\n                    if (in_coord.x >= 0 && in_coord.x < i32(xSize) &&\n                        in_coord.y >= 0 && in_coord.y < i32(ySize) &&\n                        in_coord.z >= 0 && in_coord.z < i32(zSize)) { \n                        let xOffset = kx * i32(xStride);\n                        let yOffset = ky * i32(yStride);\n                        let zOffset = kz * i32(zStride);\n                        let newIdx = i32(globalIdx) + xOffset + yOffset + zOffset;\n                        let xI = firstData[newIdx];\n                        let yI = secondData[newIdx];\n                        xSum += xI;    \n                        ySum += yI;\n                        count ++;\n                    }\n                }\n            }\n        }\n\n\n        let N: f32 = f32(count);\n        let meanX = xSum / N;\n        let meanY = ySum / N;\n        var numSum: f32 = 0;\n        var denomSum: f32 = 0;\n        \n        for (var kx: i32 = -xy_radius + xyOffset; kx < xy_radius; kx++) {\n            for (var ky: i32 = -xy_radius + xyOffset; ky < xy_radius; ky++) {\n                for (var kz: i32 = -z_radius + zOffset; kz < z_radius; kz++){\n                    let in_coord = vec3<i32>(global_id) + vec3<i32>(kx, ky, kz);\n                    if (in_coord.x >= 0 && in_coord.x < i32(xSize) &&\n                        in_coord.y >= 0 && in_coord.y < i32(ySize) &&\n                        in_coord.z >= 0 && in_coord.z < i32(zSize)) { \n                        let xOffset = kx * i32(xStride);\n                        let yOffset = ky * i32(yStride);\n                        let zOffset = kz * i32(zStride);\n                        let newIdx = i32(globalIdx) + xOffset + yOffset + zOffset;\n                        let xI = firstData[newIdx];\n                        let yI = secondData[newIdx];\n                        numSum += (xI - meanX)*(f32(yI) - meanY);\n                        denomSum += (f32(yI) - meanY)*(f32(yI) - meanY);\n                    }\n                }\n            }\n        }\n        outputData[globalIdx] = numSum/denomSum;;\n    }\n",Covariance2D:"\n    struct Params {\n    zStride: u32,\n    yStride: u32,\n    xStride: u32,\n    xSize: u32,\n    ySize: u32,\n    reduceDim: u32,\n    dimLength: u32,\n    };\n    @group(0) @binding(0) var<storage, read> firstData: array<f32>;\n    @group(0) @binding(1) var<storage, read> secondData: array<f32>;\n    @group(0) @binding(2) var<storage, read_write> outputData: array<f32>;\n    @group(0) @binding(3) var<uniform> params: Params;\n\n    @compute @workgroup_size(16, 16, 1)\n    fn main(@builtin(global_invocation_id) global_id: vec3<u32>) {\n        let zStride = params.zStride;\n        let yStride = params.yStride;\n        let xStride = params.xStride;\n        let xSize = params.xSize;\n        let ySize = params.ySize;\n        let reduceDim = params.reduceDim;\n        let dimLength = params.dimLength;\n                        \n        let outX = global_id.y;\n        let outY = global_id.x;\n        \n        if (outX >= xSize || outY >= ySize) {\n            return;\n        }\n        var ySum: f32 = 0;\n        var xSum: f32 = 0.0;\n        var numSum: f32 = 0;\n\n       // Calculate base coordinate and stride for the dimension we're iterating over\n        let baseCoord: u32;\n        let iterStride: u32;\n\n        if (reduceDim == 0u) {\n            baseCoord = outX * xStride + outY * yStride;\n            iterStride = zStride;\n        } else if (reduceDim == 1u) {\n            baseCoord = outX * xStride + outY * zStride;\n            iterStride = yStride;\n        } else {\n            baseCoord = outX * yStride + outY * zStride;\n            iterStride = xStride;\n        }\n\n        // Single pass: calculate sums, means, and covariance\n        for (var i: u32 = 0u; i < dimLength; i++) {\n            let inputIndex = baseCoord + (i * iterStride);\n            let xi: f32 = firstData[inputIndex];\n            let yi: f32 = secondData[inputIndex];\n            xSum += xi;\n            ySum += yi;\n        }\n\n        let xMean: f32 = xSum / f32(dimLength);\n        let yMean: f32 = ySum / f32(dimLength);\n\n        // Second pass for covariance calculation\n        for (var i: u32 = 0u; i < dimLength; i++) {\n            let inputIndex = baseCoord + (i * iterStride);\n            let xi: f32 = firstData[inputIndex];\n            let yi: f32 = secondData[inputIndex];\n            numSum += (xi - xMean) * (yi - yMean);\n        }\n\n        let outputIndex = outY * xSize + outX;\n        outputData[outputIndex] = numSum / (f32(dimLength) - 1);\n    }\n",Covariance3D:"\n    struct Params {\n        xStride: u32,\n        yStride: u32,\n        zStride: u32,\n        xSize: u32,\n        ySize: u32,\n        zSize: u32,\n        workGroups: vec3<u32>,\n        kernelSize: u32,\n        kernelDepth: u32\n    };\n    @group(0) @binding(0) var<storage, read> firstData: array<f32>;\n    @group(0) @binding(1) var<storage, read> secondData: array<f32>;\n    @group(0) @binding(2) var<storage, read_write> outputData: array<f32>;\n    @group(0) @binding(3) var<uniform> params: Params;\n\n    @compute @workgroup_size(4, 4, 4)\n    fn main(@builtin(global_invocation_id) global_id: vec3<u32>) {\n        let zStride = params.zStride;\n        let yStride = params.yStride;\n        let xStride = params.xStride; \n        let xSize = params.xSize;\n        let ySize = params.ySize;\n        let zSize = params.zSize; \n        let workGroups = params.workGroups;\n        let kernelSize = params.kernelSize;\n        let kernelDepth = params.kernelDepth;\n\n        let outX = global_id.x; \n        let outY = global_id.y;\n        let outZ = global_id.z; \n\n        if (outX >= xSize || outY >= ySize || outZ >= zSize) {\n            return;\n        }\n\n        let total_threads_per_slice = workGroups.x * workGroups.y * 16;\n        let globalIdx = global_id.z * total_threads_per_slice + \n                        global_id.y * (workGroups.x * 4) + \n                        global_id.x;\n\n        let xy_radius: i32 = i32(kernelSize/2u);\n        let z_radius: i32 = i32(kernelDepth/2u);\n\n        var xyOffset: i32 = 0; //These offsets are for kernelsizes of 1. I didn't wanna rewrite everything else for that case\n        var zOffset: i32 = 0;\n        if (xy_radius == 0){\n            xyOffset = -1;\n        }\n        if (z_radius == 0){\n            zOffset = -1;\n        }\n\n        var xSum: f32 = 0.0;\n        var ySum: f32 = 0.0;\n        var numSum: f32 = 0.0;\n\n        var count: u32 = 0u;\n        for (var kx: i32 = -xy_radius + xyOffset; kx < xy_radius; kx++) {\n            for (var ky: i32 = -xy_radius + xyOffset; ky < xy_radius; ky++) {\n                for (var kz: i32 = -z_radius + zOffset; kz < z_radius; kz++){\n                    let in_coord = vec3<i32>(global_id) + vec3<i32>(kx, ky, kz);\n                    if (in_coord.x >= 0 && in_coord.x < i32(xSize) &&\n                        in_coord.y >= 0 && in_coord.y < i32(ySize) &&\n                        in_coord.z >= 0 && in_coord.z < i32(zSize)) { \n                        let xOffset = kx * i32(xStride);\n                        let yOffset = ky * i32(yStride);\n                        let zOffset = kz * i32(zStride);\n                        let newIdx = i32(globalIdx) + xOffset + yOffset + zOffset;\n                        let xI = firstData[newIdx];\n                        let yI = secondData[newIdx];\n                        xSum += xI;    \n                        ySum += yI;\n                        count ++;\n                    }\n                }\n            }\n        }\n\n        let N: f32 = f32(count);\n        let meanX = xSum / N;\n        let meanY = ySum / N;\n        \n        for (var kx: i32 = -xy_radius + xyOffset; kx < xy_radius; kx++) {\n            for (var ky: i32 = -xy_radius + xyOffset; ky < xy_radius; ky++) {\n                for (var kz: i32 = -z_radius + zOffset; kz < z_radius; kz++){\n                    let in_coord = vec3<i32>(global_id) + vec3<i32>(kx, ky, kz);\n                    if (in_coord.x >= 0 && in_coord.x < i32(xSize) &&\n                        in_coord.y >= 0 && in_coord.y < i32(ySize) &&\n                        in_coord.z >= 0 && in_coord.z < i32(zSize)) { \n                        let xOffset = kx * i32(xStride);\n                        let yOffset = ky * i32(yStride);\n                        let zOffset = kz * i32(zStride);\n                        let newIdx = i32(globalIdx) + xOffset + yOffset + zOffset;\n                        let xI = firstData[newIdx];\n                        let yI = secondData[newIdx];\n                        numSum += (xI - meanX) * (yI - meanY);\n                        count ++;\n                    }\n                }\n            }\n        }\n        outputData[globalIdx] = numSum/(N-1);;\n    }\n"};async function $(e,n,t,r){var i;let a=await (null==(i=navigator.gpu)?void 0:i.requestAdapter()),o=await (null==a?void 0:a.requestDevice());if(!o)return void Error("need a browser that supports WebGPU");let{strides:l,shape:s}=n,[u,d,c]=l,f=s.filter((e,n)=>n!=t),m=s[t],x=f[0]*f[1],p=f.map(e=>Math.ceil(e/16)),h=q[r],g=o.createShaderModule({label:"reduction compute module",code:h}),y=o.createComputePipeline({label:"reduction compute pipeline",layout:"auto",compute:{module:g}}),S=(0,X.Wu)(h),v=(0,X.FE)(S.uniforms.params);v.set({zStride:u,yStride:d,xStride:c,xSize:f[1],ySize:f[0],reduceDim:t,dimLength:m});let z=o.createBuffer({label:"Input Buffer",size:e.byteLength,usage:GPUBufferUsage.STORAGE|GPUBufferUsage.COPY_DST}),b=o.createBuffer({label:"Output Buffer",size:4*x,usage:GPUBufferUsage.STORAGE|GPUBufferUsage.COPY_SRC}),w=o.createBuffer({size:v.arrayBuffer.byteLength,usage:GPUBufferUsage.UNIFORM|GPUBufferUsage.COPY_DST}),_=o.createBuffer({label:"Output Buffer",size:4*x,usage:GPUBufferUsage.COPY_DST|GPUBufferUsage.MAP_READ});o.queue.writeBuffer(z,0,e),o.queue.writeBuffer(w,0,v.arrayBuffer);let k=o.createBindGroup({layout:y.getBindGroupLayout(0),entries:[{binding:0,resource:{buffer:z}},{binding:1,resource:{buffer:b}},{binding:2,resource:{buffer:w}}]}),D=o.createCommandEncoder({label:"reduction encoder"}),C=D.beginComputePass({label:"reduction compute pass"});C.setPipeline(y),C.setBindGroup(0,k),C.dispatchWorkgroups(p[0],p[1]),C.end(),D.copyBufferToBuffer(b,0,_,0,4*x),o.queue.submit([D.finish()]),await _.mapAsync(GPUMapMode.READ);let P=new Float32Array(_.getMappedRange().slice());return _.unmap(),P}async function J(e,n,t,r){var i;let a=await (null==(i=navigator.gpu)?void 0:i.requestAdapter()),o=await (null==a?void 0:a.requestDevice({requiredLimits:{maxBufferSize:0x7a0a1efc,maxStorageBufferBindingSize:0x7a0a1efc}}));if(!o)return void Error("need a browser that supports WebGPU");let{kernelDepth:l,kernelSize:s}=r,{strides:u,shape:d}=n,c=d[0]*d[1]*d[2],[f,m,x]=u,p=d.map(e=>Math.ceil(e/4)),h=Z[t],g=o.createShaderModule({label:"convolution compute module",code:h}),y=o.createComputePipeline({label:"convolution compute pipeline",layout:"auto",compute:{module:g}}),S=(0,X.Wu)(h),v=(0,X.FE)(S.uniforms.params);v.set({xStride:x,yStride:m,zStride:f,xSize:d[2],ySize:d[1],zSize:d[0],workGroups:[p[2],p[1],p[0]],kernelDepth:l,kernelSize:s});let z=o.createBuffer({label:"Input Buffer",size:e.byteLength,usage:GPUBufferUsage.STORAGE|GPUBufferUsage.COPY_DST}),b=o.createBuffer({label:"Output Buffer",size:4*c,usage:GPUBufferUsage.STORAGE|GPUBufferUsage.COPY_SRC}),w=o.createBuffer({label:"Uniform Buffer",size:v.arrayBuffer.byteLength,usage:GPUBufferUsage.UNIFORM|GPUBufferUsage.COPY_DST}),_=o.createBuffer({label:"Read Buffer",size:4*c,usage:GPUBufferUsage.COPY_DST|GPUBufferUsage.MAP_READ});o.queue.writeBuffer(z,0,e),o.queue.writeBuffer(w,0,v.arrayBuffer);let k=o.createBindGroup({layout:y.getBindGroupLayout(0),entries:[{binding:0,resource:{buffer:z}},{binding:1,resource:{buffer:b}},{binding:2,resource:{buffer:w}}]}),D=o.createCommandEncoder({label:"convolution encoder"}),C=D.beginComputePass({label:"convolution compute pass"});C.setPipeline(y),C.setBindGroup(0,k),C.dispatchWorkgroups(p[2],p[1],p[0]),C.end(),D.copyBufferToBuffer(b,0,_,0,4*c),o.queue.submit([D.finish()]),await _.mapAsync(GPUMapMode.READ);let P=new Float32Array(_.getMappedRange().slice());return _.unmap(),P}async function K(e,n,t,r,i){var a;let o=await (null==(a=navigator.gpu)?void 0:a.requestAdapter()),l=await (null==o?void 0:o.requestDevice({requiredLimits:{maxBufferSize:0x7a0a1efc,maxStorageBufferBindingSize:0x7a0a1efc}}));if(!l)return void Error("need a browser that supports WebGPU");let{strides:s,shape:u}=t,[d,c,f]=s,m=u.filter((e,n)=>n!=r),x=u[r],p=m[0]*m[1],h=m.map(e=>Math.ceil(e/16)),g=Q[i];console.log(i);let y=l.createShaderModule({label:"Multivariate2D compute module",code:g}),S=l.createComputePipeline({label:"Multivariate2D compute pipeline",layout:"auto",compute:{module:y}}),v=(0,X.Wu)(g),z=(0,X.FE)(v.uniforms.params);z.set({zStride:d,yStride:c,xStride:f,xSize:m[1],ySize:m[0],reduceDim:r,dimLength:x});let b=l.createBuffer({label:"First Input Buffer",size:e.byteLength,usage:GPUBufferUsage.STORAGE|GPUBufferUsage.COPY_DST}),w=l.createBuffer({label:"Second Input Buffer",size:n.byteLength,usage:GPUBufferUsage.STORAGE|GPUBufferUsage.COPY_DST}),_=l.createBuffer({label:"Output Buffer",size:4*p,usage:GPUBufferUsage.STORAGE|GPUBufferUsage.COPY_SRC}),k=l.createBuffer({size:z.arrayBuffer.byteLength,usage:GPUBufferUsage.UNIFORM|GPUBufferUsage.COPY_DST}),D=l.createBuffer({label:"Output Buffer",size:4*p,usage:GPUBufferUsage.COPY_DST|GPUBufferUsage.MAP_READ});l.queue.writeBuffer(b,0,e),l.queue.writeBuffer(w,0,n),l.queue.writeBuffer(k,0,z.arrayBuffer);let C=l.createBindGroup({layout:S.getBindGroupLayout(0),entries:[{binding:0,resource:{buffer:b}},{binding:1,resource:{buffer:w}},{binding:2,resource:{buffer:_}},{binding:3,resource:{buffer:k}}]}),P=l.createCommandEncoder({label:"Multivariate2D encoder"}),I=P.beginComputePass({label:"Multivariate2D compute pass"});I.setPipeline(S),I.setBindGroup(0,C),I.dispatchWorkgroups(h[0],h[1]),I.end(),P.copyBufferToBuffer(_,0,D,0,4*p),l.queue.submit([P.finish()]),await D.mapAsync(GPUMapMode.READ);let M=new Float32Array(D.getMappedRange().slice());return D.unmap(),M}async function ee(e,n,t,r,i){var a;let o=await (null==(a=navigator.gpu)?void 0:a.requestAdapter()),l=await (null==o?void 0:o.requestDevice({requiredLimits:{maxBufferSize:0x7a0a1efc,maxStorageBufferBindingSize:0x7a0a1efc}}));if(!l)return void Error("need a browser that supports WebGPU");let{kernelDepth:s,kernelSize:u}=r,{strides:d,shape:c}=t,[f,m,x]=d,p=c[0]*c[1]*c[2],h=c.map(e=>Math.ceil(e/4)),g=Q[i],y=l.createShaderModule({label:"Multivariate3D compute module",code:g}),S=l.createComputePipeline({label:"Multivariate3D compute pipeline",layout:"auto",compute:{module:y}}),v=(0,X.Wu)(g),z=(0,X.FE)(v.uniforms.params);z.set({xStride:x,yStride:m,zStride:f,xSize:c[2],ySize:c[1],zSize:c[0],workGroups:[h[2],h[1],h[0]],kernelDepth:s,kernelSize:u});let b=l.createBuffer({label:"First Input Buffer",size:e.byteLength,usage:GPUBufferUsage.STORAGE|GPUBufferUsage.COPY_DST}),w=l.createBuffer({label:"Second Input Buffer",size:n.byteLength,usage:GPUBufferUsage.STORAGE|GPUBufferUsage.COPY_DST}),_=l.createBuffer({label:"Output Buffer",size:4*p,usage:GPUBufferUsage.STORAGE|GPUBufferUsage.COPY_SRC}),k=l.createBuffer({size:z.arrayBuffer.byteLength,usage:GPUBufferUsage.UNIFORM|GPUBufferUsage.COPY_DST}),D=l.createBuffer({label:"Output Buffer",size:4*p,usage:GPUBufferUsage.COPY_DST|GPUBufferUsage.MAP_READ});l.queue.writeBuffer(b,0,e),l.queue.writeBuffer(w,0,n),l.queue.writeBuffer(k,0,z.arrayBuffer);let C=l.createBindGroup({layout:S.getBindGroupLayout(0),entries:[{binding:0,resource:{buffer:b}},{binding:1,resource:{buffer:w}},{binding:2,resource:{buffer:_}},{binding:3,resource:{buffer:k}}]}),P=l.createCommandEncoder({label:"Multivariate3D encoder"}),I=P.beginComputePass({label:"Multivariate3D compute pass"});I.setPipeline(S),I.setBindGroup(0,C),I.dispatchWorkgroups(h[2],h[1],h[0]),I.end(),P.copyBufferToBuffer(_,0,D,0,4*p),l.queue.submit([P.finish()]),await D.mapAsync(GPUMapMode.READ);let M=new Float32Array(D.getMappedRange().slice());return D.unmap(),M}async function en(e,n,t,r){var i;let a=await (null==(i=navigator.gpu)?void 0:i.requestAdapter()),o=await (null==a?void 0:a.requestDevice({requiredLimits:{maxBufferSize:0x7a0a1efc,maxStorageBufferBindingSize:0x7a0a1efc}}));if(!o)return void Error("need a browser that supports WebGPU");let{strides:l,shape:s}=n,u=s[0]*s[1]*s[2],[d,c,f]=l,m=s.map(e=>Math.ceil(e/4)),x="\n    struct Params {\n        xStride: u32,\n        yStride: u32,\n        zStride: u32,\n        xSize: u32,\n        ySize: u32,\n        zSize: u32,\n        reduceDim: u32,\n        reverse: u32,\n        workGroups: vec3<u32>,\n    };\n    @group(0) @binding(0) var<storage, read> inputData: array<f32>;\n    @group(0) @binding(1) var<storage, read_write> outputData: array<f32>;\n    @group(0) @binding(2) var<uniform> params: Params;\n\n    @compute @workgroup_size(4, 4, 4)\n    fn main(@builtin(global_invocation_id) global_id: vec3<u32>) {\n        let zStride = params.zStride;\n        let yStride = params.yStride;\n        let xStride = params.xStride; \n        let xSize = params.xSize;\n        let ySize = params.ySize;\n        let zSize = params.zSize; \n        let reverse = params.reverse;\n        let workGroups = params.workGroups;\n        let reduceDim = params.reduceDim;\n\n        let outX = global_id.x; \n        let outY = global_id.y;\n        let outZ = global_id.z; \n\n        if (outX >= xSize || outY >= ySize || outZ >= zSize) {\n            return;\n        }\n        let totalSize: u32 = xSize * ySize * zSize;\n        var baseIdx = outZ * zStride + outY * yStride + outX * xStride;\n        var accum: f32 = 0;\n\n        // Iterate along the dimension we're averaging\n        if (reduceDim == 0u) { // CUMSUM along Z\n            if (reverse == u32(1)){\n                baseIdx = (zSize - outZ - 1) * zStride + outY * yStride + outX * xStride;\n            }\n            for (var z: u32 = 0u; z < outZ; z++) {\n                var newZ: u32 = z;\n                if (reverse == u32(1)){\n                    newZ = zSize - z - 1;\n                }\n                let idx = newZ * zStride + outY * yStride + outX * xStride;\n                accum += inputData[idx];\n            }\n\n        } else if (reduceDim == 1u) { // CUMSUM along Y\n            if (reverse == u32(1)){\n                baseIdx = outZ * zStride + (ySize - outY - 1)* yStride + outX * xStride;\n            }\n            for (var y: u32 = 0u; y < outY; y++) {\n                var newY: u32 = y;\n                if (reverse == u32(1)){\n                    newY = ySize - y - 1;\n                }\n                let idx = outZ * zStride + newY * yStride + outX * xStride;\n                accum += inputData[idx];\n            }\n        } else { // CUMSUM along X\n             if (reverse == u32(1)){\n                baseIdx = outZ * zStride + outY* yStride + (xSize - outX - 1) * xStride;\n            }\n            for (var x: u32 = 0u; x < outX; x++) {\n                var newX: u32 = x;\n                if (reverse == u32(1)){\n                    newX = xSize - x - 1;\n                }\n                let idx = outZ * zStride + outY * yStride + newX * xStride;\n                accum += inputData[idx];\n            }\n        }\n            outputData[baseIdx] = accum;\n    }\n",p=o.createShaderModule({label:"cumsum3d compute module",code:x}),h=o.createComputePipeline({label:"cumsum3d compute pipeline",layout:"auto",compute:{module:p}}),g=(0,X.Wu)(x),y=(0,X.FE)(g.uniforms.params);y.set({xStride:f,yStride:c,zStride:d,xSize:s[2],ySize:s[1],zSize:s[0],reduceDim:t,reverse:r,workGroups:[m[2],m[1],m[0]]});let S=o.createBuffer({label:"Input Buffer",size:e.byteLength,usage:GPUBufferUsage.STORAGE|GPUBufferUsage.COPY_DST}),v=o.createBuffer({label:"Output Buffer",size:4*u,usage:GPUBufferUsage.STORAGE|GPUBufferUsage.COPY_SRC}),z=o.createBuffer({label:"Uniform Buffer",size:y.arrayBuffer.byteLength,usage:GPUBufferUsage.UNIFORM|GPUBufferUsage.COPY_DST}),b=o.createBuffer({label:"Read Buffer",size:4*u,usage:GPUBufferUsage.COPY_DST|GPUBufferUsage.MAP_READ});o.queue.writeBuffer(S,0,e),o.queue.writeBuffer(z,0,y.arrayBuffer);let w=o.createBindGroup({layout:h.getBindGroupLayout(0),entries:[{binding:0,resource:{buffer:S}},{binding:1,resource:{buffer:v}},{binding:2,resource:{buffer:z}}]}),_=o.createCommandEncoder({label:"cumsum3d encoder"}),k=_.beginComputePass({label:"cumsum3d compute pass"});k.setPipeline(h),k.setBindGroup(0,w),k.dispatchWorkgroups(m[2],m[1],m[0]),k.end(),_.copyBufferToBuffer(v,0,b,0,4*u),o.queue.submit([_.finish()]),await b.mapAsync(GPUMapMode.READ);let D=new Float32Array(b.getMappedRange().slice());return b.unmap(),D}async function et(e,n,t,r){var i;let a=await (null==(i=navigator.gpu)?void 0:i.requestAdapter()),o=await (null==a?void 0:a.requestDevice({requiredLimits:{maxBufferSize:0x7a0a1efc,maxStorageBufferBindingSize:0x7a0a1efc}}));if(!o)return void Error("need a browser that supports WebGPU");let{strides:l,shape:s}=n,u=s[0]*s[1],[d,c]=[l[0],l[1]],f=[Math.ceil(s[1]/16),Math.ceil(s[0]/16)],m=H[t],x=o.createShaderModule({label:"convolution2d compute module",code:m}),p=o.createComputePipeline({label:"convolution2d compute pipeline",layout:"auto",compute:{module:x}}),h=(0,X.Wu)(m),g=(0,X.FE)(h.uniforms.params);g.set({xStride:c,yStride:d,xSize:s[1],ySize:s[0],kernelSize:r});let y=o.createBuffer({label:"Input Buffer",size:e.byteLength,usage:GPUBufferUsage.STORAGE|GPUBufferUsage.COPY_DST}),S=o.createBuffer({label:"Output Buffer",size:4*u,usage:GPUBufferUsage.STORAGE|GPUBufferUsage.COPY_SRC}),v=o.createBuffer({label:"Uniform Buffer",size:g.arrayBuffer.byteLength,usage:GPUBufferUsage.UNIFORM|GPUBufferUsage.COPY_DST}),z=o.createBuffer({label:"Read Buffer",size:4*u,usage:GPUBufferUsage.COPY_DST|GPUBufferUsage.MAP_READ});o.queue.writeBuffer(y,0,e),o.queue.writeBuffer(v,0,g.arrayBuffer);let b=o.createBindGroup({layout:p.getBindGroupLayout(0),entries:[{binding:0,resource:{buffer:y}},{binding:1,resource:{buffer:S}},{binding:2,resource:{buffer:v}}]}),w=o.createCommandEncoder({label:"convolution2d encoder"}),_=w.beginComputePass({label:"convolution2d compute pass"});_.setPipeline(p),_.setBindGroup(0,b),_.dispatchWorkgroups(f[0],f[1],1),_.end(),w.copyBufferToBuffer(S,0,z,0,4*u),o.queue.submit([w.finish()]),await z.mapAsync(GPUMapMode.READ);let k=new Float32Array(z.getMappedRange().slice());return z.unmap(),k}let er=e=>{let{setTexture:n,ZarrDS:t}=e,{strides:r,dataShape:a,valueScales:o,isFlat:l,setIsFlat:u,setDownloading:f,setShowLoading:x,setValueScales:p}=(0,d.on)((0,c.k)(e=>({strides:e.strides,dataShape:e.dataShape,valueScales:e.valueScales,isFlat:e.isFlat,setIsFlat:e.setIsFlat,setDownloading:e.setDownloading,setShowLoading:e.setShowLoading,setValueScales:e.setValueScales}))),h=(0,d.Ws)(e=>e.setPlotType),{axis:g,execute:y,operation:S,useTwo:v,variable2:z,valueScalesOrig:b,kernelSize:w,kernelDepth:_,kernelOperation:k,reverseDirection:D,analysisStore:C,analysisMode:P,analysisArray:I,setValueScalesOrig:M,setAnalysisArray:j,setAnalysisMode:B}=(0,d.r2)((0,c.k)(e=>({axis:e.axis,execute:e.execute,operation:e.operation,useTwo:e.useTwo,variable2:e.variable2,valueScalesOrig:e.valueScalesOrig,kernelSize:e.kernelSize,kernelDepth:e.kernelDepth,kernelOperation:e.kernelOperation,reverseDirection:e.reverseDirection,analysisStore:e.analysisStore,analysisMode:e.analysisMode,analysisArray:e.analysisArray,setValueScalesOrig:e.setValueScalesOrig,setAnalysisArray:e.setAnalysisArray,setAnalysisMode:e.setAnalysisMode}))),O=(0,d.SZ)(e=>e.slice),A=(0,s.useRef)(new Float32Array(1));return(0,s.useEffect)(()=>{let e=(0,m.Td)(C);if(!(e.length<=1)&&!l)if(x(!0),v)(async function(){if(f(!0),A.current=await t.GetArray(z,O),f(!1),["TwoVarLinearSlope2D","Correlation2D","Covariance2D"].includes(S)){let t=a.filter((e,n)=>n!=g),l=await K(P?I:new Float32Array(e),new Float32Array(A.current.data),{shape:a,strides:r},g,S);b||M(o);let[s,u]=[-1,1];["TwoVarLinearSlope2D","Covariance2D"].includes(S)&&([s,u]=(0,m.Qt)(l)),p({minVal:s,maxVal:u});let d=new Uint8Array(l.map(e=>(e-s)/(u-s)).map(e=>isNaN(e)?255:254*e)),c=new i.GYF(d,t[1],t[0],i.VT0,i.OUM);c.needsUpdate=!0,j(l),n(c),h("flat")}else{let t=await ee(P?I:new Float32Array(e),new Float32Array(A.current.data),{shape:a,strides:r},{kernelDepth:_,kernelSize:w},S);b||M(o),console.log(S);let[l,s]=[-1,1];["TwoVarLinearSlope3D","Covariance3D"].includes(S)&&([l,s]=(0,m.Qt)(t)),p({minVal:l,maxVal:s});let d=new Uint8Array(t.map(e=>(e-l)/(s-l)).map(e=>isNaN(e)?255:254*e)),c=new i.dYF(d,a[2],a[1],a[0]);c.format=i.VT0,c.minFilter=i.hxR,c.magFilter=i.hxR,c.needsUpdate=!0,j(t),n(c),u(!1),h("volume")}})().then(e=>{B(!0),x(!1)});else if("Convolution"!=S){let t=a.filter((e,n)=>n!=g),l="CUMSUM3D"==S;!async function(){let s,d,c;if(!(s="CUMSUM3D"==S?await en(P?I:new Float32Array(e),{shape:a,strides:r},g,D):await $(P?I:new Float32Array(e),{shape:a,strides:r},g,S)))return;["StDev","CUMSUM","CUMSUM3D","LinearSlope"].includes(S)?([d,c]=(0,m.Qt)(s),b||M(o),p({minVal:d,maxVal:c})):b?(d=b.minVal,c=b.maxVal,p(b),M(null)):(d=o.minVal,c=o.maxVal);let f=new Uint8Array(s.map(e=>(e-d)/(c-d)).map(e=>isNaN(e)?255:254*e)),y=l?new i.dYF(f,a[2],a[1],a[0]):new i.GYF(f,t[1],t[0],i.VT0,i.OUM);l&&(y.format=i.VT0,y.minFilter=i.hxR,y.magFilter=i.hxR),y.needsUpdate=!0,j(s),n(y),"CUMSUM3D"!=S&&(u(!0),h("flat")),B(!0),x(!1)}()}else J(P?I:new Float32Array(e),{shape:a,strides:r},k,{kernelDepth:_,kernelSize:w}).then(e=>{let t,r;if(!e)return;"StDev"==k?([t,r]=(0,m.Qt)(e),b||M(o),p({minVal:t,maxVal:r})):b?(t=b.minVal,r=b.maxVal,p(b),M(null)):(t=o.minVal,r=o.maxVal);let l=new Uint8Array(e.map(e=>(e-t)/(r-t)).map(e=>isNaN(e)?255:254*e)),s=new i.dYF(l,a[2],a[1],a[0]);s.format=i.VT0,s.minFilter=i.hxR,s.magFilter=i.hxR,s.needsUpdate=!0,j(e),n(s),u(!1),h("volume")}).then(e=>{B(!0),x(!1)})},[y]),(0,s.useEffect)(()=>{let e=(0,m.Td)(C);if(!(e.length<=1)&&l&&(x(!0),!v))if("Convolution"!=S);else{let t=a.length>2?a.slice(1):a,l=r.length>2?r.slice(1):r;et(P?I:new Float32Array(e),{shape:t,strides:l},k,w).then(e=>{let r,a;if(!e)return;"StDev"==k?([r,a]=(0,m.Qt)(e),b||M(o),p({minVal:r,maxVal:a})):b?(r=b.minVal,a=b.maxVal,p(b),M(null)):(r=o.minVal,a=o.maxVal);let l=new Uint8Array(e.map(e=>(e-r)/(a-r)).map(e=>isNaN(e)?255:254*e)),s=new i.GYF(l,t[1],t[0],i.VT0,i.OUM);s.needsUpdate=!0,j(e),n(s),B(!0),x(!1)})}},[y]),null},ei=e=>{let{show:n}=e,{valueScales:t,variable:a,metadata:o}=(0,d.on)((0,c.k)(e=>({valueScales:e.valueScales,variable:e.variable,metadata:e.metadata}))),{exportImg:l,includeBackground:u,includeColorbar:f,doubleSize:m,useCustomRes:x,getCbarLoc:p,getCbarNum:h,getCustomRes:g,setHideAxisControls:y,setHideAxis:v}=(0,d.qi)((0,c.k)(e=>({exportImg:e.exportImg,includeBackground:e.includeBackground,includeColorbar:e.includeColorbar,doubleSize:e.doubleSize,useCustomRes:e.useCustomRes,getCbarLoc:e.getCbarLoc,getCbarNum:e.getCbarNum,getCustomRes:e.getCustomRes,setHideAxisControls:e.setHideAxisControls,setHideAxis:e.setHideAxis}))),{gl:z,scene:b,camera:w}=(0,N.C)(),_=(0,s.useRef)(!1),k=(0,S.$m)("--text-plot"),D=(0,S.$m)("--background");return(0,s.useEffect)(()=>{if(!n)return;if(!_.current){_.current=!0;return}let e=z.domElement.width,r=z.domElement.height,l=g(),s=x?l[0]:m?2*e:e,d=x?l[1]:m?2*r:r,c=document.createElement("canvas"),S=c.getContext("2d");if(!S)return;if(c.width=s,c.height=d,u&&(S.fillStyle=D,S.fillRect(0,0,c.width,c.height)),x){let e,n=z.getSize(new i.I9Y);if(w instanceof i.ubm)e={aspect:w.aspect},w.aspect=s/d,w.updateProjectionMatrix();else if(w instanceof i.qUd){e={left:w.left,right:w.right,top:w.top,bottom:w.bottom};let n=s/d;if(n>(w.right-w.left)/(w.top-w.bottom)){let e=(w.top-w.bottom)*n,t=(w.left+w.right)/2;w.left=t-e/2,w.right=t+e/2}else{let e=(w.right-w.left)/n,t=(w.top+w.bottom)/2;w.top=t+e/2,w.bottom=t-e/2}w.updateProjectionMatrix()}z.setSize(s,d),z.render(b,w),S.drawImage(z.domElement,0,0,s,d),w instanceof i.ubm?w.aspect=e.aspect:w instanceof i.qUd&&(w.left=e.left,w.right=e.right,w.top=e.top,w.bottom=e.bottom),z.setSize(n.x,n.y),w.updateProjectionMatrix(),v(!1),y(!1),z.render(b,w)}else z.render(b,w),S.drawImage(z.domElement,0,0,s,d),z.render(b,w),v(!1),y(!1);S.fillStyle=k,S.font="".concat(m?72:36,'px "Segoe UI"'),S.fillText(a,m?40:20,m?100:50);let C=m?52:26;if(f){let n=document.getElementById("colorbar-canvas"),r=p(),i=m?Math.min(1024,.8*e):Math.min(512,.8*e),a=m?48:24,l=Math.round(s/2-i/2),u="top"===r?m?140:70:m?d-140:d-70,c="right"===r||"left"===r;if(c){let e=i;i=a,u=Math.round(d/2-(a=e)/2),l="right"===r?m?s-140:s-70:m?140:70}if(n instanceof HTMLCanvasElement)if(c){S.save();let e=l+i/2,t=u+a/2;S.translate(e,t),S.rotate(-Math.PI/2);let r=m?1024:512,o=m?48:24;S.drawImage(n,-r/2,-o/2,r,o),S.restore()}else S.drawImage(n,l,u,i,a);let f=h(),x=t.maxVal-t.minVal,g=1/(f-1),y=c?1/(f-1)*a:1/(f-1)*i;if(S.font="".concat(m?36:18,'px "Segoe UI"'),c){S.textBaseline="middle",S.textAlign="left"==r?"left":"right";for(let e=0;e<f;e++)"left"==r?S.fillText(String((t.minVal+e*g*x).toFixed(2)),l+i+6,u+a-e*y):S.fillText(String((t.minVal+e*g*x).toFixed(2)),l-6,u+a-e*y)}else{S.textBaseline="top",S.textAlign="center";for(let e=0;e<f;e++)S.fillText(String((t.minVal+e*g*x).toFixed(2)),l+e*y,u+a+6)}S.fillStyle=k,S.font="".concat(C,'px "Segoe UI" bold'),S.textAlign="center",S.fillText(null==o?void 0:o.units,l+i/2,u-C-4)}S.fillStyle="#888888",S.font="".concat(m?40:20,'px "Segoe UI", serif '),S.textAlign="left",S.textBaseline="bottom",S.fillText("browzarr.io",m?20:10,m?d-20:d-10),c.toBlob(e=>{if(!e)return;let n=URL.createObjectURL(e),t=document.createElement("a");t.download="browzarr-plot.png",t.href=n,t.click(),URL.revokeObjectURL(n)},"image/png")},[l]),(0,r.jsx)(r.Fragment,{})},ea=e=>{let{isFlat:n}=e,{resetCamera:t}=(0,d.Ws)((0,c.k)(e=>({resetCamera:e.resetCamera}))),a=(0,s.useRef)(null),o=(0,s.useRef)(!1);return(0,s.useEffect)(()=>{if(!o.current){o.current=!0;return}if(a.current){let e,t=a.current,r=performance.now(),o=t.object.position.clone(),l=t.position0.clone(),s=t.target.clone(),u=t.target0.clone(),d=t.object.zoom,c=a=>{(0,N.m)();let f=Math.min((a-r)/1e3,1);t.object.position.lerpVectors(o,l,f),t.target.lerpVectors(s,u,f),n&&(t.object.zoom=i.cj9.lerp(d,1e3,f),t.object.updateProjectionMatrix(),t.update()),f<1&&(e=requestAnimationFrame(c))};return e=requestAnimationFrame(c),()=>cancelAnimationFrame(e)}},[t]),(0,r.jsxs)(r.Fragment,{children:[n&&(0,r.jsx)(T.N,{ref:a,enableRotate:!1,enablePan:!0,maxDistance:50,minZoom:50,maxZoom:3e3}),!n&&(0,r.jsx)(T.N,{ref:a,enableRotate:!0,enablePan:!0,maxDistance:50})]})},eo=e=>{let{ZarrDS:n}=e,{setShape:t,setDataShape:a,setFlipY:o,setValueScales:l,setMetadata:u,setDimArrays:x,setDimNames:h,setDimUnits:v,setPlotOn:z,setShowLoading:b}=(0,d.on)((0,c.k)(e=>({setShape:e.setShape,setDataShape:e.setDataShape,setFlipY:e.setFlipY,setValueScales:e.setValueScales,setMetadata:e.setMetadata,setDimArrays:e.setDimArrays,setDimNames:e.setDimNames,setDimUnits:e.setDimUnits,setPlotOn:e.setPlotOn,setShowLoading:e.setShowLoading}))),{colormap:w,variable:_,isFlat:k,metadata:D,valueScales:C,is4D:P,setIsFlat:I}=(0,d.on)((0,c.k)(e=>({colormap:e.colormap,variable:e.variable,isFlat:e.isFlat,metadata:e.metadata,valueScales:e.valueScales,is4D:e.is4D,setIsFlat:e.setIsFlat}))),{plotType:M}=(0,d.Ws)((0,c.k)(e=>({plotType:e.plotType}))),{slice:j,reFetch:B}=(0,d.SZ)((0,c.k)(e=>({slice:e.slice,reFetch:e.reFetch}))),O=(0,s.useRef)([0,0]),A=(0,s.useRef)(0),[U,Y]=(0,s.useState)(!1),[L,T]=(0,s.useState)([0,0]),[N,V]=(0,s.useState)(null),[X,R]=(0,s.useState)(!0);(0,s.useEffect)(()=>{if("Default"!=_){b(!0),R(!1);try{n.GetArray(_,j).then(e=>{let[n,r]=(0,E.oW)({data:e.data,shape:e.shape});if(n instanceof i.GYF||n instanceof i.dYF?V(n):(console.error("Invalid texture type returned from ArrayToTexture"),V(null)),e.scalingFactor){let{maxVal:n,minVal:t}=r;l({maxVal:n*Math.pow(10,e.scalingFactor),minVal:t*Math.pow(10,e.scalingFactor)})}else l(r);2==e.shape.length?I(!0):I(!1);let o=e.shape[1]/e.shape[2]*2;t(new i.Pq0(2,o,2)),a(e.shape),R(!0),z(!0),b(!1)})}catch(e){b(!1);return}n.GetAttributes(_).then(e=>{u(e);let[t,r,i]=n.GetDimArrays();P&&(t=t.slice(1),r=r.slice(1),i=i.slice(1)),x(t),h(i),t.length>2?t[1][1]<t[1][0]?o(!0):o(!1):t[0][1]<t[0][0]?o(!0):o(!1);let a=[];for(let e of r)a.push(e.units);v(a),(0,m.QB)(a,t)})}else u(null)},[B]);let F=(0,s.useMemo)(()=>({setLoc:T,setShowInfo:Y,coords:O,val:A}),[]),W=(0,s.useMemo)(()=>S.Fp,[]);return(0,r.jsxs)("div",{className:"main-canvas",style:{width:"100vw"},children:[(0,r.jsx)(er,{setTexture:V,ZarrDS:n}),X&&(0,r.jsx)(S.PL,{units:null==D?void 0:D.units,valueScales:C}),(0,r.jsx)(W,{}),(k||"flat"==M)&&(0,r.jsx)(G,{loc:L,show:U,info:[...O.current,A.current]}),(!k&&"flat"!=M||k&&"sphere"===M)&&(0,r.jsx)(r.Fragment,{children:(0,r.jsxs)(y.Hl,{id:"main-canvas",camera:{position:k?[0,0,5]:[-4.5,3,4.5],fov:50},frameloop:"demand",gl:{preserveDrawingBuffer:!0},children:[(0,r.jsx)(ep,{}),(0,r.jsx)(ei,{show:X}),X&&(0,r.jsx)(ez,{}),"volume"==M&&X&&(0,r.jsxs)(r.Fragment,{children:[(0,r.jsx)(f,{volTexture:N}),(0,r.jsx)(p,{ZarrDS:n})]}),"point-cloud"==M&&X&&(0,r.jsx)(r.Fragment,{children:(0,r.jsx)(g,{textures:{texture:N,colormap:w},ZarrDS:n})}),"sphere"==M&&X&&(0,r.jsx)(ec,{texture:N,ZarrDS:n}),(0,r.jsx)(ea,{isFlat:!1})]})}),(k||"flat"==M)&&(0,r.jsx)(r.Fragment,{children:(0,r.jsxs)(y.Hl,{id:"main-canvas",camera:{position:[0,0,5],zoom:1e3},orthographic:!0,frameloop:"demand",children:[(0,r.jsx)(ei,{show:X}),(0,r.jsx)(ep,{}),X&&(0,r.jsx)(ez,{}),(0,r.jsx)(eu,{texture:N,infoSetters:F}),(0,r.jsx)(ea,{isFlat:!0})]})})]})};function el(e){let{points:n,tsID:t,pointSetters:a,scalers:o}=e,l=(0,s.useRef)(null),u=n.length,f=(0,s.useRef)(null),[m,x]=(0,s.useState)(!1),{setPointID:p,setPointLoc:h,setShowPointInfo:g}=a,[y,S]=(0,s.useState)(1),{pointColor:v,pointSize:z,useCustomPointColor:b}=(0,d.Ws)((0,c.k)(e=>({pointColor:e.pointColor,pointSize:e.linePointSize,showPoints:e.showPoints,useCustomPointColor:e.useCustomPointColor}))),{xScale:w,yScale:_}=o,{timeSeries:k}=(0,d.on)((0,c.k)(e=>({timeSeries:e.timeSeries}))),[D,C,P]=k[t].color,I=(0,s.useMemo)(()=>new i.Gu$(z),[z]),M=(0,s.useMemo)(()=>new i.V9B({color:new i.Q1f().setRGB(D/300,C/300,P/300).convertSRGBToLinear()}),[v,b,k]);return(0,s.useEffect)(()=>{if(l.current){let e=new i.B69;for(let t=0;t<u;t++){let r=n[t].toArray();e.position.set(r[0]*(w/2),r[1]*_,1),e.scale.set(z/y,z/y,z/y),e.updateMatrix(),l.current.setMatrixAt(t,e.matrix)}l.current.instanceMatrix.needsUpdate=!0}},[n,y,I,M,w,_,z]),(0,N.D)(e=>{let{camera:n}=e;n.zoom!==y&&S(n.zoom)}),(0,r.jsx)(r.Fragment,{children:(0,r.jsx)("mesh",{position:[0,0,5],onPointerEnter:function(e){if(l.current){let n=e.instanceId,r=new i.B69,a=new i.kn4,o=new i.Pq0;n!=f.current&&f.current&&(l.current.getMatrixAt(f.current,a),o.setFromMatrixPosition(a),r.scale.set(z/y,z/y,z/y),r.position.copy(o),r.updateMatrix(),l.current.setMatrixAt(f.current,r.matrix)),f.current=n,l.current.getMatrixAt(n,a),o.setFromMatrixPosition(a),r.scale.set(3*z/y,3*z/y,3/y),r.position.copy(o),r.updateMatrix(),l.current.setMatrixAt(e.instanceId,r.matrix),l.current.instanceMatrix.needsUpdate=!0,x(e=>!e),p([t,e.instanceId]),h([e.clientX,e.clientY]),g(!0)}},onPointerLeave:function(e){let n=e.instanceId;if(l.current){let e=new i.B69,t=new i.kn4,r=new i.Pq0;f.current&&(l.current.getMatrixAt(n,t),r.setFromMatrixPosition(t),e.scale.set(z/y,z/y,z/y),e.position.copy(r),e.updateMatrix(),l.current.setMatrixAt(n,e.matrix),l.current.instanceMatrix.needsUpdate=!0,x(e=>!e),g(n!=f.current))}},children:(0,r.jsx)("instancedMesh",{ref:l,args:[I,M,u]})})})}let es=e=>{let{height:n,xScale:t,yScale:a,pointSetters:o}=e,{valueScales:l,timeSeries:u,colormap:f}=(0,d.on)((0,c.k)(e=>({valueScales:e.valueScales,timeSeries:e.timeSeries,colormap:e.colormap}))),{lineWidth:m,useLineColor:x,lineColor:p,showPoints:h,lineResolution:g,useCustomColor:y}=(0,d.Ws)((0,c.k)(e=>({lineWidth:e.lineWidth,linePointSize:e.linePointSize,showPoints:e.showPoints,useLineColor:e.useLineColor,lineColor:e.lineColor,lineResolution:e.lineResolution,useCustomColor:e.useCustomColor}))),{camera:S}=(0,N.C)(),{maxVal:v,minVal:z}=l,b=(0,s.useMemo)(()=>{let e={};return Object.keys(u).reverse().map((n,r)=>{let[o,l,s]=u[n].color;e[n]=new i.BKk({glslVersion:i.Wdf,uniforms:{cmap:{value:f},xScale:{value:t},yScale:{value:a},aspect:{value:window.innerWidth/window.innerHeight},thickness:{value:m},miter:{value:1},useLineColor:{value:y},useMapColors:{value:x},lineColor:{value:new i.Q1f().setRGB(o/255,l/255,s/255)},userColor:{value:new i.Q1f(p)},zoom:{value:S.zoom}},vertexShader:"attribute float direction; \nattribute vec3 next;\nattribute vec3 previous;\nattribute float normed;\n\nvarying float vNormed;\n\nuniform float zoom;\nuniform float thickness;\nuniform int miter;\nuniform float xScale; \nuniform float yScale;\n\nfloat getOrthographicZoom(mat4 projectionMatrix, float referenceWidth) {\n    float m0 = projectionMatrix[0][0]; // Scaling factor: 2/(right-left)\n    float viewWidth = 2.0 / m0; // Viewable width\n    return referenceWidth / viewWidth; // Zoom level\n}\n\nvoid main() {\n    vec3 pos = position;\n    vec3 prev = previous;\n    vec3 nex = next;\n    pos.x *= xScale/2.0;\n    pos.y *= yScale;\n    prev.x *= xScale/2.0;\n    prev.y *= yScale;\n    nex.x *= xScale/2.0;\n    nex.y *= yScale;\n\n    // Transform positions to view space (before projection)\n    float zoom = getOrthographicZoom(projectionMatrix, 2.);\n    float zoomLevel = 2. / projectionMatrix[0][0]; // Extract vertical scale\n    vec4 currentView = modelViewMatrix * vec4(pos, 1.0);\n    vec4 prevView = modelViewMatrix * vec4(prev, 1.0);\n    vec4 nextView = modelViewMatrix * vec4(nex, 1.0);\n\n    // Compute directions in view space\n    vec3 dir = vec3(0.0);\n    if (currentView.xyz == prevView.xyz) {\n        dir = normalize(nextView.xyz - currentView.xyz);\n    } else if (currentView.xyz == nextView.xyz) {\n        dir = normalize(currentView.xyz - prevView.xyz);\n    } else {\n        vec3 dirA = normalize(currentView.xyz - prevView.xyz);\n        if (miter == 1) {\n            vec3 dirB = normalize(nextView.xyz - currentView.xyz);\n            vec3 tangent = normalize(dirA + dirB);\n            vec3 perp = vec3(-dirA.y, dirA.x, 0.0); // Perpendicular in view space\n            vec3 miterVec = vec3(-tangent.y, tangent.x, 0.0);\n            float miterLen = dot(miterVec, perp);\n            miterLen = max(miterLen, 0.5); // Avoid division by zero\n            dir = tangent;\n        } else {\n            dir = dirA;\n        }\n    }\n\n    // Compute normal in view space\n    vec3 normal = vec3(-dir.y, dir.x, 0.0); // Perpendicular to direction\n    float len = thickness / zoom/500.; // Thickness in world/view space units\n    normal *= 0.5 * len * direction; // Apply thickness and direction\n\n    // Apply offset in view space\n    currentView.xyz += normal;\n\n    // Project to clip space\n    gl_Position = projectionMatrix * currentView;\n\n\n    vNormed = normed;\n    gl_PointSize = 1.0;\n}",fragmentShader:"\n                out vec4 Color;\n                uniform sampler2D cmap;\n                uniform bool useLineColor;\n                uniform bool useMapColors;\n                uniform vec3 lineColor;\n                uniform vec3 userColor;\n                varying float vNormed;\n\n                void main() {\n                    vec4 texColor = texture(cmap, vec2(vNormed, 0.1));\n                    texColor.a = 1.;\n                    Color = useLineColor ? vec4(userColor, 1.0) : useMapColors ? texColor : vec4(lineColor, 1.0) ;\n                }\n                ",depthWrite:!1})}),e},[f,m,t,a,window.innerWidth,window.innerHeight,x,p,S.zoom,y,u]),w=(0,s.useMemo)(()=>window.innerWidth,[window.innerWidth]),_=(0,s.useMemo)(()=>window.innerHeight-n,[window.innerWidth,n]),[k,D]=(0,s.useState)({}),C=(0,s.useMemo)(()=>{let e={},n={};return Object.keys(u).map((t,r)=>{let a=u[t].data,o=a.map(e=>(e-z)/(v-z)),l=function(e,n,t){let r=(n-e)/(t-1);return Array.from({length:t},(n,t)=>e+r*t)}(-w,w,a.length),s=o.map((e,n)=>new i.Pq0(l[n],(e-.5)*_,5));n[t]=s;let d=new i.B6O(s).getPoints(s.length*g-1),c=[];for(let e=0;e<d.length;e++){let n=e/(d.length-1)*(o.length-1),t=Math.floor(n),r=Math.min(o.length-1,Math.ceil(n)),i=n-t;c.push(o[t]*(1-i)+o[r]*i)}let f=d.length,m=[],x=[],p=[],h=[],y=[],S=[];for(let e=0;e<f;e++){let n=d[e],t=d[Math.max(0,e-1)],r=d[Math.min(f-1,e+1)];m.push(...n,...n),x.push(1,-1),p.push(...t,...t),h.push(...r,...r),y.push(c[e],c[e])}for(let e=0;e<f-1;e++){let n=2*e,t=n+1,r=n+2,i=n+3;S.push(n,t,r),S.push(t,i,r)}let b=new i.LoY;b.setAttribute("position",new i.qtW(m,3)),b.setAttribute("direction",new i.qtW(x,1)),b.setAttribute("previous",new i.qtW(p,3)),b.setAttribute("next",new i.qtW(h,3)),b.setAttribute("normed",new i.qtW(y,1)),b.setIndex(new i.A$4(S,1)),e[t]=b}),D(n),e},[u,g]);return(0,s.useEffect)(()=>{(0,N.m)()},[h]),(0,r.jsx)(r.Fragment,{children:(0,r.jsxs)("group",{children:[Object.keys(u).map((e,n)=>(0,r.jsx)("mesh",{geometry:C[e],material:b[e]},"lineMesh_".concat(n))),h&&Object.keys(u).map((e,n)=>(0,r.jsx)(el,{points:k[e],tsID:e,pointSetters:o,scalers:{xScale:t,yScale:a}},"plotPoints_".concat(n)))]})})},eu=e=>{let{texture:n,infoSetters:t}=e,{setLoc:a,setShowInfo:o,val:l,coords:u}=t,{flipY:f,colormap:x,valueScales:p,dimArrays:h,isFlat:g}=(0,d.on)((0,c.k)(e=>({flipY:e.flipY,colormap:e.colormap,valueScales:e.valueScales,dimArrays:e.dimArrays,isFlat:e.isFlat}))),{cScale:y,cOffset:S,animProg:v,nanTransparency:z,nanColor:b}=(0,d.Ws)((0,c.k)(e=>({cOffset:e.cOffset,cScale:e.cScale,resetAnim:e.resetAnim,animate:e.animate,animProg:e.animProg,nanTransparency:e.nanTransparency,nanColor:e.nanColor}))),{axis:w,analysisMode:_,analysisArray:k}=(0,d.r2)((0,c.k)(e=>({axis:e.axis,analysisMode:e.analysisMode,analysisArray:e.analysisArray}))),D=n.source.data,C=(0,s.useMemo)(()=>D.height/D.width,[D]),P=(0,s.useMemo)(()=>new i.bdM(2,2*C),[C]),I=(0,s.useRef)(!1),M=(0,s.useRef)(new i.I9Y(0,0)),j=_&&2==w,B=(0,s.useMemo)(()=>_?k:(0,m.Td)(),[_,k]),O=(0,s.useMemo)(()=>h.filter((e,n)=>n!=w),[h,w]),A=(0,s.useMemo)(()=>new i.BKk({glslVersion:i.Wdf,uniforms:{cScale:{value:y},cOffset:{value:S},data:{value:n},cmap:{value:x},animateProg:{value:v},nanColor:{value:new i.Q1f(b)},nanAlpha:{value:1-z}},vertexShader:" // by Jeran Poehls\r\nvarying vec2 vUv;\r\n\r\nvoid main() {\r\n    vUv = uv;\r\n    gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);\r\n}",fragmentShader:g?" // Basic Shader for colors on a plane used in FlatMap with 2D data\r\nprecision highp float;\r\nprecision highp sampler3D;\r\n\r\nout vec4 color;\r\n\r\nvarying vec2 vUv;\r\n\r\nuniform sampler2D data;\r\nuniform sampler2D cmap;\r\nuniform float nanAlpha;\r\nuniform vec3 nanColor;\r\nuniform float cOffset;\r\nuniform float cScale;\r\n\r\nvoid main(){\r\n\r\n    float strength = texture2D(data, vUv).r;\r\n    bool isNaN = strength == 1.;\r\n    float sampLoc = isNaN ? strength: (strength - 0.5)*cScale + 0.5;\r\n    sampLoc = isNaN ? strength : min(sampLoc+cOffset,0.995);\r\n    color = isNaN ? vec4(nanColor, nanAlpha) : vec4(texture2D(cmap, vec2(sampLoc, 0.5)).rgb, 1.);\r\n\r\n}":"//This is for Flat Textures but with 3D textures to sample from i,e; animation\r\n\r\nuniform sampler3D data;\r\nuniform sampler2D cmap;\r\n\r\nuniform float cOffset;\r\nuniform float cScale;\r\nuniform float animateProg;\r\nuniform float nanAlpha;\r\nuniform vec3 nanColor;\r\n\r\nvarying vec2 vUv;\r\nout vec4 Color;\r\n\r\nvoid main() {\r\n\r\n    float strength = texture(data,vec3(vUv, animateProg)).r;\r\n    bool isNaN = strength == 1.;\r\n    float sampLoc = isNaN ? strength: (strength)*cScale;\r\n    sampLoc = isNaN ? strength : min(sampLoc+cOffset,0.995);\r\n    Color = isNaN ? vec4(nanColor, nanAlpha) : vec4(texture2D(cmap, vec2(sampLoc, 0.5)).rgb, 1.);\r\n\r\n}",side:i.$EB}),[y,S,n,x,v,b,z]);(0,s.useEffect)(()=>{P.dispose()},[P]);let U=(0,s.useRef)(null),Y=(0,s.useCallback)(e=>{if(I.current&&e.uv){U.current=e,a([e.clientX,e.clientY]),M.current=e.uv;let{x:n,y:t}=e.uv,r=g?_?O[1].length:h[1].length:h[2].length,i=g?_?O[0].length:h[0].length:h[1].length,o=Math.round(n*r-.5),s=Math.round(t*i-.5),d=r*s+o;d+=g?0:Math.floor((h[0].length-1)*v)*r*i;let c=B?B[d]:0;l.current=g&&!_?function(e,n){return e*(n.maxVal-n.minVal)+n.minVal}(c,p):c,u.current=g?_?[O[0][s],O[1][o]]:[h[0][s],h[1][o]]:[h[1][s],h[2][o]]}},[B,h,v]);return(0,r.jsx)(r.Fragment,{children:(0,r.jsx)("mesh",{material:A,geometry:P,scale:[1,f?-1:1,1],rotation:[0,0,j?Math.PI/2:0],onPointerEnter:()=>{o(!0),I.current=!0},onPointerLeave:()=>{o(!1),I.current=!1},onPointerMove:Y})})};function ed(e){return e*Math.PI/180}let ec=e=>{let{texture:n,ZarrDS:t}=e,{colormap:a,isFlat:o}=(0,d.on)((0,c.k)(e=>({colormap:e.colormap,isFlat:e.isFlat}))),{setPlotDim:l,updateDimCoords:f,updateTimeSeries:p}=(0,d.on)((0,c.k)(e=>({setPlotDim:e.setPlotDim,updateDimCoords:e.updateDimCoords,updateTimeSeries:e.updateTimeSeries}))),{analysisMode:h,analysisArray:g}=(0,d.r2)((0,c.k)(e=>({analysisMode:e.analysisMode,analysisArray:e.analysisArray}))),{dimArrays:y,dimNames:S,dimUnits:v,timeSeries:z,dataShape:b,strides:w}=(0,d.on)((0,c.k)(e=>({dimArrays:e.dimArrays,dimNames:e.dimNames,dimUnits:e.dimUnits,timeSeries:e.timeSeries,dataShape:e.dataShape,strides:e.strides}))),{animate:_,animProg:k,cOffset:D,cScale:C,selectTS:P,lonExtent:I,latExtent:M,lonResolution:j,latResolution:B,nanColor:O,nanTransparency:A,getColorIdx:U,incrementColorIdx:Y}=(0,d.Ws)((0,c.k)(e=>({animate:e.animate,animProg:e.animProg,cOffset:e.cOffset,cScale:e.cScale,selectTS:e.selectTS,lonExtent:e.lonExtent,latExtent:e.latExtent,lonResolution:e.lonResolution,latResolution:e.latResolution,nanColor:e.nanColor,nanTransparency:e.nanTransparency,getColorIdx:e.getColorIdx,incrementColorIdx:e.incrementColorIdx}))),[L,T]=(0,s.useState)({}),[N,V]=(0,s.useState)(Array(10).fill(new i.IUQ(-1,-1,-1,-1))),{height:E,width:G}=(0,s.useMemo)(()=>null==n?void 0:n.source.data,[n]);(0,s.useEffect)(()=>{let e=Object.keys(L),n=Object.keys(z),t=(e=e.filter(e=>n.includes(e))).map(e=>L[e]);V([...t,...Array(Math.max(0,10-t.length)).fill(new i.IUQ(-1,-1,-1,-1))])},[L,z]);let[X,R]=(0,s.useMemo)(()=>{let e=B/2,n=j/2;return[[Math.max(I[0]-n,-180),Math.min(I[1]+n,180)],[Math.max(M[0]-e,-90),Math.min(M[1]+e,90)]]},[M,I,j,B]),F=(0,s.useMemo)(()=>new i.WBB(1,9),[]);(0,s.useRef)(0);let W=(0,s.useMemo)(()=>new i.BKk({glslVersion:i.Wdf,uniforms:{map:{value:n},selectTS:{value:P},selectBounds:{value:N},cmap:{value:a},cOffset:{value:D},cScale:{value:C},animateProg:{value:k},latBounds:{value:new i.I9Y(ed(R[0]),ed(R[1]))},lonBounds:{value:new i.I9Y(ed(X[0]),ed(X[1]))},nanColor:{value:new i.Q1f(O)},nanAlpha:{value:1-A}},vertexShader:u,fragmentShader:o?" // by Jeran Poehls\nprecision highp float;\nprecision highp sampler2D;\n\nout vec4 color;\n\nin vec3 aPosition;\n\nuniform sampler2D map;\nuniform sampler2D cmap;\n\nuniform float cOffset;\nuniform float cScale;\nuniform float animateProg;\nuniform bool selectTS;\nuniform vec2 latBounds;\nuniform vec2 lonBounds;\nuniform vec3 nanColor;\nuniform float nanAlpha;\n\n#define pi 3.141592653\n\nvec2 giveUV(vec3 position){\n    vec3 n = normalize(position);\n    float latitude = asin(n.y);\n    float longitude = atan(n.z, n.x);\n    latitude = (latitude - latBounds.x)/(latBounds.y - latBounds.x);\n    longitude = (longitude - lonBounds.x)/(lonBounds.y - lonBounds.x);\n\n    return vec2(1.-longitude, latitude);\n}\n\nvoid main(){\n    vec2 sampleCoord = giveUV(aPosition);\n    float strength = texture(map, sampleCoord).r;\n    bool isNaN = strength == 1.;\n    strength = isNaN ? strength : (strength - 0.5)*cScale + 0.5;\n    strength = isNaN ? strength : min(strength+cOffset,0.99);\n    color = isNaN ? vec4(nanColor, nanAlpha) : texture(cmap, vec2(strength, 0.5));\n    if (!isNaN){\n        color.a = 1.;\n    }\n\n\n}":" // by Jeran Poehls\nprecision highp float;\nprecision highp sampler3D;\n\nout vec4 color;\n\nin vec3 aPosition;\n\nuniform sampler3D map;\nuniform sampler2D cmap;\n\nuniform float cOffset;\nuniform float cScale;\nuniform float animateProg;\nuniform vec4[10] selectBounds; \nuniform bool selectTS;\nuniform vec2 latBounds;\nuniform vec2 lonBounds;\nuniform vec3 nanColor;\nuniform float nanAlpha;\n\n#define pi 3.141592653\n\nvec2 giveUV(vec3 position){\n    vec3 n = normalize(position);\n    float latitude = asin(n.y);\n    float longitude = atan(n.z, n.x);\n    latitude = (latitude - latBounds.x)/(latBounds.y - latBounds.x);\n    longitude = (longitude - lonBounds.x)/(lonBounds.y - lonBounds.x);\n\n    return vec2(1.-longitude, latitude);\n}\n\nbool isValid(vec2 sampleCoord){\n    for (int i = 0; i < 10; i++){\n        vec4 thisBound = selectBounds[i];\n        if (thisBound.x == -1.){\n            return false;\n        }\n        bool cond = (sampleCoord.x < thisBound.r || sampleCoord.x > thisBound.g || sampleCoord.y < thisBound.b ||  sampleCoord.y > thisBound.a);\n        if (!cond){\n            return true;\n        }\n    }\n    return false;\n}\n\nvoid main(){\n    vec2 sampleCoord = giveUV(aPosition);\n    bool inBounds = all(greaterThanEqual(sampleCoord, vec2(0.0))) && \n                all(lessThanEqual(sampleCoord, vec2(1.0)));\n    \n    if (inBounds) {\n    float strength = texture(map, vec3(sampleCoord, animateProg)).r;\n    bool isNaN = strength == 1.;\n    strength = isNaN ? strength : (strength)*cScale;\n    strength = isNaN ? strength : min(strength+cOffset,0.99);\n    color = isNaN ? vec4(nanColor, nanAlpha) : texture(cmap, vec2(strength, 0.5));\n    if (!isNaN){\n        color.a = 1.;\n    }\n    bool cond = isValid(sampleCoord);\n    if (!cond && selectTS){\n        color.rgb *= 0.65;\n    }\n    } else {\n        color = vec4(nanColor, 1.); // Black\n        color.a = nanAlpha;\n    }\n    \n    // color = vec4(sampleCoord, 0., 1.0);\n\n}",blending:i.NTi,side:i.hB5,transparent:!0,depthWrite:!1}),[n,k,a,D,C,_,N,P,X,R,O,A]),q=W.clone();return q.side=i.hsX,(0,r.jsxs)(r.Fragment,{children:[(0,r.jsx)("mesh",{renderOrder:1,geometry:F,material:W,onClick:e=>P&&function(e){let n=function(e,n,t){let r=Math.atan2(e.z,e.x),a=Math.asin(e.y),o=(r-ed(t[0]))/(ed(t[1])-ed(t[0])),l=(a-ed(n[0]))/(ed(n[1])-ed(n[0]));return new i.I9Y(1-o,l)}(e.point.normalize(),R,X),r=new i.Pq0(0,0,1);if(t){var a,o;let e=(0,m.PE)({data:h?g:(0,m.Td)(),shape:b,stride:w},{uv:n,normal:r}),t=r.toArray().map((e,n)=>Math.abs(e)>0?n:null).filter(e=>null!==e);l(2-t[0]);let s=(0,m.jT)({normal:r,uv:n}).map((e,n)=>e?y[n][Math.round(e*y[n].length)]:null),u=S.filter((e,n)=>null!==s[n]),d=v.filter((e,n)=>null!==s[n]);s=s.filter(e=>null!==e);let c="".concat(s[0],"_").concat(s[1]),z={color:(0,x.md)(U()/10,"Paired"),data:e};Y(),p({[c]:z}),f({[c]:{first:{name:u[0],loc:null!=(a=s[0])?a:0,units:d[0]},second:{name:u[1],loc:null!=(o=s[1])?o:0,units:d[1]},plot:{units:v[2-t[0]]}}}),function(e,n){let t=Math.floor(e.x*G)+.5,r=Math.ceil(e.y*E)-.5,a=1/G,o=1/E,l={[n]:new i.IUQ(...[t/G-a/2,t/G+a/2],...[r/E-o/2,r/E+o/2])};T(e=>({...l,...e}))}(n,c)}}(e)}),(0,r.jsx)("mesh",{renderOrder:0,geometry:F,material:q})]})};function ef(e,n,t){let[r,i]=e,a=(r-n[0])/(n[1]-n[0]),o=(i-t[0])/(t[1]-t[0]);return a-=.5,o-=.5,[a*=2,(o*=2)/2,0]}function em(e){let[n,t]=e,r=t*Math.PI/180,i=n*Math.PI/180;return[Math.cos(r)*Math.cos(i)*1.001,1.001*Math.sin(r),Math.cos(r)*Math.sin(i)*1.001]}function ex(e){let{features:n}=e,{xRange:t,yRange:a,plotType:o,borderColor:l,lonExtent:f,latExtent:m,lonResolution:x,latResolution:p}=(0,d.Ws)((0,c.k)(e=>({xRange:e.xRange,yRange:e.yRange,plotType:e.plotType,borderColor:e.borderColor,lonExtent:e.lonExtent,latExtent:e.latExtent,lonResolution:e.lonResolution,latResolution:e.latResolution}))),{flipY:h,shape:g}=(0,d.on)((0,c.k)(e=>({flipY:e.flipY,shape:e.shape}))),[y,S]=(0,s.useMemo)(()=>{let e=p/2,n=x/2,t=[Math.max(f[0]-n,-180),Math.min(f[1]+n,180)],r=[Math.max(m[0]-e,-90),Math.min(m[1]+e,90)];return[t,r=h?[r[1],r[0]]:r]},[m,f,x,p]),[v,z]=(0,s.useState)(!1);(0,s.useEffect)(()=>{"sphere"===o?z(!0):z(!1)},[o]);let b=(0,s.useMemo)(()=>new i.BKk({glslVersion:i.Wdf,vertexShader:u,fragmentShader:"precision highp float;\r\nprecision highp sampler3D;\r\n\r\nout vec4 color;\r\n\r\nin vec3 aPosition;\r\n\r\nuniform vec2 xBounds;\r\nuniform vec2 yBounds;\r\nuniform vec3 borderColor;\r\nuniform bool trim;\r\n\r\nvoid main() {\r\n\r\n    if ((aPosition.x < xBounds.x || aPosition.x > xBounds.y || aPosition.y < yBounds.x || aPosition.y > yBounds.y) && trim){\r\n        discard;\r\n    }\r\n\r\n    color = vec4(borderColor, 1.0);\r\n}",uniforms:{xBounds:{value:new i.I9Y(t[0],t[1])},yBounds:{value:new i.I9Y(a[0]/g.x,a[1]/g.x)},borderColor:{value:new i.Q1f(l)},trim:{value:!v}}}),[t,a,l,v]),w=(0,s.useMemo)(()=>n.flatMap((e,n)=>{let t=[];if("LineString"===e.geometry.type){let n=[];e.geometry.coordinates.forEach(e=>{let[t,r]=e,[a,o,l]=v?em([-t,r]):ef([t,r],y,S);n.push(new i.Pq0(a,o,l))});let r=new Float32Array(3*n.length);n.forEach((e,n)=>{r.set([e.x,e.y,e.z],3*n)});let a=new i.LoY;a.setAttribute("position",new i.THS(r,3)),t.push(a)}else"MultiPolygon"===e.geometry.type?e.geometry.coordinates.forEach((e,n)=>{let r=n,a=e[0],o=[];a.forEach(e=>{let[n,t]=e;r++;let[a,l,s]=v?em([-n,t]):ef([n,t],y,S);o.push(new i.Pq0(a,l,s))});let l=new Float32Array(3*o.length);o.forEach((e,n)=>{l.set([e.x,e.y,e.z],3*n)});let s=new i.LoY;s.setAttribute("position",new i.THS(l,3)),t.push(s)}):("Polygon"===e.geometry.type?[e.geometry.coordinates]:e.geometry.coordinates).forEach(e=>{let n=[];e.forEach(e=>{e.forEach(e=>{let[t,r]=e,[a,o,l]=v?em([-t,r]):ef([t,r],y,S);n.push(new i.Pq0(a,o,l))})});let r=new Float32Array(3*n.length);n.forEach((e,n)=>{r.set([e.x,e.y,e.z],3*n)});let a=new i.LoY;a.setAttribute("position",new i.THS(r,3)),t.push(a)});return t}),[n,v,h,y,S]),_=(0,s.useMemo)(()=>w.map((e,n)=>{let t=new i.N1A(e,b);return(0,r.jsx)("primitive",{object:t},"border-".concat(n))}),[w,b]);return(0,r.jsx)(r.Fragment,{children:_})}let ep=()=>{let[e,n]=(0,s.useState)(null),[t,i]=(0,s.useState)(null),[a,o]=(0,s.useState)(!1),{zRange:l,plotType:u,showBorders:f}=(0,d.Ws)((0,c.k)(e=>({zRange:e.zRange,plotType:e.plotType,showBorders:e.showBorders}))),[m,x]=(0,s.useState)(!1);return(0,s.useEffect)(()=>{"sphere"===u?x(!0):x(!1)},[u]),(0,N.D)(e=>{let{camera:n}=e;!m&&(Math.abs(n.rotation.z)>Math.PI/2?o(!0):a&&o(!1))}),(0,s.useEffect)(()=>{fetch("./ne_110m_coastline.json").then(e=>e.json()).then(e=>n(e.features)),fetch("./ne_110m_admin_0_countries.json").then(e=>e.json()).then(e=>i(e.features))},[]),(0,r.jsxs)("group",{visible:f&&"point-cloud"!=u,position:m?[0,0,0]:[0,0,a?l[0]:l[1]],children:[e&&(0,r.jsx)(ex,{features:e}),t&&(0,r.jsx)(ex,{features:t})]})};var eh=t(2349),eg=t(3571),ey=t(9385);let eS=e=>{let{flipX:n,flipY:t,flipDown:a}=e,{dimArrays:o,dimNames:l,dimUnits:u,shape:f,dataShape:x}=(0,d.on)((0,c.k)(e=>({dimArrays:e.dimArrays,dimNames:e.dimNames,dimUnits:e.dimUnits,shape:e.shape,dataShape:e.dataShape}))),{xRange:p,yRange:h,zRange:g,plotType:y,timeScale:v,animProg:z}=(0,d.Ws)((0,c.k)(e=>({xRange:e.xRange,yRange:e.yRange,zRange:e.zRange,plotType:e.plotType,timeScale:e.timeScale,animProg:e.animProg}))),{hideAxis:b,hideAxisControls:w}=(0,d.qi)((0,c.k)(e=>({hideAxis:e.hideAxis,hideAxisControls:e.hideAxisControls}))),_=[o[0].length,o[1].length,o[2].length],[k,D]=(0,s.useState)(7),[C,P]=(0,s.useState)(7),[I,M]=(0,s.useState)(7),j=(0,s.useMemo)(()=>"point-cloud"==y,[y]),B=(0,s.useMemo)(()=>x[0]/x[1]*v/2,[x,v]),O=(0,s.useMemo)(()=>f.y/f.x,[f]),A=(0,S.$m)("--text-plot"),U=(0,s.useMemo)(()=>{if(A)return new i.Q1f(A).getHex()},[A]),Y=(0,s.useMemo)(()=>new ey.G({color:U||0,linewidth:2}),[U]),T=(0,s.useMemo)(()=>{let e=new eh.n().setPositions([p[0]-.025,0,0,p[1]+.025,0,0]);return new eg.b(e,Y)},[p,Y]),N=(0,s.useMemo)(()=>{let e=new eh.n().setPositions([0,h[0]*O,0,0,h[1]*O+.025,0]);return new eg.b(e,Y)},[h,O,Y]),V=(0,s.useMemo)(()=>{let e=new eh.n().setPositions([0,0,j?g[0]*B-.025:g[0]-.025,0,0,j?g[1]*B+.025:g[1]+.025]);return new eg.b(e,Y)},[g,B,j,Y]),E=(0,s.useMemo)(()=>{let e=new eh.n().setPositions([0,0,0,0,0,.05]);return new eg.b(e,Y)},[Y]),G=k/(k-1),X=1/(k-1),R=C/(C-1),F=1/(C-1),W=I/(I-1),q=1/(I-1);return(0,r.jsxs)("group",{visible:"sphere"!=y&&"flat"!=y&&!b,children:[(0,r.jsxs)("group",{position:[0,O*h[0],0],children:[(0,r.jsxs)("group",{position:[0,0,n?j?g[0]*B-.025:g[0]-.025:j?g[1]*B+.025:g[1]+.025],rotation:[a?n?-Math.PI/2:Math.PI/2:0,0,0],children:[(0,r.jsx)("primitive",{object:T},"xLine"),Array(k).fill(null).map((e,t)=>(p[0]+1)/2<=t*G/k&&(p[1]+1)/2>=t*G/k&&(0,r.jsxs)("group",{position:[-1+t*G/(k/2),0,0],children:[(0,r.jsx)("primitive",{object:E.clone(),rotation:[0,n?Math.PI:0,0]},t),(0,r.jsx)(L.E,{anchorX:0==t?n?"right":"left":t==k-1?n?"left":"right":"center",anchorY:"top",fontSize:.05,color:U,"material-depthTest":!1,rotation:[-Math.PI/2,0,n?Math.PI:0],position:[0,0,n?-.05:.05],children:(0,m.SB)(o[2][Math.floor((_[2]-1)*t*X)],u[2])},"textX_".concat(t))]},"xGroup_".concat(t))),(0,r.jsxs)("group",{rotation:[-Math.PI/2,0,n?Math.PI:0],position:[(p[0]+p[1])/2,0,n?-.2:.2],children:[(0,r.jsx)(L.E,{anchorX:"center",anchorY:"top",fontSize:.1,color:U,"material-depthTest":!1,children:l[2]},"xTitle"),(0,r.jsxs)("group",{visible:!w,children:[k<20&&(0,r.jsx)(L.E,{anchorX:"center",anchorY:"middle",fontSize:.2,color:U,"material-depthTest":!1,position:[.2,-.2,0],onClick:e=>D(e=>Math.min(e+1,20)),onPointerEnter:e=>document.body.style.cursor="pointer",onPointerLeave:e=>document.body.style.cursor="default",children:"+"},"xAdd"),k>1&&(0,r.jsx)(L.E,{anchorX:"center",anchorY:"middle",fontSize:.2,color:U,"material-depthTest":!1,position:[-.2,-.2,0],onClick:e=>D(e=>Math.max(e-1,1)),onPointerEnter:e=>document.body.style.cursor="pointer",onPointerLeave:e=>document.body.style.cursor="default",children:"-"},"xSub")]})]})]}),(0,r.jsxs)("group",{position:[t?p[1]+.025:p[0]-.025,0,0],rotation:[0,0,a?t?-Math.PI/2:Math.PI/2:0],children:[(0,r.jsx)("primitive",{object:V},"zLine"),Array(I).fill(null).map((e,n)=>(g[0]+1)/2<=n*W/I&&(g[1]+1)/2>=n*W/I&&(0,r.jsxs)("group",{position:[0,0,j?-B+n*W/(I/2)*B:-1+n*W/(I/2)],children:[(0,r.jsx)("primitive",{object:E.clone(),rotation:[0,t?Math.PI/2:-Math.PI/2,0]},n),(0,r.jsx)(L.E,{anchorX:0==n?t?"right":"left":n==I-1?t?"left":"right":"center",anchorY:"top",fontSize:.04,color:U,"material-depthTest":!1,rotation:[-Math.PI/2,0,t?Math.PI/2:-Math.PI/2],position:[t?.05:-.05,0,0],children:(0,m.SB)(o[0][(Math.floor((_[0]-1)*n*q)+Math.floor(_[0]*z))%_[0]],u[0])},"textY_".concat(n))]},"zGroup_".concat(n))),(0,r.jsxs)("group",{rotation:[-Math.PI/2,0,t?Math.PI/2:-Math.PI/2],position:[t?.2:-.2,0,j?(g[0]+g[1])/2*B:(g[0]+g[1])/2],children:[(0,r.jsx)(L.E,{anchorX:"center",anchorY:"top",fontSize:.1,color:U,"material-depthTest":!1,children:l[0]},"zTitle"),(0,r.jsxs)("group",{visible:!w,children:[I<20&&(0,r.jsx)(L.E,{anchorX:"center",anchorY:"middle",fontSize:.2,color:U,"material-depthTest":!1,position:[.2,-.2,0],onClick:e=>M(e=>Math.min(e+1,20)),onPointerEnter:e=>document.body.style.cursor="pointer",onPointerLeave:e=>document.body.style.cursor="default",children:"+"},"zAdd"),I>1&&(0,r.jsx)(L.E,{anchorX:"center",anchorY:"middle",fontSize:.2,color:U,"material-depthTest":!1,position:[-.2,-.2,0],onClick:e=>M(e=>Math.max(e-1,1)),onPointerEnter:e=>document.body.style.cursor="pointer",onPointerLeave:e=>document.body.style.cursor="default",children:"-"},"zSub")]})]})]})]}),(0,r.jsxs)("group",{position:[t?p[0]-.025:p[1]+.025,0,n?j?g[0]*B-.025:g[0]-.025:j?g[1]*B+.025:g[1]+.025],children:[(0,r.jsx)("primitive",{object:N},"yLine"),Array(C).fill(null).map((e,i)=>(h[0]+1)/2<=i*R/C&&(h[1]+1)/2>=i*R/C&&(0,r.jsxs)("group",{position:[0,-f.y/2+i*R/(C/2)*O,0],children:[(0,r.jsx)("primitive",{object:E.clone(),rotation:[0,t?-Math.PI/2:Math.PI/2,0]},i),(0,r.jsx)(L.E,{anchorX:t?n?"left":"right":n?"right":"left",anchorY:"middle",fontSize:.05,color:U,"material-depthTest":!1,rotation:[0,n?Math.PI:0,0],position:[t?-.07:.07,0,0],children:(0,m.SB)(o[1][Math.floor((_[1]-1)*i*F)],u[1])},"text_".concat(i))]},"yGroup_".concat(i))),(0,r.jsxs)("group",{rotation:[0,n?Math.PI:0,0],position:[t?-.25:.25,(h[0]+h[1])/2*O,0],children:[(0,r.jsx)(L.E,{anchorX:t?n?"left":"right":n?"right":"left",anchorY:"middle",fontSize:.1,color:U,"material-depthTest":!1,children:l[1]},"yTitle"),(0,r.jsxs)("group",{visible:!w,children:[C<20&&(0,r.jsx)(L.E,{anchorX:"center",anchorY:"middle",fontSize:.2,color:U,"material-depthTest":!1,position:[t==n?.2:-.2,.2,0],onClick:e=>P(e=>Math.min(e+1,20)),onPointerEnter:e=>document.body.style.cursor="pointer",onPointerLeave:e=>document.body.style.cursor="default",children:"+"},"zAdd"),C>1&&(0,r.jsx)(L.E,{anchorX:"center",anchorY:"middle",fontSize:.2,color:U,"material-depthTest":!1,position:[t==n?.2:-.2,-.2,0],onClick:e=>P(e=>Math.max(e-1,1)),onPointerEnter:e=>document.body.style.cursor="pointer",onPointerLeave:e=>document.body.style.cursor="default",children:"-"},"zSub")]})]})]})]})},ev=()=>{let{dimArrays:e,dimNames:n,dimUnits:t}=(0,d.on)((0,c.k)(e=>({dimArrays:e.dimArrays,dimNames:e.dimNames,dimUnits:e.dimUnits}))),{plotType:a}=(0,d.Ws)((0,c.k)(e=>({plotType:e.plotType}))),{hideAxis:o,hideAxisControls:l}=(0,d.qi)((0,c.k)(e=>({hideAxis:e.hideAxis,hideAxisControls:e.hideAxisControls}))),u=e.map(e=>e.length),f=e.length-1,x=e.length-2,[p,h]=(0,s.useState)(7),[g,y]=(0,s.useState)(7),v=(0,s.useMemo)(()=>u[x]/u[f],[u]),z=(0,S.$m)("--text-plot"),b=(0,s.useMemo)(()=>{if(z)return new i.Q1f(z).getHex()},[z]),w=(0,s.useMemo)(()=>new ey.G({color:b||0,linewidth:2}),[b]),_=(0,s.useMemo)(()=>{let e=new eh.n().setPositions([-1.025,0,0,1.025,0,0]);return new eg.b(e,w)},[w]),k=(0,s.useMemo)(()=>{let e=new eh.n().setPositions([0,-v-.025,0,0,v+.025,0]);return new eg.b(e,w)},[v,w]),D=(0,s.useMemo)(()=>{let e=new eh.n().setPositions([0,0,0,0,0,.05]);return new eg.b(e,w)},[w]),C=p/(p-1),P=1/(p-1),I=g/(g-1),M=1/(g-1);return(0,r.jsxs)("group",{visible:"flat"==a&&!o,children:[(0,r.jsxs)("group",{position:[0,-v-.025,0],rotation:[Math.PI/2,0,0],children:[(0,r.jsx)("primitive",{object:_},"xLine"),Array(p).fill(null).map((n,i)=>(0,r.jsxs)("group",{position:[-1+i*C/(p/2),0,0],children:[(0,r.jsx)("primitive",{object:D.clone(),rotation:[0,0,0]},i),(0,r.jsx)(L.E,{anchorX:"center",anchorY:"top",fontSize:.05,color:b,"material-depthTest":!1,rotation:[-Math.PI/2,0,0],position:[0,0,.05],children:(0,m.SB)(e[f][Math.floor((u[f]-1)*i*P)],t[f])},"textX_".concat(i))]},"xGroup_".concat(i))),(0,r.jsxs)("group",{rotation:[-Math.PI/2,0,0],position:[0,0,.2],children:[(0,r.jsx)(L.E,{anchorX:"center",anchorY:"top",fontSize:.1,color:b,"material-depthTest":!1,children:n[f]},"xTitle"),(0,r.jsxs)("group",{visible:!l,children:[p<20&&(0,r.jsx)(L.E,{anchorX:"center",anchorY:"middle",fontSize:.15,color:b,"material-depthTest":!1,position:[.2,-.15,0],onClick:e=>h(e=>Math.min(e+1,20)),onPointerEnter:e=>document.body.style.cursor="pointer",onPointerLeave:e=>document.body.style.cursor="default",children:"+"},"xAdd"),p>1&&(0,r.jsx)(L.E,{anchorX:"center",anchorY:"middle",fontSize:.15,color:b,"material-depthTest":!1,position:[-.2,-.15,0],onClick:e=>h(e=>Math.max(e-1,1)),onPointerEnter:e=>document.body.style.cursor="pointer",onPointerLeave:e=>document.body.style.cursor="default",children:"-"},"xSub")]})]})]}),(0,r.jsxs)("group",{position:[-1.025,0,0],children:[(0,r.jsx)("primitive",{object:k},"yLine"),Array(g).fill(null).map((n,i)=>(0,r.jsxs)("group",{position:[0,-v+i*I/(g/2)*v,0],rotation:[0,0,Math.PI],children:[(0,r.jsx)("primitive",{object:D.clone(),rotation:[0,Math.PI/2,0]},i),(0,r.jsx)(L.E,{anchorX:"right",anchorY:"middle",fontSize:.05,color:b,"material-depthTest":!1,rotation:[0,0,-Math.PI],position:[.07,0,0],children:(0,m.SB)(e[x][Math.floor((u[x]-1)*i*M)],t[x])},"text_".concat(i))]},"yGroup_".concat(i))),(0,r.jsxs)("group",{rotation:[0,0,0],position:[-.25,0,0],children:[(0,r.jsx)(L.E,{anchorX:"right",anchorY:"middle",fontSize:.1,color:b,"material-depthTest":!1,children:n[x]},"yTitle"),(0,r.jsxs)("group",{visible:!l,children:[g<20&&(0,r.jsx)(L.E,{anchorX:"center",anchorY:"middle",fontSize:.15,color:b,"material-depthTest":!1,position:[-.1,.2,0],onClick:e=>y(e=>Math.min(e+1,20)),onPointerEnter:e=>document.body.style.cursor="pointer",onPointerLeave:e=>document.body.style.cursor="default",children:"+"},"zAdd"),g>1&&(0,r.jsx)(L.E,{anchorX:"center",anchorY:"middle",fontSize:.15,color:b,"material-depthTest":!1,position:[-.1,-.2,0],onClick:e=>y(e=>Math.max(e-1,1)),onPointerEnter:e=>document.body.style.cursor="pointer",onPointerLeave:e=>document.body.style.cursor="default",children:"-"},"zSub")]})]})]})]})},ez=()=>{let[e,n]=(0,s.useState)(!1),[t,i]=(0,s.useState)(!1),[a,o]=(0,s.useState)(!1),{isFlat:l}=(0,d.on)((0,c.k)(e=>({isFlat:e.isFlat})));return(0,N.D)(r=>{let{camera:l}=r,s=Math.abs(l.rotation.z)>Math.PI/2;e!==s&&n(s);let u=l.rotation.z>0&&l.rotation.x<0||l.rotation.z<=0&&l.rotation.x>0;t!==u&&i(u);let d=l.rotation.x>0||l.position.y<=0;a!==d&&o(d)}),(0,r.jsxs)(r.Fragment,{children:[!l&&(0,r.jsx)(eS,{flipX:e,flipY:t,flipDown:a}),(0,r.jsx)(ev,{})]})};var eb=t(9341);function ew(e){let{className:n,...t}=e;return(0,r.jsx)("div",{"data-slot":"table-container",className:"relative w-full overflow-x-auto",children:(0,r.jsx)("table",{"data-slot":"table",className:(0,b.cn)("w-full caption-bottom text-sm",n),...t})})}function e_(e){let{className:n,...t}=e;return(0,r.jsx)("tbody",{"data-slot":"table-body",className:(0,b.cn)("[&_tr:last-child]:border-0",n),...t})}function ek(e){let{className:n,...t}=e;return(0,r.jsx)("tr",{"data-slot":"table-row",className:(0,b.cn)("hover:bg-muted/50 data-[state=selected]:bg-muted border-b transition-colors",n),...t})}function eD(e){let{className:n,...t}=e;return(0,r.jsx)("td",{"data-slot":"table-cell",className:(0,b.cn)("p-2 align-middle whitespace-nowrap [&:has([role=checkbox])]:pr-0 [&>[role=checkbox]]:translate-y-[2px]",n),...t})}var eC=t(4716);function eP(e){let{className:n,children:t,...i}=e;return(0,r.jsxs)(eC.bL,{"data-slot":"scroll-area",className:(0,b.cn)("relative",n),...i,children:[(0,r.jsx)(eC.LM,{"data-slot":"scroll-area-viewport",className:"focus-visible:ring-ring/50 size-full rounded-[inherit] transition-[color,box-shadow] outline-none focus-visible:ring-[3px] focus-visible:outline-1",children:t}),(0,r.jsx)(eI,{}),(0,r.jsx)(eC.OK,{})]})}function eI(e){let{className:n,orientation:t="vertical",...i}=e;return(0,r.jsx)(eC.VM,{"data-slot":"scroll-area-scrollbar",orientation:t,className:(0,b.cn)("flex touch-none p-px transition-colors select-none","vertical"===t&&"h-full w-2.5 border-l border-l-transparent","horizontal"===t&&"h-2.5 flex-col border-t border-t-transparent",n),...i,children:(0,r.jsx)(eC.lr,{"data-slot":"scroll-area-thumb",className:"bg-border relative flex-1 rounded-full"})})}var eM=t(489),ej=t(1950),eB=t(355);function eO(){let{variables:e,zMeta:n,setVariable:t}=(0,d.on)((0,c.k)(e=>({variables:e.variables,zMeta:e.zMeta,setVariable:e.setVariable}))),[i,a]=(0,s.useState)(""),[o,l]=(0,s.useState)(null),[u,f]=(0,s.useState)(!1),m=(0,s.useMemo)(()=>{let n=i.toLowerCase().trim();return n?e.filter(e=>e.toLowerCase().includes(n)):e},[i,e]);return(0,r.jsx)("div",{className:"min-h-screen w-full flex items-start justify-center pt-[8vh] p-0 relative z-1",children:(0,r.jsxs)(eb.Zp,{className:"w-full max-w-full md:max-w-[80%] shadow-xl rounded-2xl border-0 bg-transparent",children:[(0,r.jsx)(eb.aR,{className:"gap-3",children:(0,r.jsxs)("div",{className:"flex items-center gap-2 justify-center max-w-[240px] md:max-w-sm mx-auto",children:[(0,r.jsx)(eM.p,{placeholder:"Search variable...",value:i,onChange:e=>a(e.target.value),className:"flex-1"}),(0,r.jsx)(v.$,{variant:"secondary",onClick:()=>a(""),children:"Clear"})]})}),(0,r.jsx)(eb.Wu,{children:(0,r.jsx)(eP,{className:"h-[65vh] rounded-md border-0",children:(0,r.jsx)(ew,{children:(0,r.jsx)(e_,{children:m.length>0?m.map((e,t)=>(0,r.jsx)(ek,{className:"hover:bg-gray",children:(0,r.jsx)(eD,{className:"text-center",children:(0,r.jsxs)(eB.lG,{open:u&&(null==o?void 0:o.name)===e,onOpenChange:e=>{e||(f(!1),l(null))},children:[(0,r.jsx)(eB.zM,{asChild:!0,children:(0,r.jsx)(v.$,{variant:"ghost",className:"w-full text-center text-lg cursor-pointer",onClick:()=>{l(null==n?void 0:n.find(n=>n.name===e)),f(!0)},children:e})}),(0,r.jsxs)(eB.Cf,{"aria-describedby":"Data information for selected variable","aria-description":"Data information for selected variable",className:"max-w-[85%] md:max-w-2xl max-h-[80vh] overflow-y-auto",children:[(0,r.jsx)(eB.L3,{className:"text-center text-lg font-semibold",children:e}),(0,r.jsx)("div",{className:"mt-4",children:o&&(0,r.jsx)(ej.A,{meta:o,setShowMeta:f,noCard:!0})})]})]})})},t)):(0,r.jsx)(ek,{children:(0,r.jsx)(eD,{className:"text-center text-muted-foreground py-8",children:i?"No variables found matching your search.":"No variables available."})})})})})})]})})}i.l2R.enabled=!0;let eA=function(){let{initStore:e,timeSeries:n,variable:t,metadata:i,plotOn:u,setZMeta:f,setVariables:m,setPlotOn:x,setTitleDescription:p,titleDescription:h}=(0,d.on)((0,c.k)(e=>({initStore:e.initStore,timeSeries:e.timeSeries,variable:e.variable,metadata:e.metadata,plotOn:e.plotOn,setZMeta:e.setZMeta,setVariables:e.setVariables,setPlotOn:e.setPlotOn,setTitleDescription:e.setTitleDescription,titleDescription:e.titleDescription}))),{setMaxTextureSize:g}=(0,d.Ws)((0,c.k)(e=>({setMaxTextureSize:e.setMaxTextureSize}))),{currentStore:y,setCurrentStore:v}=(0,d.SZ)((0,c.k)(e=>({currentStore:e.currentStore,setCurrentStore:e.setCurrentStore})));(0,s.useEffect)(()=>{v((0,l.Oe)(e))},[e,v]);let z=(0,s.useMemo)(()=>new l.Y5(y),[y]);return(0,s.useEffect)(()=>{let n=!0;(0,o.tz)(y,e).then(e=>{n&&p(e)});let t=(0,o.Tk)(y),r=(0,o.Bi)(t);return t.then(e=>f(e)),r.then(e=>m(e)),()=>{n=!1}},[y,e,f,m,p]),(0,s.useEffect)(()=>{let e=new a.WebGLRenderer,n=e.getContext();return g(n.getParameter(n.MAX_TEXTURE_SIZE)),()=>{e.dispose()}},[g]),(0,r.jsxs)(r.Fragment,{children:[(0,r.jsx)(S.oU,{}),(0,r.jsx)(S.$D,{}),!u&&(0,r.jsx)(S.Fp,{}),(0,r.jsx)(S.Rh,{}),(0,r.jsx)(S.wC,{}),"Default"===t&&(0,r.jsx)(eO,{}),"Default"!=t&&(0,r.jsx)(eo,{ZarrDS:z}),i&&(0,r.jsx)(S.OS,{data:i}),Object.keys(n).length>=1&&(0,r.jsx)(Y,{})]})}},6469:()=>{},9519:()=>{}},e=>{e.O(0,[248,577,197,669,813,444,755,858,56,667,800,645,812,959,152,195,499,100,970,984,65,705,127,434,212,246,358],()=>e(e.s=1894)),_N_E=e.O()}]);