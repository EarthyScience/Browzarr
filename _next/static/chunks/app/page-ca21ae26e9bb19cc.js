(self.webpackChunk_N_E=self.webpackChunk_N_E||[]).push([[974],{1536:(e,n,t)=>{Promise.resolve().then(t.bind(t,4090))},1610:()=>{},3583:()=>{},4090:(e,n,t)=>{"use strict";t.d(n,{default:()=>nl});var r={};t.r(r),t.d(r,{CUMSUM3D:()=>em,CUMSUMReduction:()=>Q,Correlation2D:()=>ex,CorrelationConvolution:()=>ed,CovarianceConvolution:()=>ef,CovarianceReduction:()=>K,LinearSlopeReduction:()=>$,MaxConvolution:()=>ei,MaxConvolution2D:()=>eu,MaxReduction:()=>W,MeanConvolution:()=>et,MeanConvolution2D:()=>eo,MeanReduction:()=>q,MinConvolution:()=>er,MinConvolution2D:()=>el,MinReduction:()=>Z,StDevConvolution:()=>ea,StDevConvolution2D:()=>es,StDevReduction:()=>H,TwoVarLinearSlopeConvolution:()=>ec,TwoVarLinearSlopeReduction:()=>J});var i={};t.r(i),t.d(i,{CUMSUM3D:()=>eL,CUMSUMReduction:()=>ez,Correlation2D:()=>eU,CorrelationConvolution:()=>eA,CovarianceConvolution:()=>ej,CovarianceReduction:()=>e_,LinearSlopeReduction:()=>eh,MaxConvolution:()=>eC,MaxConvolution2D:()=>eB,MaxReduction:()=>eg,MeanConvolution:()=>eD,MeanConvolution2D:()=>eP,MeanReduction:()=>ey,MinConvolution:()=>eI,MinConvolution2D:()=>eO,MinReduction:()=>eS,StDevConvolution:()=>eM,StDevConvolution2D:()=>eY,StDevReduction:()=>ev,TwoVarLinearSlopeConvolution:()=>eX,TwoVarLinearSlopeReduction:()=>eb});var a=t(3013),o=t(597),l=t(5436),u=t(5999),s=t(9841);let d=" // by Jeran Poehls\r\n\r\nout vec3 vOrigin;\r\nout vec3 vDirection;\r\nout vec3 aPosition;\r\n\r\nout vec2 Vuv;\r\n\r\nvoid main() {\r\n    vec4 worldPos = modelViewMatrix * vec4( position, 1.0 );\r\n\r\n    aPosition = position; //Pass out position for sphere frag\r\n    vOrigin = vec3( inverse( modelMatrix ) * vec4( cameraPosition, 1.0 ) ).xyz;\r\n    vDirection = position - vOrigin;\r\n    Vuv = uv;\r\n    gl_Position = projectionMatrix * worldPos;\r\n}";var f=t(2980),c=t(2583),m=t(979);let x=e=>{let{volTexture:n}=e,{shape:t,colormap:r,flipY:i}=(0,f.on)((0,c.k)(e=>({shape:e.shape,colormap:e.colormap,flipY:e.flipY}))),{valueRange:l,xRange:u,yRange:x,zRange:p,quality:y,animProg:S,cScale:g,cOffset:v,useFragOpt:z,transparency:h,nanTransparency:b,nanColor:_,vTransferRange:w,vTransferScale:k}=(0,f.Ws)((0,c.k)(e=>({valueRange:e.valueRange,xRange:e.xRange,yRange:e.yRange,zRange:e.zRange,quality:e.quality,animProg:e.animProg,cScale:e.cScale,cOffset:e.cOffset,useFragOpt:e.useFragOpt,transparency:e.transparency,nanTransparency:e.nanTransparency,nanColor:e.nanColor,vTransferRange:e.vTransferRange,vTransferScale:e.vTransferScale}))),D=t.y/t.x,I=(0,s.useMemo)(()=>new o.BKk({glslVersion:o.Wdf,uniforms:{map:{value:n},cmap:{value:r},cOffset:{value:v},cScale:{value:g},threshold:{value:new o.I9Y(l[0],l[1])},scale:{value:t},flatBounds:{value:new o.IUQ(-u[1],-u[0],p[0],p[1])},vertBounds:{value:new o.I9Y(x[0]*D,x[1]*D)},steps:{value:y},animateProg:{value:S},transparency:{value:h},opacityMag:{value:k},useClipScale:{value:w},nanAlpha:{value:1-b},nanColor:{value:new o.Q1f(_)}},vertexShader:d,fragmentShader:z?"// This is an optimized version of the original Volumetric shader\r\n\r\nprecision highp float;\r\nprecision highp sampler3D;\r\n\r\nin vec3 vOrigin;\r\nin vec3 vDirection;\r\n\r\nout vec4 color;\r\n\r\nuniform sampler3D map;\r\nuniform sampler2D cmap;\r\n\r\nuniform float cOffset;\r\nuniform float cScale;\r\nuniform vec3 scale;\r\nuniform vec2 threshold;\r\nuniform float steps;\r\nuniform vec4 flatBounds;\r\nuniform vec2 vertBounds;\r\nuniform float animateProg;\r\nuniform float transparency;\r\nuniform float nanAlpha;\r\nuniform vec3 nanColor;\r\n\r\nvec2 hitBox(vec3 orig, vec3 dir) {\r\n    vec3 box_min = vec3(-(scale * 0.5));\r\n    vec3 box_max = vec3(scale * 0.5);\r\n    vec3 inv_dir = 1.0 / dir;\r\n    vec3 tmin_tmp = (box_min - orig) * inv_dir;\r\n    vec3 tmax_tmp = (box_max - orig) * inv_dir;\r\n    vec3 tmin = min(tmin_tmp, tmax_tmp);\r\n    vec3 tmax = max(tmin_tmp, tmax_tmp);\r\n    float t0 = max(tmin.x, max(tmin.y, tmin.z));\r\n    float t1 = min(tmax.x, min(tmax.y, tmax.z));\r\n    return vec2(t0, t1);\r\n}\r\n\r\nfloat sample1( vec3 p ) {\r\n    return texture( map, p ).r;\r\n}\r\n\r\n#define epsilon 0.0001\r\n\r\nvoid main() {\r\n    vec3 rayDir = normalize(vDirection);\r\n    vec2 bounds = hitBox(vOrigin, rayDir);\r\n\r\n    if (bounds.x > bounds.y) discard;\r\n\r\n    bounds.x = max(bounds.x, 0.0);\r\n\r\n    vec3 p = vOrigin + bounds.x * rayDir;\r\n    vec3 inc = 1.0 / abs(rayDir);\r\n\r\n    //Step Sizes\r\n    float fineDelta = min(inc.x, min(inc.y, inc.z)) / steps;\r\n\r\n    float coarseDelta = min(inc.x, min(inc.y, inc.z))/50.;\r\n\r\n    float delta = fineDelta;\r\n\r\n    vec4 accumColor = vec4(0.0);\r\n    float alphaAcc = 0.0;\r\n\r\n    float t = bounds.x;\r\n    int countdown = 0;\r\n    bool useCoarseStep = false;\r\n\r\n    while (t < bounds.y) {\r\n        vec3 p = vOrigin + rayDir * t;\r\n        \r\n        // --- Boundary checks ---\r\n        if (p.x < flatBounds.x || p.x > flatBounds.y ||\r\n            p.z < flatBounds.z || p.z > flatBounds.w ||\r\n            p.y < vertBounds.x || p.y > vertBounds.y) {\r\n\r\n            t += useCoarseStep ? coarseDelta : fineDelta;\r\n            continue;\r\n        }\r\n\r\n        vec3 texCoord = p / scale + 0.5;\r\n        texCoord.z = mod(texCoord.z + animateProg, 1.0001);\r\n        float d = sample1(texCoord);\r\n\r\n        bool cond = nanAlpha == 0. ? (d > threshold.x) && (d < threshold.y) : (d > threshold.x) && (d < threshold.y+.01); //We skip over nans if the transparency is enabled\r\n        \r\n        if (cond) {\r\n            // Hit something interesting - switch to fine stepping\r\n            if (useCoarseStep) {\r\n                useCoarseStep = false;\r\n                countdown = 40;\r\n                // Step back to ensure we don't miss the boundary\r\n                t -= coarseDelta;\r\n                continue;\r\n            }\r\n            if (d == 1.){\r\n                accumColor.rgb += (1.0 - alphaAcc) * pow(nanAlpha, 5.) * nanColor.rgb;\r\n                alphaAcc += pow(nanAlpha, 5.);\r\n            }\r\n            else{\r\n                float sampLoc = (d - 0.5)*cScale + 0.5;\r\n                sampLoc = min(sampLoc+cOffset,0.99);\r\n                vec4 col = texture(cmap, vec2(sampLoc, 0.5));\r\n                float alpha = pow(max(sampLoc, 0.001), transparency);\r\n                accumColor.rgb += (1.0 - alphaAcc) * alpha * col.rgb;\r\n                alphaAcc += alpha * (1.0 - alphaAcc);\r\n            }      \r\n\r\n            if (alphaAcc >= 1.0) break;\r\n            \r\n            t += fineDelta;\r\n        }\r\n        else {\r\n            // Nothing interesting here\r\n            if (countdown > 0) {\r\n                countdown--;\r\n                t += fineDelta; // Continue with fine steps while countdown > 0\r\n            } else {\r\n                useCoarseStep = true;\r\n                t += coarseDelta; // Switch to coarse steps\r\n            }\r\n        }\r\n    }\r\n    accumColor.a = alphaAcc; // Set the final accumulated alpha\r\n    color = accumColor;\r\n    if (color.a == 0.0) discard;\r\n}\r\n":"// by Jeran Poehls\r\nprecision highp float;\r\nprecision highp sampler3D;\r\n\r\nin vec3 vOrigin;\r\nin vec3 vDirection;\r\n\r\nout vec4 color;\r\n\r\nuniform sampler3D map;\r\nuniform sampler2D cmap;\r\n\r\nuniform float cOffset;\r\nuniform float cScale;\r\nuniform vec3 scale;\r\nuniform vec2 threshold;\r\nuniform float steps;\r\nuniform vec4 flatBounds;\r\nuniform vec2 vertBounds;\r\nuniform float animateProg;\r\nuniform float transparency;\r\nuniform float nanAlpha;\r\nuniform vec3 nanColor;\r\nuniform float opacityMag;\r\nuniform bool useClipScale;\r\n\r\n\r\nvec2 hitBox(vec3 orig, vec3 dir) {\r\n    vec3 box_min = vec3(-(scale * 0.5));\r\n    vec3 box_max = vec3(scale * 0.5);\r\n    vec3 inv_dir = 1.0 / dir;\r\n    vec3 tmin_tmp = (box_min - orig) * inv_dir;\r\n    vec3 tmax_tmp = (box_max - orig) * inv_dir;\r\n    vec3 tmin = min(tmin_tmp, tmax_tmp);\r\n    vec3 tmax = max(tmin_tmp, tmax_tmp);\r\n    float t0 = max(tmin.x, max(tmin.y, tmin.z));\r\n    float t1 = min(tmax.x, min(tmax.y, tmax.z));\r\n    return vec2(t0, t1);\r\n}\r\n\r\nfloat sample1( vec3 p ) {\r\n    return texture( map, p ).r;\r\n}\r\n\r\n#define epsilon 0.0001\r\n\r\nvoid main() {\r\n    vec3 rayDir = normalize(vDirection);\r\n    vec2 bounds = hitBox(vOrigin, rayDir);\r\n\r\n    if (bounds.x > bounds.y) discard;\r\n\r\n    bounds.x = max(bounds.x, 0.0);\r\n\r\n    vec3 p = vOrigin + bounds.x * rayDir;\r\n    vec3 inc = 1.0 / abs(rayDir);\r\n    float delta = min(inc.x, min(inc.y, inc.z));\r\n    delta /= steps;\r\n    vec4 accumColor = vec4(0.0);\r\n    float alphaAcc = 0.0;\r\n\r\n    for (float t = bounds.x; t < bounds.y; t += delta) {\r\n        p = vOrigin + rayDir * t;\r\n        if (p.x > -flatBounds.x || p.x < -flatBounds.y) { \r\n            continue;\r\n        }\r\n        if (-p.z > -flatBounds.z || -p.z < -flatBounds.w) {\r\n            continue;\r\n        }\r\n        if (p.y < vertBounds.x || p.y > vertBounds.y) {\r\n            continue;\r\n        }\r\n\r\n        vec3 texCoord = p / scale + 0.5;\r\n        texCoord.z = mod(texCoord.z + animateProg, 1.0001);\r\n        float d = sample1(texCoord);\r\n\r\n        bool cond = nanAlpha == 0. ? (d >= threshold.x) && (d <= threshold.y) : (d >= threshold.x) && (d <= threshold.y); //We skip over nans if the transparency is enabled\r\n        \r\n        if (cond) {\r\n            if (d == 1.){\r\n                accumColor.rgb += (1.0 - alphaAcc) * pow(nanAlpha, 5.) * nanColor.rgb;\r\n                alphaAcc += pow(nanAlpha, 5.);\r\n            }\r\n            else{\r\n                float sampLoc = (d - 0.5)*cScale + 0.5;\r\n                sampLoc = min(sampLoc+cOffset,0.99);\r\n                vec4 col = texture(cmap, vec2(sampLoc, 0.5));\r\n                float alpha;\r\n                if (useClipScale){\r\n                    float normalizedOpacity = clamp((sampLoc - threshold.x) / (threshold.y - threshold.x), 0.0, 1.0);\r\n                    alpha = pow(max(normalizedOpacity, 0.001), transparency*opacityMag);\r\n                } else {\r\n                    alpha = pow(max(sampLoc, 0.001), transparency*opacityMag);\r\n                }\r\n                accumColor.rgb += (1.0 - alphaAcc) * alpha * col.rgb;\r\n                alphaAcc += alpha * (1.0 - alphaAcc);\r\n            }      \r\n\r\n            if (alphaAcc >= 1.0) break;\r\n        }\r\n    }\r\n\r\n    accumColor.a = alphaAcc; // Set the final accumulated alpha\r\n    color = accumColor;\r\n    if (color.a == 0.0) discard;\r\n}\r\n",transparent:!0,blending:o.NTi,depthWrite:!1,side:o.hsX}),[z]),C=(0,s.useMemo)(()=>new o.WBB(2,4),[]);return(0,s.useEffect)(()=>{if(I){let e=I.uniforms;e.map.value=n,e.cmap.value=r,e.cOffset.value=v,e.cScale.value=g,e.threshold.value.set(l[0],l[1]),e.scale.value=t,e.flatBounds.value.set(-u[1],-u[0],p[0],p[1]),e.vertBounds.value.set(x[0]*D,x[1]*D),e.steps.value=y,e.animateProg.value=S,e.transparency.value=h,e.nanAlpha.value=1-b,e.nanColor.value.set(_),e.opacityMag.value=k,e.useClipScale.value=w,(0,m.m)()}},[n,t,r,v,g,l,u,x,p,D,y,S,h,b,_,k,w]),(0,a.jsx)(a.Fragment,{children:(0,a.jsx)("mesh",{geometry:C,scale:[1,i?-1:1,1],children:(0,a.jsx)("primitive",{attach:"material",object:I})})})};var p=t(3541),y=t(3947);let S=e=>{let{ZarrDS:n}=e,{setTimeSeries:t,setPlotDim:r,setDimCoords:i,updateTimeSeries:l,updateDimCoords:u}=(0,f.on)((0,c.k)(e=>({setTimeSeries:e.setTimeSeries,setPlotDim:e.setPlotDim,setDimCoords:e.setDimCoords,updateTimeSeries:e.updateTimeSeries,updateDimCoords:e.updateDimCoords}))),{analysisMode:d,analysisArray:m}=(0,f.r2)((0,c.k)(e=>({analysisMode:e.analysisMode,analysisArray:e.analysisArray}))),{shape:x,dataShape:S,strides:g,dimArrays:v,dimNames:z,dimUnits:h}=(0,f.on)((0,c.k)(e=>({shape:e.shape,dataShape:e.dataShape,strides:e.strides,dimArrays:e.dimArrays,dimNames:e.dimNames,dimUnits:e.dimUnits}))),{selectTS:b,getColorIdx:_,incrementColorIdx:w}=(0,f.Ws)((0,c.k)(e=>({selectTS:e.selectTS,getColorIdx:e.getColorIdx,incrementColorIdx:e.incrementColorIdx}))),k=(0,s.useRef)(0),D=(0,s.useMemo)(()=>new o.iNn(1,1,1),[]);return(0,s.useEffect)(()=>()=>{D.dispose()},[]),(0,a.jsx)(a.Fragment,{children:(0,a.jsx)("mesh",{geometry:D,scale:x,onClick:e=>{e.stopPropagation(),e.intersections.length>0&&b&&function(e){e.point;let a=e.uv,o=e.normal,s=(0,p._8)(o);if(s!=k.current&&(t({}),i({})),k.current=s,n){var f,c;let e=(0,p.PE)({data:d?m:(0,p.Td)(),shape:S,stride:g},{uv:a,normal:o}),n=o.toArray().map((e,n)=>Math.abs(e)>0?n:null).filter(e=>null!==e);r(2-n[0]);let t=(0,p.jT)({normal:o,uv:a}).map((e,n)=>e?v[n][Math.round(e*v[n].length)]:null),i=z.filter((e,n)=>null!==t[n]),s=h.filter((e,n)=>null!==t[n]);t=t.filter(e=>null!==e);let x="".concat(t[0],"_").concat(t[1]);l({[x]:{color:(0,y.md)(_()/10,"Paired"),data:e}}),w(),u({[x]:{first:{name:i[0],loc:null!=(f=t[0])?f:0,units:s[0]},second:{name:i[1],loc:null!=(c=t[1])?c:0,units:s[1]},plot:{units:h[2-n[0]]}}})}}(e.intersections[0])},children:(0,a.jsx)("meshBasicMaterial",{transparent:!0,opacity:0})})})},g=e=>{let{dimensions:n,ZarrDS:t,setters:r}=e,{width:i,height:o,depth:l}=n,{setPoints:u,setStride:d,setDimWidth:m}=r,x=(0,f.Ws)(e=>e.selectTS),S=i/o,g=l/o,{dimArrays:v,dimUnits:z,dimNames:h,strides:b,dataShape:_,setPlotDim:w,setTimeSeries:k,updateTimeSeries:D,setDimCoords:I,updateDimCoords:C}=(0,f.on)((0,c.k)(e=>({dimArrays:e.dimArrays,dimUnits:e.dimUnits,dimNames:e.dimNames,strides:e.strides,dataShape:e.dataShape,setPlotDim:e.setPlotDim,setTimeSeries:e.setTimeSeries,updateTimeSeries:e.updateTimeSeries,setDimCoords:e.setDimCoords,updateDimCoords:e.updateDimCoords}))),{analysisMode:M,analysisArray:P}=(0,f.r2)((0,c.k)(e=>({analysisMode:e.analysisMode,analysisArray:e.analysisArray}))),O=(0,s.useRef)(null),{timeScale:B,getColorIdx:Y,incrementColorIdx:A}=(0,f.Ws)((0,c.k)(e=>({timeScale:e.timeScale,getColorIdx:e.getColorIdx,incrementColorIdx:e.incrementColorIdx})));return(0,a.jsxs)("mesh",{scale:[S,1,g*B],onClick:function(e){if(!x)return;let n=e.uv,r=e.normal,a=(0,p._8)(r);if(a!=O.current&&(k({}),I({}),u({})),O.current=a,t){var s,f;let e=(0,p.PE)({data:M?P:(0,p.Td)(),shape:_,stride:b},{uv:n,normal:r}),t=r.toArray().map((e,n)=>Math.abs(e)>0?n:null).filter(e=>null!==e);w(2-t[0]);let a=(0,p.jT)({normal:r,uv:n}),c=a.map((e,n)=>e?v[n][Math.round(e*v[n].length-.5)]:null),x=h.filter((e,n)=>null!==c[n]),S=z.filter((e,n)=>null!==c[n]);c=c.filter(e=>null!==e);let g="".concat(c[0],"_").concat(c[1]),k={color:(0,y.md)(Y()/10,"Paired"),data:e};A(),D({[g]:k}),C({[g]:{first:{name:x[0],loc:null!=(s=c[0])?s:0,units:S[0]},second:{name:x[1],loc:null!=(f=c[1])?f:0,units:S[1]},plot:{units:z[2-t[0]]}}});let I=[l,o,i].filter((e,n)=>null!=a[n]),O=[l,o,i].filter((e,n)=>null==a[n]),B=a.filter(e=>null!=e),j=b.filter((e,n)=>null!=a[n]),X=Math.round(B[0]*I[0]-.5),L=Math.round(B[1]*I[1]-.5),U=X*j[0]+L*j[1],V=b.filter((e,n)=>null==a[n]);m(O[0]),u(e=>({...{[g]:U},...e})),d(V[0])}},children:[(0,a.jsx)("boxGeometry",{}),(0,a.jsx)("meshBasicMaterial",{transparent:!0,opacity:0})]})},v=e=>{let{textures:n,ZarrDS:t}=e,{texture:r,colormap:i}=n,{timeSeries:l,flipY:u}=(0,f.on)((0,c.k)(e=>({timeSeries:e.timeSeries,flipY:e.flipY}))),{scalePoints:d,scaleIntensity:m,pointSize:x,cScale:p,cOffset:y,valueRange:S,animProg:v,selectTS:z,timeScale:h,xRange:b,yRange:_,zRange:w}=(0,f.Ws)((0,c.k)(e=>({scalePoints:e.scalePoints,scaleIntensity:e.scaleIntensity,pointSize:e.pointSize,cScale:e.cScale,cOffset:e.cOffset,valueRange:e.valueRange,animProg:e.animProg,selectTS:e.selectTS,timeScale:e.timeScale,xRange:e.xRange,yRange:e.yRange,zRange:e.zRange})));(0,f.$U)(e=>e.setError);let[k,D]=(0,s.useState)({}),[I,C]=(0,s.useState)(Array(10).fill(-1)),[M,P]=(0,s.useState)(1),[O,B]=(0,s.useState)(0);(0,s.useEffect)(()=>{let e=Object.keys(k),n=Object.keys(l),t=(e=e.filter(e=>n.includes(e))).map(e=>k[e]);C([...t,...Array(Math.max(0,10-t.length)).fill(-1)])},[l,k]);let{data:Y,width:A,height:j,depth:X}=(0,s.useMemo)(()=>r instanceof o.dYF?{data:r.image.data,width:r.image.width,height:r.image.height,depth:r.image.depth}:(console.warn("Provided texture is not a Data3DTexture"),{data:[],width:0,height:0,depth:0}),[r]),L=(0,s.useMemo)(()=>A/j,[A,j]),U=(0,s.useMemo)(()=>X/j,[X,j]),V=(0,s.useMemo)(()=>{let e=new o.LoY;e.setAttribute("value",new o.baL(Y,1));let n=X*j*A;return e.setDrawRange(0,n),e},[Y]),T=(0,s.useMemo)(()=>new o.BKk({glslVersion:o.Wdf,uniforms:{pointSize:{value:x},cmap:{value:i},cOffset:{value:y},cScale:{value:p},valueRange:{value:new o.I9Y(S[0],S[1])},scalePoints:{value:d},scaleIntensity:{value:m},startIDs:{value:I},stride:{value:M},showTransect:{value:z},dimWidth:{value:O},timeScale:{value:h},animateProg:{value:v},depthRatio:{value:U},aspectRatio:{value:L},shape:{value:new o.Pq0(X,j,A)},flatBounds:{value:new o.IUQ(b[0],b[1],w[0]*U/2,w[1]*U/2)},vertBounds:{value:new o.I9Y(_[0]/L,_[1]/L)}},vertexShader:"attribute float value;\r\n\r\nout float vValue;\r\n\r\nflat out int highlight;\r\n\r\nuniform float pointSize;\r\nuniform bool scalePoints;\r\nuniform float scaleIntensity;\r\nuniform vec2 valueRange;\r\nuniform int[10] startIDs;\r\nuniform int stride;\r\nuniform int dimWidth;\r\nuniform bool showTransect;\r\nuniform float timeScale;\r\nuniform float animateProg;\r\nuniform float depthRatio;\r\nuniform vec4 flatBounds;\r\nuniform vec2 vertBounds;\r\nuniform float aspectRatio;\r\nuniform vec3 shape;\r\n\r\nbool isValidPoint(){\r\n    for (int i = 0; i < 10; i++){\r\n        if (startIDs[i] == -1){\r\n            return false;\r\n        }\r\n        int rePos = gl_VertexID - startIDs[i];\r\n        bool isValid = rePos % stride == 0;\r\n        bool secondary = gl_VertexID < (startIDs[i] + dimWidth*stride) && gl_VertexID > startIDs[i];\r\n        isValid = isValid && secondary;\r\n        if (isValid){\r\n            return true;\r\n        }\r\n    }\r\n    return false;\r\n}\r\n\r\nvec3 computePosition(int vertexID) {\r\n    int depth = int(shape.x);\r\n    int height = int(shape.y);\r\n    int width = int(shape.z);\r\n\r\n    int sliceSize = width * height;\r\n\r\n    int z = vertexID / sliceSize;\r\n    int y = (vertexID % sliceSize) / width;\r\n    int x = vertexID % width;\r\n\r\n    float px = (float(x) / float(width - 1)) - 0.5;\r\n    float py = ((float(y) / float(height - 1)) - 0.5) / aspectRatio;\r\n    float pz = ((float(z) / float(depth - 1)) - 0.5) * depthRatio;\r\n\r\n    return vec3(px * 2.0, py * 2.0, pz);\r\n}\r\n\r\nvoid main() {\r\n    vValue = float(value)/255.;\r\n    vec3 scaledPos = computePosition(gl_VertexID);\r\n\r\n    scaledPos.z += depthRatio/2.;\r\n    scaledPos.z = mod(scaledPos.z + animateProg*depthRatio, depthRatio);\r\n    scaledPos.z -= depthRatio/2.;\r\n\r\n    scaledPos.z *= timeScale;\r\n    gl_Position = projectionMatrix * modelViewMatrix * vec4(scaledPos, 1.0);\r\n\r\n    float pointScale = pointSize/gl_Position.w;\r\n    pointScale = scalePoints ? pointScale*pow(vValue,scaleIntensity) : pointScale;\r\n\r\n    bool isValid = isValidPoint();\r\n    highlight = isValid ? 1 : 0;\r\n    \r\n    if (value == 255. || (pointScale*gl_Position.w < 0.75 && scalePoints)){ //Hide points that are invisible or get too small when scalled\r\n        gl_Position = vec4(2.0, 2.0, 2.0, 1.0);\r\n    }\r\n\r\n    if (vValue < valueRange.x || vValue > valueRange.y){ //Hide points that are outside of value range\r\n        gl_Position = vec4(2.0, 2.0, 2.0, 1.0);\r\n    }\r\n\r\n    vec2 scaledZBounds = vec2(flatBounds.z,  flatBounds.w) * vec2(timeScale);\r\n    bool xCheck = scaledPos.x < flatBounds.x || scaledPos.x > flatBounds.y;\r\n    bool zCheck = scaledPos.z < scaledZBounds.x || scaledPos.z > scaledZBounds.y;\r\n    bool yCheck = scaledPos.y < vertBounds.x || scaledPos.y> vertBounds.y;\r\n\r\n    if (xCheck || zCheck || yCheck){ //Hide points that are clipped\r\n        gl_Position = vec4(2.0, 2.0, 2.0, 1.0);\r\n    }\r\n    \r\n    if (showTransect){\r\n        gl_PointSize = isValid ? max(pointScale*5. , pointScale+80./gl_Position.w) : pointScale;\r\n    }\r\n    else{\r\n        gl_PointSize =  pointScale;\r\n    }\r\n\r\n}\r\n",fragmentShader:"out vec4 Color;\r\n\r\nin float vValue;\r\nflat in int highlight;\r\n\r\n\r\nuniform sampler2D cmap;\r\nuniform float cScale;\r\nuniform float cOffset;\r\nuniform bool showTransect;\r\n\r\nvoid main() {\r\n    float sampLoc = vValue == 1. ? vValue : (vValue - 0.5)*cScale + 0.5;\r\n    sampLoc = vValue == 1. ? vValue : min(sampLoc+cOffset,0.99);\r\n    vec4 color = texture(cmap, vec2(sampLoc, 0.5));\r\n    color.a = 1.;\r\n    Color = color;\r\n    if (showTransect){\r\n        Color = highlight == 1 ? color : color * vec4(vec3(0.4),1.);\r\n    }\r\n    else{\r\n        Color = color;\r\n    }\r\n}\r\n",depthWrite:!0,depthTest:!0,transparent:!1,blending:o.NTi,side:o.$EB}),[]);return(0,s.useEffect)(()=>{if(T){let e=T.uniforms;e.pointSize.value=x,e.cmap.value=i,e.cOffset.value=y,e.cScale.value=p,e.valueRange.value.set(S[0],S[1]),e.scalePoints.value=d,e.scaleIntensity.value=m,e.startIDs.value=I,e.stride.value=M,e.showTransect.value=z,e.dimWidth.value=O,e.timeScale.value=h,e.animateProg.value=v,e.depthRatio.value=U,e.flatBounds.value.set(b[0],b[1],w[0]*U/2,w[1]*U/2),e.vertBounds.value.set(_[0]/L,_[1]/L)}},[x,i,y,p,S,d,m,I,M,z,v,h,U,L,b,_,w]),(0,a.jsxs)(a.Fragment,{children:[(0,a.jsx)("mesh",{scale:[1,u?-1:1,1],children:(0,a.jsx)("points",{geometry:V,material:T,frustumCulled:!1})}),(0,a.jsx)(g,{dimensions:{width:A,height:j,depth:X},ZarrDS:t,setters:{setPoints:D,setStride:P,setDimWidth:B}})]})};var z=t(5606),h=t(3098);t(7181);var b=t(5798);t(1610);var _=t(9786),w=t(5922);function k(e){let{...n}=e;return(0,a.jsx)(_.bL,{"data-slot":"dropdown-menu",...n})}function D(e){let{...n}=e;return(0,a.jsx)(_.l9,{"data-slot":"dropdown-menu-trigger",...n})}function I(e){let{className:n,sideOffset:t=4,...r}=e;return(0,a.jsx)(_.ZL,{children:(0,a.jsx)(_.UC,{"data-slot":"dropdown-menu-content",sideOffset:t,className:(0,w.cn)("bg-popover text-popover-foreground data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0 data-[state=closed]:zoom-out-95 data-[state=open]:zoom-in-95 data-[side=bottom]:slide-in-from-top-2 data-[side=left]:slide-in-from-right-2 data-[side=right]:slide-in-from-left-2 data-[side=top]:slide-in-from-bottom-2 z-50 max-h-(--radix-dropdown-menu-content-available-height) min-w-[8rem] origin-(--radix-dropdown-menu-content-transform-origin) overflow-x-hidden overflow-y-auto rounded-md border p-1 shadow-md",n),...r})})}function C(e){let{...n}=e;return(0,a.jsx)(_.YJ,{"data-slot":"dropdown-menu-group",...n})}function M(e){let{className:n,inset:t,variant:r="default",...i}=e;return(0,a.jsx)(_.q7,{"data-slot":"dropdown-menu-item","data-inset":t,"data-variant":r,className:(0,w.cn)("focus:bg-accent focus:text-accent-foreground data-[variant=destructive]:text-destructive data-[variant=destructive]:focus:bg-destructive/10 dark:data-[variant=destructive]:focus:bg-destructive/20 data-[variant=destructive]:focus:text-destructive data-[variant=destructive]:*:[svg]:!text-destructive [&_svg:not([class*='text-'])]:text-muted-foreground relative flex cursor-default items-center gap-2 rounded-sm px-2 py-1.5 text-sm outline-hidden select-none data-[disabled]:pointer-events-none data-[disabled]:opacity-50 data-[inset]:pl-8 [&_svg]:pointer-events-none [&_svg]:shrink-0 [&_svg:not([class*='size-'])]:size-4",n),...i})}function P(e){let{className:n,...t}=e;return(0,a.jsx)(_.wv,{"data-slot":"dropdown-menu-separator",className:(0,w.cn)("bg-border -mx-1 my-1 h-px",n),...t})}var O=t(8797);let B=s.memo(function(){let{showPoints:e,linePointSize:n,pointColor:t,useCustomPointColor:r,setLinePointSize:i,setPointColor:o,setUseCustomPointColor:l}=(0,f.Ws)((0,c.k)(e=>({showPoints:e.showPoints,linePointSize:e.linePointSize,pointColor:e.pointColor,useCustomPointColor:e.useCustomPointColor,setLinePointSize:e.setLinePointSize,setPointColor:e.setPointColor,setUseCustomPointColor:e.setUseCustomPointColor})));return e?(0,a.jsxs)(a.Fragment,{children:[(0,a.jsxs)("div",{className:"w-full flex items-center mb-2",children:[(0,a.jsx)("div",{className:"w-[40%]",children:(0,a.jsx)("b",{children:"Point Size"})}),(0,a.jsx)(O.A,{min:1,max:10,step:.1,value:[n],className:"flex-1 my-2",onValueChange:e=>i(e[0])})]}),(0,a.jsxs)("div",{className:"w-full flex items-center mb-2",children:[(0,a.jsx)("div",{className:"w-[40%]",children:(0,a.jsx)("b",{children:"Point Color"})}),r&&(0,a.jsx)("input",{type:"color",title:"Point Color",value:t,onChange:e=>o(e.target.value)}),(0,a.jsxs)(b.$,{className:"h-8 px-2 py-1",variant:"outline",onClick:()=>l(!r),children:["Use",r?" Browzarr Color":" Custom Color"]})]})]}):null}),Y=s.memo(function(){let{lineWidth:e,lineColor:n,useLineColor:t,lineResolution:r,useCustomColor:i,setLineWidth:o,setLineColor:l,setUseLineColor:u,setLineResolution:s,setUseCustomColor:d}=(0,f.Ws)((0,c.k)(e=>({lineWidth:e.lineWidth,lineColor:e.lineColor,useLineColor:e.useLineColor,lineResolution:e.lineResolution,useCustomColor:e.useCustomColor,setLineWidth:e.setLineWidth,setLineColor:e.setLineColor,setUseLineColor:e.setUseLineColor,setLineResolution:e.setLineResolution,setUseCustomColor:e.setUseCustomColor})));return(0,a.jsxs)(a.Fragment,{children:[(0,a.jsxs)("div",{className:"w-full flex items-center mb-2",children:[(0,a.jsx)("div",{className:"w-[40%]",children:(0,a.jsx)("b",{children:"Line Width"})}),(0,a.jsx)(O.A,{min:1,max:10,step:.2,value:[e],className:"flex-1 my-2",onValueChange:e=>o(e[0])})]}),(0,a.jsxs)("div",{className:"w-full flex items-center mb-2",children:[(0,a.jsx)("div",{className:"w-[40%]",children:(0,a.jsx)("b",{children:"Line Resolution"})}),(0,a.jsx)(O.A,{min:1,max:10,step:1,value:[r],className:"flex-1 my-2",onValueChange:e=>s(e[0])})]}),(0,a.jsxs)("div",{className:"w-full flex items-center",children:[(0,a.jsx)("div",{className:"w-[40%]",children:(0,a.jsx)("b",{children:"Line Color"})}),i&&(0,a.jsx)("input",{type:"color",title:"Line Color",value:n,onChange:e=>l(e.target.value)}),!i&&(0,a.jsxs)(b.$,{className:"h-8 px-2 py-5",variant:"outline",onClick:()=>u(!t),children:["Use ",(0,a.jsx)("br",{}),t?"Individual Color":"Plot Color"]}),(0,a.jsxs)(b.$,{className:"h-8 px-2 py-5",variant:"outline",onClick:()=>d(!i),children:["Use ",(0,a.jsx)("br",{}),i?"Browzarr Color":"Custom Color"]})]})]})}),A=s.memo(function(){let{showPoints:e,setShowPoints:n}=(0,f.Ws)((0,c.k)(e=>({showPoints:e.showPoints,setShowPoints:e.setShowPoints})));return(0,a.jsx)("div",{className:"plotline-options",children:(0,a.jsxs)(k,{children:[(0,a.jsx)(D,{asChild:!0,children:(0,a.jsx)(b.$,{className:"cursor-pointer",variant:"outline",children:"Line Options"})}),(0,a.jsxs)(I,{className:"w-80 items-center",align:"center",children:[(0,a.jsx)(C,{onClick:e=>e.preventDefault(),children:(0,a.jsx)(M,{children:(0,a.jsx)(b.$,{variant:"outline",onClick:t=>{t.preventDefault(),n(!e)},children:e?"Hide Points":"Show Points"})})}),(0,a.jsx)(B,{}),(0,a.jsx)(P,{}),(0,a.jsx)(Y,{})]})]})})});var j=t(5844);function X(e){let{pointID:n,pointLoc:t,showPointInfo:r,plotUnits:i}=e,{plotDim:o,dimArrays:l,dimNames:u,dimUnits:d,timeSeries:m}=(0,f.on)((0,c.k)(e=>({plotDim:e.plotDim,dimArrays:e.dimArrays,dimNames:e.dimNames,dimUnits:e.dimUnits,timeSeries:e.timeSeries}))),x=0,y=0;if(Object.entries(n).length>0&&Object.entries(m).length>0){let[e,t]=n;x=m[e].data[t],y=l[o][t]}let[S,g]=t,[v,z]=(0,s.useState)(!1);return(0,s.useEffect)(()=>{if(!r){let e=setTimeout(()=>{z(!1)},100);return()=>clearTimeout(e)}z(!0)},[r]),(0,a.jsx)(a.Fragment,{children:v&&(0,a.jsxs)("div",{className:"point-info",style:{left:"".concat(S,"px"),top:"".concat(g,"px")},children:["".concat(x.toFixed(2)).concat(i),(0,a.jsx)("br",{}),"".concat(u[o],": ").concat((0,p.SB)(y,d[o]),"       \n        ")]})})}function L(){let{coords:e,timeSeries:n,setDimCoords:t,setTimeSeries:r}=(0,f.on)((0,c.k)(e=>({coords:e.dimCoords,timeSeries:e.timeSeries,setDimCoords:e.setDimCoords,setTimeSeries:e.setTimeSeries}))),[i,o]=(0,s.useState)(!1),l=(0,s.useRef)([0,Math.round(.255*window.innerHeight)]),u=(0,s.useRef)([0,Math.round(.255*window.innerHeight)]),[d,m]=(0,s.useState)([0,Math.round(.255*window.innerHeight)]);function x(e){if(i){let n=l.current[0]-e.clientX,t=l.current[1]-e.clientY,r=Math.min(Math.max(u.current[0]-n,10),window.innerWidth-120),i=Math.max(u.current[1]+t,0);m([Math.min(r,window.innerWidth-100),Math.min(i,window.innerHeight-100)])}}function y(){o(!1)}return(0,s.useEffect)(()=>(i&&(document.addEventListener("mousemove",x),document.addEventListener("mouseup",y)),()=>{document.removeEventListener("mousemove",x),document.removeEventListener("mouseup",y)}),[i]),(0,a.jsx)(a.Fragment,{children:(0,a.jsx)("div",{className:"coord-container",onPointerDown:function(e){l.current=[e.clientX,e.clientY],u.current=[...d],o(!0)},onPointerMove:x,onPointerUp:()=>o(!1),style:{left:"".concat(d[0],"px"),bottom:"".concat(d[1],"px")},children:Object.keys(e).length>0&&Object.keys(e).reverse().map((i,o)=>(0,a.jsxs)("div",{className:"plot-coords",style:{background:"rgb(".concat(n[i].color,")"),justifyContent:"space-between"},children:[(0,a.jsx)("b",{children:"".concat(e[i].first.name,": ")}),"".concat((0,p.SB)(e[i].first.loc,e[i].first.units)),(0,a.jsx)("br",{}),(0,a.jsx)("b",{children:"".concat(e[i].second.name,": ")}),"".concat((0,p.SB)(e[i].second.loc,e[i].second.units)),(0,a.jsx)(j.Xr4,{onClick:()=>(function(i){let{[i]:a,...o}=e;t(o);let{[i]:l,...u}=n;r(u)})(i),color:"red",style:{cursor:"pointer",zIndex:3}})]},i))})})}function U(){let[e,n]=(0,s.useState)(["",0]),[t,r]=(0,s.useState)([0,0]),[i,o]=(0,s.useState)(!1),[l,u]=(0,s.useState)(Math.round(window.innerHeight-.25*window.innerHeight)),d=(0,f.on)(e=>e.metadata),c=d?d.units:"Default",[m,x]=(0,s.useState)(1),[p,y]=(0,s.useState)(1);(0,s.useEffect)(()=>{let e=()=>{let e=Math.round(window.innerHeight-.25*window.innerHeight);u(e),document.documentElement.style.setProperty("--plot-height","".concat(e,"px"))};return window.addEventListener("orientationchange",e),window.addEventListener("resize",e),()=>{window.removeEventListener("orientationchange",e),window.removeEventListener("resize",e)}},[]),(0,s.useEffect)(()=>{document.documentElement.style.setProperty("--plot-height","".concat(l,"px"))},[l]);let S=window.innerHeight-l>=10;return(0,a.jsxs)(a.Fragment,{children:[!S&&(0,a.jsx)(h.de,{onClick:()=>{u(window.innerHeight-60)}}),S&&(0,a.jsxs)("div",{className:"plot-canvas",children:[(0,a.jsx)(A,{}),i&&(0,a.jsx)(X,{pointID:e,pointLoc:t,showPointInfo:i,plotUnits:c}),(0,a.jsx)(h.A,{height:l,setHeight:u}),(0,a.jsx)(h.gj,{scale:m,setScale:x}),(0,a.jsx)(h.LC,{scale:p,setScale:y}),(0,a.jsxs)(z.Hl,{orthographic:!0,camera:{position:[0,0,100]},frameloop:"demand",children:[(0,a.jsx)(e0,{height:l,yScale:m,pointSetters:{setPointID:n,setPointLoc:r,setShowPointInfo:o},xScale:p}),(0,a.jsx)(N,{height:l,yScale:m,xScale:p})]}),(0,a.jsx)(L,{})]})]})}var V=t(8736),T=t(780);function N(e){let{colorTicks:n="grey",tickSize:t=4,fontSize:r=14,showGrid:i=!0,gridOpacity:o=.5,height:l,yScale:u=1,xScale:d=1}=e,{camera:x}=(0,m.C)(),[y,S]=(0,s.useState)({left:0,right:0,top:0,bottom:0}),{dimCoords:g,dimArrays:v,plotDim:z,valueScales:h}=(0,f.on)((0,c.k)(e=>({dimCoords:e.dimCoords,dimArrays:e.dimArrays,plotDim:e.plotDim,valueScales:e.valueScales}))),b=v[z],_=b.length,w=h.maxVal-h.minVal,k=(0,s.useMemo)(()=>{let e=["Jan","Feb","Mar","Apr","May","Jun","Jul","Aug","Sep","Oct","Nov","Dec"];if(b){if(b.every(e=>"bigint"==typeof e)){let n=Object.keys(g).length>0?Object.keys(g)[0]:null,t=n?(0,p.lt)(g[n].plot.units):1,r=[];for(let n=0;n<b.length;n++){let i=new Date(Number(b[n])*t),a="".concat(i.getDate().toString().padStart(2,"0")," ").concat(e[i.getMonth()],"\n").concat(i.getFullYear());r.push(a)}return r}return b.map(e=>String(e))}},[b,g]),D=(0,s.useMemo)(()=>{let e=window.innerWidth,n=window.innerHeight-l;return{left:-e/2+x.position.x,right:e/2+x.position.x,top:n/2+x.position.y,bottom:-n/2+x.position.y}},[]),[I,C]=(0,s.useState)(x.zoom),M=(0,s.useMemo)(()=>{let e=1/x.zoom;return{tickSize:t*e,fontSize:r/e,labelOffset:t*e}},[x.zoom,t,r]);(0,m.D)(()=>{x.zoom!==I&&C(x.zoom);let e=window.innerWidth/x.zoom,n=(window.innerHeight-l)/x.zoom,t={left:-e/2+x.position.x,right:e/2+x.position.x,top:n/2+x.position.y,bottom:-n/2+x.position.y};JSON.stringify(y)!=JSON.stringify(t)&&S(t)});let P=(0,s.useRef)(null),O=(0,s.useRef)(null);(0,s.useEffect)(()=>(P.current&&clearTimeout(P.current),O.current&&(P.current=setTimeout(()=>{O.current&&O.current.reset()},100)),()=>{null!==P.current&&clearTimeout(P.current)}),[l]);let B=(y.top+y.bottom)/2,Y=(y.left+y.right)/2;return(0,a.jsxs)("group",{children:[i&&(0,a.jsxs)(a.Fragment,{children:[Array.from({length:10},(e,t)=>{var r;if(0===t||9===t)return null;let i=+Math.round(y.left/1)+(Math.round(y.right/1)-Math.round(y.left/1))*(t/9),l=i/d/(D.right-D.left)+.5;return(0,a.jsxs)(s.Fragment,{children:[(0,a.jsx)("group",{position:[i,B,0],children:(0,a.jsxs)("line",{children:[(0,a.jsx)("bufferGeometry",{children:(0,a.jsx)("float32BufferAttribute",{attach:"attributes-position",args:[new Float32Array([0,y.top-B,0,0,y.bottom-B,0]),3]})}),(0,a.jsx)("lineDashedMaterial",{color:n,opacity:o,transparent:!0,dashSize:.5,gapSize:.5})]},"vgrid-".concat(t))}),(0,a.jsxs)("group",{position:[i,y.top,0],children:[(0,a.jsxs)("line",{children:[(0,a.jsx)("bufferGeometry",{children:(0,a.jsx)("float32BufferAttribute",{attach:"attributes-position",args:[new Float32Array([0,0,0,0,-M.tickSize,0]),3]})}),(0,a.jsx)("lineBasicMaterial",{color:n})]}),0!==t&&9!==t&&(0,a.jsx)(V.E,{position:[0,M.tickSize/4-M.labelOffset,0],fontSize:M.fontSize/I**2,color:n,anchorX:"center",anchorY:"top",children:null!=(r=null==k?void 0:k[Math.round(l*_-.5)])?r:""})]},"top-tick-".concat(t))]},"vert-group-".concat(t))}),Array.from({length:8},(e,t)=>{if(0===t||7===t)return null;let r=y.bottom+(y.top-y.bottom)*(t/7),i=r/u/(y.top-y.bottom)/I+.5;return(0,a.jsxs)(s.Fragment,{children:[(0,a.jsx)("group",{position:[Y,r,0],children:(0,a.jsxs)("line",{children:[(0,a.jsx)("bufferGeometry",{children:(0,a.jsx)("float32BufferAttribute",{attach:"attributes-position",args:[new Float32Array([y.left-Y,0,0,y.right-Y,0,0]),3]})}),(0,a.jsx)("lineDashedMaterial",{color:n,opacity:o,transparent:!0,dashSize:0,gapSize:.5,linewidth:1})]})},"hgrid-".concat(t)),(0,a.jsxs)("group",{position:[y.right,r,0],children:[(0,a.jsxs)("line",{children:[(0,a.jsx)("bufferGeometry",{children:(0,a.jsx)("float32BufferAttribute",{attach:"attributes-position",args:[new Float32Array([0,0,0,-M.tickSize,0,0]),3]})}),(0,a.jsx)("lineBasicMaterial",{color:n})]}),0!==t&&7!==t&&(0,a.jsx)(V.E,{position:[-M.tickSize-M.labelOffset,0,0],fontSize:M.fontSize/I**2,color:n,anchorX:"right",anchorY:"middle",children:(h.minVal+i*w).toFixed(1)})]},"right-tick-".concat(t))]},"vert-group-".concat(t))})]}),(0,a.jsx)(T.N,{ref:O,enableRotate:!1,enablePan:!0,enableZoom:!0,zoomSpeed:.85,maxDistance:500,maxZoom:20,minZoom:.5})]})}var E=t(1785);t(3583);let G=e=>{let{loc:n,show:t,info:r}=e,{dimNames:i,dimUnits:o}=(0,f.on)((0,c.k)(e=>({dimNames:e.dimNames,dimUnits:e.dimUnits}))),l=(0,f.r2)(e=>e.axis),u=(0,s.useMemo)(()=>i.length<3?[i[0],i[1]]:i.filter((e,n)=>n!=l),[i,l]),d=(0,s.useMemo)(()=>i.length<3?[o[0],o[1]]:o.filter((e,n)=>n!=l),[o,l]);return(0,a.jsxs)("div",{className:"analysis-overlay",style:{left:"".concat(n[0]+10,"px"),top:"".concat(n[1]+10,"px"),display:t?"":"none"},children:["".concat(u[0],": ").concat(t&&(0,p.SB)(r[0],d[0])),(0,a.jsx)("br",{}),"".concat(u[1],": ").concat(t&&(0,p.SB)(r[1],d[1])),(0,a.jsx)("br",{}),"Value: ".concat(Math.round(100*r[2])/100)]})};var R=t(9301);let F="\n    struct Params {\n        zStride: u32,\n        yStride: u32,\n        xStride: u32,\n        xSize: u32,\n        ySize: u32,\n        reduceDim: u32,\n        dimLength: u32,\n    };\n    @group(0) @binding(0) var<storage, read> inputData: array<f32>;\n    @group(0) @binding(1) var<storage, read_write> outputData: array<f32>;\n    @group(0) @binding(2) var<uniform> params: Params;\n\n    @compute @workgroup_size(16, 16, 1)\n    fn main(@builtin(global_invocation_id) global_id: vec3<u32>) {\n        let zStride = params.zStride;\n        let yStride = params.yStride;\n        let xStride = params.xStride;\n        let xSize = params.xSize;\n        let ySize = params.ySize;\n        let reduceDim = params.reduceDim;\n        let dimLength = params.dimLength;\n                        \n        let outX = global_id.y;\n        let outY = global_id.x;\n        \n        if (outX >= xSize || outY >= ySize) {\n            return;\n        }\n",q="\n    ".concat(F,"\n        var sum: f32 = 0.0;\n        \n        // Iterate along the dimension we're averaging\n        if (reduceDim == 0u) { // Average along Z\n            let cCoord = outX * xStride + outY * yStride;\n            for (var z: u32 = 0u; z < dimLength; z++) {\n                let inputIndex = cCoord + (z * zStride);\n                sum += inputData[inputIndex];\n            }\n        } else if (reduceDim == 1u) { // Average along Y\n            let cCoord = outX * xStride + outY * zStride;\n            for (var y: u32 = 0u; y < dimLength; y++) {\n                let inputIndex = cCoord + (y * yStride);\n                sum += inputData[inputIndex];\n            }\n        } else { // Average along X\n            let cCoord = outX * yStride + outY * zStride;\n            for (var x: u32 = 0u; x < dimLength; x++) {\n                let inputIndex = cCoord + (x * xStride);\n                sum += inputData[inputIndex];\n            }\n        }\n        \n        let outputIndex = outY * xSize + outX;\n        outputData[outputIndex] = sum / f32(dimLength);\n    }\n"),Z="\n    ".concat(F,"\n        var min: f32 = 1e12;\n        \n        // Iterate along the dimension we're averaging\n        if (reduceDim == 0u) { // Average along Z\n            let cCoord = outX * xStride + outY * yStride;\n            for (var z: u32 = 0u; z < dimLength; z++) {\n                let inputIndex = cCoord + (z * zStride);\n                let newMin = inputData[inputIndex];\n                if (newMin < min) {\n                    min = newMin;\n                }\n            }\n        } else if (reduceDim == 1u) { // Average along Y\n            let cCoord = outX * xStride + outY * zStride;\n            for (var y: u32 = 0u; y < dimLength; y++) {\n                let inputIndex = cCoord + (y * yStride);\n                let newMin = inputData[inputIndex];\n                if (newMin < min) {\n                    min = newMin;\n                }\n            }\n        } else { // Average along X\n            let cCoord = outX * yStride + outY * zStride;\n            for (var x: u32 = 0u; x < dimLength; x++) {\n                let inputIndex = cCoord + (x * xStride);\n                let newMin = inputData[inputIndex];\n                if (newMin < min) {\n                    min = newMin;\n                }\n            }\n        }\n        \n        let outputIndex = outY * xSize + outX;\n        outputData[outputIndex] = min;\n    }\n"),W="\n    ".concat(F,"\n        \n        var max: f32 = -1e12;\n        \n        // Iterate along the dimension we're averaging\n        if (reduceDim == 0u) { // Average along Z\n            let cCoord = outX * xStride + outY * yStride;\n            for (var z: u32 = 0u; z < dimLength; z++) {\n                let inputIndex = cCoord + (z * zStride);\n                let newMax = inputData[inputIndex];\n                if (newMax > max) {\n                    max = newMax;\n                }\n            }\n        } else if (reduceDim == 1u) { // Average along Y\n            let cCoord = outX * xStride + outY * zStride;\n            for (var y: u32 = 0u; y < dimLength; y++) {\n                let inputIndex = cCoord + (y * yStride);\n                let newMax = inputData[inputIndex];\n                if (newMax > max) {\n                    max = newMax;\n                }\n            }\n        } else { // Average along X\n            let cCoord = outX * yStride + outY * zStride;\n            for (var x: u32 = 0u; x < dimLength; x++) {\n                let inputIndex = cCoord + (x * xStride);\n                let newMax = inputData[inputIndex];\n                if (newMax > max) {\n                    max = newMax;\n                }\n            }\n        }\n        \n        let outputIndex = outY * xSize + outX;\n        outputData[outputIndex] = max;\n    }\n"),H="\n    ".concat(F,"\n        var sum: f32 = 0.0;\n        // Iterate along the dimension we're averaging\n        if (reduceDim == 0u) { // Average along Z\n            let cCoord = outX * xStride + outY * yStride;\n            for (var z: u32 = 0u; z < dimLength; z++) {\n                let inputIndex = cCoord + (z * zStride);\n                sum += inputData[inputIndex];\n            }\n        } else if (reduceDim == 1u) { // Average along Y\n            let cCoord = outX * xStride + outY * zStride;\n            for (var y: u32 = 0u; y < dimLength; y++) {\n                let inputIndex = cCoord + (y * yStride);\n                sum += inputData[inputIndex];\n            }\n        } else { // Average along X\n            let cCoord = outX * yStride + outY * zStride;\n            for (var x: u32 = 0u; x < dimLength; x++) {\n                let inputIndex = cCoord + (x * xStride);\n                sum += inputData[inputIndex];\n            }\n        }\n        \n        let mean: f32 = sum / f32(dimLength);\n\n        var squaredDiffSum: f32 = 0.0;\n\n        // Iterate along the dimension again\n        if (reduceDim == 0u) { // Average along Z\n            let cCoord = outX * xStride + outY * yStride;\n            for (var z: u32 = 0u; z < dimLength; z++) {\n                let inputIndex = cCoord + (z * zStride);\n                let diff: f32 = mean - inputData[inputIndex];\n                squaredDiffSum += diff*diff;\n            }\n        } else if (reduceDim == 1u) { // Average along Y\n            let cCoord = outX * xStride + outY * zStride;\n            for (var y: u32 = 0u; y < dimLength; y++) {\n                let inputIndex = cCoord + (y * yStride);\n                let diff: f32 = mean - inputData[inputIndex];\n                squaredDiffSum += diff*diff;\n            }\n        } else { // Average along X\n            let cCoord = outX * yStride + outY * zStride;\n            for (var x: u32 = 0u; x < dimLength; x++) {\n                let inputIndex = cCoord + (x * xStride);\n                let diff: f32 = mean - inputData[inputIndex];\n                squaredDiffSum += diff*diff;\n            }\n        }\n\n        let stDev: f32 = sqrt(squaredDiffSum / f32(dimLength));\n        let outputIndex = outY * xSize + outX;\n        outputData[outputIndex] = stDev;\n    }\n"),Q="\n    ".concat(F,"\n        \n        var accum: f32 = 0;\n        \n        // Iterate along the dimension we're averaging\n        if (reduceDim == 0u) { // Average along Z\n            let cCoord = outX * xStride + outY * yStride;\n            for (var z: u32 = 0u; z < dimLength; z++) {\n                let inputIndex = cCoord + (z * zStride);\n                accum += inputData[inputIndex];\n                \n            }\n        } else if (reduceDim == 1u) { // Average along Y\n            let cCoord = outX * xStride + outY * zStride;\n            for (var y: u32 = 0u; y < dimLength; y++) {\n                let inputIndex = cCoord + (y * yStride);\n                accum += inputData[inputIndex];\n            }\n        } else { // Average along X\n            let cCoord = outX * yStride + outY * zStride;\n            for (var x: u32 = 0u; x < dimLength; x++) {\n                let inputIndex = cCoord + (x * xStride);\n                accum += inputData[inputIndex];\n            }\n        }\n        \n        let outputIndex = outY * xSize + outX;\n        outputData[outputIndex] = accum;\n    }\n"),$="\n    ".concat(F,"\n        let meanY: f32 = f32(dimLength)/2;\n        var sum: f32 = 0.0;\n\n\n        // Iterate along the dimension we're averaging\n        if (reduceDim == 0u) { // Average along Z\n            let cCoord = outX * xStride + outY * yStride;\n            for (var z: u32 = 0u; z < dimLength; z++) {\n                let inputIndex = cCoord + (z * zStride);\n                sum += inputData[inputIndex];\n            }\n        } else if (reduceDim == 1u) { // Average along Y\n            let cCoord = outX * xStride + outY * zStride;\n            for (var y: u32 = 0u; y < dimLength; y++) {\n                let inputIndex = cCoord + (y * yStride);\n                sum += inputData[inputIndex];\n            }\n        } else { // Average along X\n            let cCoord = outX * yStride + outY * zStride;\n            for (var x: u32 = 0u; x < dimLength; x++) {\n                let inputIndex = cCoord + (x * xStride);\n                sum += inputData[inputIndex];\n            }\n        }\n        \n        let meanX: f32 = sum / f32(dimLength);\n        var numSum: f32 = 0;\n        var denomSum: f32 = 0;\n\n        if (reduceDim == 0u) { // Average along Z\n            let cCoord = outX * xStride + outY * yStride;\n            for (var z: u32 = 0u; z < dimLength; z++) {\n                let inputIndex = cCoord + (z * zStride);\n                let xi: f32 = inputData[inputIndex];\n                numSum += (xi - meanX)*(f32(z) - meanY);\n                denomSum += (f32(z) - meanY)*(f32(z) - meanY);\n            }\n        } else if (reduceDim == 1u) { // Average along Y\n            let cCoord = outX * xStride + outY * zStride;\n            for (var y: u32 = 0u; y < dimLength; y++) {\n                let inputIndex = cCoord + (y * yStride);\n                let xi: f32 = inputData[inputIndex];\n                numSum += (xi - meanX)*(f32(y) - meanY);\n                denomSum += (f32(y) - meanY)*(f32(y) - meanY);\n            }\n        } else { // Average along X\n            let cCoord = outX * yStride + outY * zStride;\n            for (var x: u32 = 0u; x < dimLength; x++) {\n                let inputIndex = cCoord + (x * xStride);\n                let xi: f32 = inputData[inputIndex];\n                numSum += (xi - meanX)*(f32(x) - meanY);\n                denomSum += (f32(x) - meanY)*(f32(x) - meanY);\n            }\n        }\n        \n        let outputIndex = outY * xSize + outX;\n        outputData[outputIndex] = numSum/denomSum;\n    }\n"),J="\n    struct Params {\n    zStride: u32,\n    yStride: u32,\n    xStride: u32,\n    xSize: u32,\n    ySize: u32,\n    reduceDim: u32,\n    dimLength: u32,\n    };\n    @group(0) @binding(0) var<storage, read> firstData: array<f32>;\n    @group(0) @binding(1) var<storage, read> secondData: array<f32>;\n    @group(0) @binding(2) var<storage, read_write> outputData: array<f32>;\n    @group(0) @binding(3) var<uniform> params: Params;\n\n    @compute @workgroup_size(16, 16, 1)\n    fn main(@builtin(global_invocation_id) global_id: vec3<u32>) {\n        let zStride = params.zStride;\n        let yStride = params.yStride;\n        let xStride = params.xStride;\n        let xSize = params.xSize;\n        let ySize = params.ySize;\n        let reduceDim = params.reduceDim;\n        let dimLength = params.dimLength;\n                        \n        let outX = global_id.y;\n        let outY = global_id.x;\n        \n        if (outX >= xSize || outY >= ySize) {\n            return;\n        }\n\n        var ySum: f32 = 0;\n        var xSum: f32 = 0.0;\n\n        // Iterate along the dimension we're averaging\n        if (reduceDim == 0u) { \n            let cCoord = outX * xStride + outY * yStride;\n            for (var z: u32 = 0u; z < dimLength; z++) {\n                let inputIndex = cCoord + (z * zStride);\n                xSum += firstData[inputIndex];\n                ySum += secondData[inputIndex];\n            }\n        } else if (reduceDim == 1u) { \n            let cCoord = outX * xStride + outY * zStride;\n            for (var y: u32 = 0u; y < dimLength; y++) {\n                let inputIndex = cCoord + (y * yStride);\n                xSum += firstData[inputIndex];\n                ySum += secondData[inputIndex];\n            }\n        } else { \n            let cCoord = outX * yStride + outY * zStride;\n            for (var x: u32 = 0u; x < dimLength; x++) {\n                let inputIndex = cCoord + (x * xStride);\n                xSum += firstData[inputIndex];\n                ySum += secondData[inputIndex];\n            }\n        }\n        \n        let xMean: f32 = xSum / f32(dimLength);\n        let yMean: f32 = ySum / f32(dimLength);\n        var numSum: f32 = 0;\n        var denomSum: f32 = 0;\n\n        if (reduceDim == 0u) { // Average along Z\n            let cCoord = outX * xStride + outY * yStride;\n            for (var z: u32 = 0u; z < dimLength; z++) {\n                let inputIndex = cCoord + (z * zStride);\n                let xi: f32 = firstData[inputIndex];\n                let yi: f32 = secondData[inputIndex];\n                numSum += (xi - xMean)*(f32(yi) - yMean);\n                denomSum += (f32(yi) - yMean)*(f32(yi) - yMean);\n            }\n        } else if (reduceDim == 1u) { // Average along Y\n            let cCoord = outX * xStride + outY * zStride;\n            for (var y: u32 = 0u; y < dimLength; y++) {\n                let inputIndex = cCoord + (y * yStride);\n                let xi: f32 = firstData[inputIndex];\n                let yi: f32 = secondData[inputIndex];\n                numSum += (xi - xMean)*(f32(yi) - yMean);\n                denomSum += (f32(yi) - yMean)*(f32(yi) - yMean);\n            }\n        } else { // Average along X\n            let cCoord = outX * yStride + outY * zStride;\n            for (var x: u32 = 0u; x < dimLength; x++) {\n                let inputIndex = cCoord + (x * xStride);\n                let xi: f32 = firstData[inputIndex];\n                let yi: f32 = secondData[inputIndex];\n                numSum += (xi - xMean)*(f32(yi) - yMean);\n                denomSum += (f32(yi) - yMean)*(f32(yi) - yMean);\n            }\n        }\n        \n        let outputIndex = outY * xSize + outX;\n        outputData[outputIndex] = numSum/denomSum;\n    }\n",K="\n    struct Params {\n    zStride: u32,\n    yStride: u32,\n    xStride: u32,\n    xSize: u32,\n    ySize: u32,\n    reduceDim: u32,\n    dimLength: u32,\n    };\n    @group(0) @binding(0) var<storage, read> firstData: array<f32>;\n    @group(0) @binding(1) var<storage, read> secondData: array<f32>;\n    @group(0) @binding(2) var<storage, read_write> outputData: array<f32>;\n    @group(0) @binding(3) var<uniform> params: Params;\n\n    @compute @workgroup_size(16, 16, 1)\n    fn main(@builtin(global_invocation_id) global_id: vec3<u32>) {\n        let zStride = params.zStride;\n        let yStride = params.yStride;\n        let xStride = params.xStride;\n        let xSize = params.xSize;\n        let ySize = params.ySize;\n        let reduceDim = params.reduceDim;\n        let dimLength = params.dimLength;\n                        \n        let outX = global_id.y;\n        let outY = global_id.x;\n        \n        if (outX >= xSize || outY >= ySize) {\n            return;\n        }\n        var ySum: f32 = 0;\n        var xSum: f32 = 0.0;\n        var numSum: f32 = 0;\n\n       // Calculate base coordinate and stride for the dimension we're iterating over\n        var baseCoord: u32;\n        var iterStride: u32;\n\n        if (reduceDim == 0u) {\n            baseCoord = outX * xStride + outY * yStride;\n            iterStride = zStride;\n        } else if (reduceDim == 1u) {\n            baseCoord = outX * xStride + outY * zStride;\n            iterStride = yStride;\n        } else {\n            baseCoord = outX * yStride + outY * zStride;\n            iterStride = xStride;\n        }\n\n        // Single pass: calculate sums, means, and covariance\n        for (var i: u32 = 0u; i < dimLength; i++) {\n            let inputIndex = baseCoord + (i * iterStride);\n            let xi: f32 = firstData[inputIndex];\n            let yi: f32 = secondData[inputIndex];\n            xSum += xi;\n            ySum += yi;\n        }\n\n        let xMean: f32 = xSum / f32(dimLength);\n        let yMean: f32 = ySum / f32(dimLength);\n\n        // Second pass for covariance calculation\n        for (var i: u32 = 0u; i < dimLength; i++) {\n            let inputIndex = baseCoord + (i * iterStride);\n            let xi: f32 = firstData[inputIndex];\n            let yi: f32 = secondData[inputIndex];\n            numSum += (xi - xMean) * (yi - yMean);\n        }\n\n        let outputIndex = outY * xSize + outX;\n        outputData[outputIndex] = numSum / (f32(dimLength) - 1);\n    }\n",ee="\n    struct Params {\n        xStride: u32,\n        yStride: u32,\n        zStride: u32,\n        xSize: u32,\n        ySize: u32,\n        zSize: u32,\n        workGroups: vec3<u32>,\n        kernelSize: u32,\n        kernelDepth: u32\n    };\n    @group(0) @binding(0) var<storage, read> inputData: array<f32>;\n    @group(0) @binding(1) var<storage, read_write> outputData: array<f32>;\n    @group(0) @binding(2) var<uniform> params: Params;\n\n    @compute @workgroup_size(4, 4, 4)\n    fn main(@builtin(global_invocation_id) global_id: vec3<u32>) {\n        let zStride = params.zStride;\n        let yStride = params.yStride;\n        let xStride = params.xStride; \n        let xSize = params.xSize;\n        let ySize = params.ySize;\n        let zSize = params.zSize; \n        let workGroups = params.workGroups;\n        let kernelSize = params.kernelSize;\n        let kernelDepth = params.kernelDepth;\n\n        let outX = global_id.x; \n        let outY = global_id.y;\n        let outZ = global_id.z; \n\n        if (outX >= xSize || outY >= ySize || outZ >= zSize) {\n            return;\n        }\n\n        let total_threads_per_slice = workGroups.x * workGroups.y * 16;\n        let globalIdx = global_id.z * total_threads_per_slice + \n                        global_id.y * (workGroups.x * 4) + \n                        global_id.x;\n\n        let xy_radius: i32 = i32(kernelSize/2u);\n        let z_radius: i32 = i32(kernelDepth/2u);\n\n        var xyOffset: i32 = 0; //These offsets are for kernelsizes of 1. I didn't wanna rewrite everything else for that case\n        var zOffset: i32 = 0;\n        if (xy_radius == 0){\n            xyOffset = -1;\n        }\n        if (z_radius == 0){\n            zOffset = -1;\n        }\n",en="\n    struct Params {\n        xStride: u32,\n        yStride: u32,\n        xSize: u32,\n        ySize: u32,\n        kernelSize: u32,\n        kernelDepth: u32\n    };\n    @group(0) @binding(0) var<storage, read> inputData: array<f32>;\n    @group(0) @binding(1) var<storage, read_write> outputData: array<f32>;\n    @group(0) @binding(2) var<uniform> params: Params;\n\n    @compute @workgroup_size(16, 16, 1)\n    fn main(@builtin(global_invocation_id) global_id: vec3<u32>,) {\n        let xStride = params.xStride; \n        let yStride = params.yStride;\n        let xSize = params.xSize;\n        let ySize = params.ySize;\n        let kernelSize = params.kernelSize;\n\n        let outX = global_id.x; \n        let outY = global_id.y;\n\n        if (outX >= xSize|| outY >= ySize) {\n            return;\n        }\n\n        let globalIdx = outY * xSize + outX;\n        let thisVal = inputData[globalIdx];\n        let isNaN: bool = thisVal != thisVal;\n        if (isNaN){\n            outputData[globalIdx] = thisVal;\n            return;\n        }   \n\n        let xy_radius: i32 = i32(kernelSize/2u);\n\n",et="\n        ".concat(ee,"    \n        var sum: f32 = 0.0;\n        var count: u32 = 0u;\n        for (var kx: i32 = -xy_radius + xyOffset; kx < xy_radius; kx++) {\n            for (var ky: i32 = -xy_radius + xyOffset; ky < xy_radius; ky++) {\n                for (var kz: i32 = -z_radius + zOffset; kz < z_radius; kz++){\n                    let in_coord = vec3<i32>(global_id) + vec3<i32>(kx, ky, kz);\n\n                    if (in_coord.x >= 0 && in_coord.x < i32(xSize) &&\n                        in_coord.y >= 0 && in_coord.y < i32(ySize) &&\n                        in_coord.z >= 0 && in_coord.z < i32(zSize)) { //Ensure the sampled point is within 3D dataspace\n                        let xOffset = kx * i32(xStride);\n                        let yOffset = ky * i32(yStride);\n                        let zOffset = kz * i32(zStride);\n                        let newIdx = i32(globalIdx) + xOffset + yOffset + zOffset;\n\n                        sum += inputData[u32(newIdx)];\n                        count ++;\n                    }\n                }\n            }\n        }\n        \n        outputData[globalIdx] = sum / f32(count);\n    }\n"),er="\n    ".concat(ee,"  \n        var minVal: f32 = 1e12;\n        var count: u32 = 0u;\n        for (var kx: i32 = -xy_radius + xyOffset; kx < xy_radius; kx++) {\n            for (var ky: i32 = -xy_radius + xyOffset; ky < xy_radius; ky++) {\n                for (var kz: i32 = -z_radius + zOffset; kz < z_radius; kz++){\n                    let in_coord = vec3<i32>(global_id) + vec3<i32>(kx, ky, kz);\n\n                    if (in_coord.x >= 0 && in_coord.x < i32(xSize) &&\n                        in_coord.y >= 0 && in_coord.y < i32(ySize) &&\n                        in_coord.z >= 0 && in_coord.z < i32(zSize)) { //Ensure the sampled point is within 3D dataspace\n                        let xOffset = kx * i32(xStride);\n                        let yOffset = ky * i32(yStride);\n                        let zOffset = kz * i32(zStride);\n                        let newIdx = i32(globalIdx) + xOffset + yOffset + zOffset;\n                        let sampledVal = inputData[u32(newIdx)];\n                        if (sampledVal < minVal){\n                            minVal = sampledVal;\n                        }\n                    }\n                }\n            }\n        }\n        \n        outputData[globalIdx] = minVal;\n    }\n"),ei="\n    ".concat(ee,"  \n\n        var maxVal: f32 = -1e12;\n        var count: u32 = 0u;\n        for (var kx: i32 = -xy_radius + xyOffset; kx < xy_radius; kx++) {\n            for (var ky: i32 = -xy_radius + xyOffset; ky < xy_radius; ky++) {\n                for (var kz: i32 = -z_radius + zOffset; kz < z_radius; kz++){\n                    let in_coord = vec3<i32>(global_id) + vec3<i32>(kx, ky, kz);\n\n                    if (in_coord.x >= 0 && in_coord.x < i32(xSize) &&\n                        in_coord.y >= 0 && in_coord.y < i32(ySize) &&\n                        in_coord.z >= 0 && in_coord.z < i32(zSize)) { //Ensure the sampled point is within 3D dataspace\n                        let xOffset = kx * i32(xStride);\n                        let yOffset = ky * i32(yStride);\n                        let zOffset = kz * i32(zStride);\n                        let newIdx = i32(globalIdx) + xOffset + yOffset + zOffset;\n                        let sampledVal = inputData[u32(newIdx)];\n                        if (sampledVal > maxVal){\n                            maxVal = sampledVal;\n                        }\n                    }\n                }\n            }\n        }\n        \n        outputData[globalIdx] = maxVal;\n    }\n"),ea="\n    ".concat(ee,"  \n        var sum: f32 = 0.0;\n        var count: u32 = 0u;\n        for (var kx: i32 = -xy_radius + xyOffset; kx < xy_radius; kx++) {\n            for (var ky: i32 = -xy_radius + xyOffset; ky < xy_radius; ky++) {\n                for (var kz: i32 = -z_radius + zOffset; kz < z_radius; kz++){\n                    let in_coord = vec3<i32>(global_id) + vec3<i32>(kx, ky, kz);\n\n                    if (in_coord.x >= 0 && in_coord.x < i32(xSize) &&\n                        in_coord.y >= 0 && in_coord.y < i32(ySize) &&\n                        in_coord.z >= 0 && in_coord.z < i32(zSize)) { //Ensure the sampled point is within 3D dataspace\n                        let xOffset = kx * i32(xStride);\n                        let yOffset = ky * i32(yStride);\n                        let zOffset = kz * i32(zStride);\n                        let newIdx = i32(globalIdx) + xOffset + yOffset + zOffset;\n\n                        sum += inputData[u32(newIdx)];\n                        count ++;\n                    }\n                }\n            }\n        }\n        \n        let mean: f32 = sum / f32(count);\n\n        var squaredDiffSum: f32 = 0.0;\n\n        for (var kx: i32 = -xy_radius + xyOffset; kx < xy_radius; kx++) {\n            for (var ky: i32 = -xy_radius + xyOffset; ky < xy_radius; ky++) {\n                for (var kz: i32 = -z_radius + zOffset; kz < z_radius; kz++){\n                    let in_coord = vec3<i32>(global_id) + vec3<i32>(kx, ky, kz);\n\n                    if (in_coord.x >= 0 && in_coord.x < i32(xSize) &&\n                        in_coord.y >= 0 && in_coord.y < i32(ySize) &&\n                        in_coord.z >= 0 && in_coord.z < i32(zSize)) { //Ensure the sampled point is within 3D dataspace\n                        let xOffset = kx * i32(xStride);\n                        let yOffset = ky * i32(yStride);\n                        let zOffset = kz * i32(zStride);\n                        let newIdx = i32(globalIdx) + xOffset + yOffset + zOffset;\n\n                        let diff: f32 = mean - inputData[u32(newIdx)];\n                        squaredDiffSum += diff*diff;\n                    }\n                }\n            }\n        }\n\n        let stDev: f32 = sqrt(squaredDiffSum / f32(count));\n\n        outputData[globalIdx] = stDev;\n    }\n"),eo="\n        ".concat(en,"    \n        var sum: f32 = 0;\n        var count: u32 = 0u;\n        for (var kx: i32 = -xy_radius; kx <= xy_radius; kx++) {\n            for (var ky: i32 = -xy_radius; ky <= xy_radius; ky++) {\n                let in_coord = vec2<i32>(i32(global_id.x), i32(global_id.y)) + vec2<i32>(kx, ky);\n                if (in_coord.x >= 0 && in_coord.x < i32(xSize) &&\n                    in_coord.y >= 0 && in_coord.y < i32(ySize)) { //Ensure the sampled point is within 3D dataspace\n                    let xOffset = kx * i32(xStride);\n                    let yOffset = ky * i32(yStride);\n                    let newIdx = i32(globalIdx) + xOffset + yOffset;\n                    let newVal = inputData[u32(newIdx)];\n                    if (newVal != newVal){ //This only evaluates if newVal is NaN\n                        continue;\n                    }\n                    sum += newVal;\n                    count ++;\n                }\n            }\n        }\n        outputData[globalIdx] = sum / f32(count);\n    }\n"),el="\n    ".concat(en,"   \n        var minVal: f32 = 1e12;\n        for (var kx: i32 = -xy_radius; kx <= xy_radius; kx++) {\n            for (var ky: i32 = -xy_radius; ky <= xy_radius; ky++) {\n                let in_coord = vec2<i32>(i32(global_id.x), i32(global_id.y)) + vec2<i32>(kx, ky);\n                if (in_coord.x >= 0 && in_coord.x < i32(xSize) &&\n                    in_coord.y >= 0 && in_coord.y < i32(ySize)) { //Ensure the sampled point is within 3D dataspace\n                    let xOffset = kx * i32(xStride);\n                    let yOffset = ky * i32(yStride);\n                    let newIdx = i32(globalIdx) + xOffset + yOffset;\n                    let newVal = inputData[u32(newIdx)];\n                    if (newVal != newVal){ //This only evaluates if newVal is NaN\n                        continue;\n                    }\n                    if (newVal < minVal){\n                        minVal = newVal;\n                    }\n                }\n            }\n        }\n        outputData[globalIdx] = minVal;\n    }\n"),eu="\n    ".concat(en,"  \n        var maxVal: f32 = -1e12;\n        for (var kx: i32 = -xy_radius; kx <= xy_radius; kx++) {\n            for (var ky: i32 = -xy_radius; ky <= xy_radius; ky++) {\n                let in_coord = vec2<i32>(i32(global_id.x), i32(global_id.y)) + vec2<i32>(kx, ky);\n                if (in_coord.x >= 0 && in_coord.x < i32(xSize) &&\n                    in_coord.y >= 0 && in_coord.y < i32(ySize)) { //Ensure the sampled point is within 3D dataspace\n                    let xOffset = kx * i32(xStride);\n                    let yOffset = ky * i32(yStride);\n                    let newIdx = i32(globalIdx) + xOffset + yOffset;\n                    let newVal = inputData[u32(newIdx)];\n                    if (newVal != newVal){ //This only evaluates if newVal is NaN\n                        continue;\n                    }\n                    if (newVal > maxVal){\n                        maxVal = newVal;\n                    }\n                }\n            }\n        }\n        outputData[globalIdx] = maxVal;\n    }\n"),es="\n     ".concat(en,"  \n        var sum: f32 = 1e12;\n        var count: u32 = 0u;\n        for (var kx: i32 = -xy_radius; kx <= xy_radius; kx++) {\n            for (var ky: i32 = -xy_radius; ky <= xy_radius; ky++) {\n                let in_coord = vec2<i32>(i32(global_id.x), i32(global_id.y)) + vec2<i32>(kx, ky);\n                if (in_coord.x >= 0 && in_coord.x < i32(xSize) &&\n                    in_coord.y >= 0 && in_coord.y < i32(ySize)) { //Ensure the sampled point is within 3D dataspace\n                    let xOffset = kx * i32(xStride);\n                    let yOffset = ky * i32(yStride);\n                    let newIdx = i32(globalIdx) + xOffset + yOffset;\n                    let newVal = inputData[u32(newIdx)];\n                    if (newVal != newVal){ //This only evaluates if newVal is NaN\n                        continue;\n                    }\n                    sum += newVal;\n                    count ++;\n                }\n            }\n        }\n        \n        let mean: f32 = sum / f32(count);\n\n        var squaredDiffSum: f32 = 0.0;\n\n        for (var kx: i32 = -xy_radius; kx <= xy_radius; kx++) {\n            for (var ky: i32 = -xy_radius; ky <= xy_radius; ky++) {\n                let in_coord = vec2<i32>(i32(global_id.x), i32(global_id.y)) + vec2<i32>(kx, ky);\n                if (in_coord.x >= 0 && in_coord.x < i32(xSize) &&\n                    in_coord.y >= 0 && in_coord.y < i32(ySize)) { //Ensure the sampled point is within 3D dataspace\n                    let xOffset = kx * i32(xStride);\n                    let yOffset = ky * i32(yStride);\n                    let newIdx = i32(globalIdx) + xOffset + yOffset;\n                    let newVal = inputData[u32(newIdx)];\n                    if (newVal != newVal){ //This only evaluates if newVal is NaN\n                        continue;\n                    }\n                    let diff: f32 = mean - newVal;\n                    squaredDiffSum += diff*diff;\n                }\n            }\n        }\n        let stDev: f32 = sqrt(squaredDiffSum / f32(count));\n\n        outputData[globalIdx] = stDev;\n    }\n"),ed="\n    struct Params {\n        xStride: u32,\n        yStride: u32,\n        zStride: u32,\n        xSize: u32,\n        ySize: u32,\n        zSize: u32,\n        workGroups: vec3<u32>,\n        kernelSize: u32,\n        kernelDepth: u32\n    };\n    @group(0) @binding(0) var<storage, read> firstData: array<f32>;\n    @group(0) @binding(1) var<storage, read> secondData: array<f32>;\n    @group(0) @binding(2) var<storage, read_write> outputData: array<f32>;\n    @group(0) @binding(3) var<uniform> params: Params;\n\n    @compute @workgroup_size(4, 4, 4)\n    fn main(@builtin(global_invocation_id) global_id: vec3<u32>) {\n        let zStride = params.zStride;\n        let yStride = params.yStride;\n        let xStride = params.xStride; \n        let xSize = params.xSize;\n        let ySize = params.ySize;\n        let zSize = params.zSize; \n        let workGroups = params.workGroups;\n        let kernelSize = params.kernelSize;\n        let kernelDepth = params.kernelDepth;\n\n        let outX = global_id.x; \n        let outY = global_id.y;\n        let outZ = global_id.z; \n\n        if (outX >= xSize || outY >= ySize || outZ >= zSize) {\n            return;\n        }\n\n        let total_threads_per_slice = workGroups.x * workGroups.y * 16;\n        let globalIdx = global_id.z * total_threads_per_slice + \n                        global_id.y * (workGroups.x * 4) + \n                        global_id.x;\n\n        let xy_radius: i32 = i32(kernelSize/2u);\n        let z_radius: i32 = i32(kernelDepth/2u);\n\n        var xyOffset: i32 = 0; //These offsets are for kernelsizes of 1. I didn't wanna rewrite everything else for that case\n        var zOffset: i32 = 0;\n        if (xy_radius == 0){\n            xyOffset = -1;\n        }\n        if (z_radius == 0){\n            zOffset = -1;\n        }\n\n        var xSum: f32 = 0.0;\n        var xxSum: f32 = 0.0;\n        var ySum: f32 = 0.0;\n        var yySum: f32 = 0.0;\n        var xySum: f32 = 0.0;\n\n        var count: u32 = 0u;\n        for (var kx: i32 = -xy_radius + xyOffset; kx < xy_radius; kx++) {\n            for (var ky: i32 = -xy_radius + xyOffset; ky < xy_radius; ky++) {\n                for (var kz: i32 = -z_radius + zOffset; kz < z_radius; kz++){\n                    let in_coord = vec3<i32>(global_id) + vec3<i32>(kx, ky, kz);\n                    if (in_coord.x >= 0 && in_coord.x < i32(xSize) &&\n                        in_coord.y >= 0 && in_coord.y < i32(ySize) &&\n                        in_coord.z >= 0 && in_coord.z < i32(zSize)) { //Ensure the sampled point is within 3D dataspace\n                        let xOffset = kx * i32(xStride);\n                        let yOffset = ky * i32(yStride);\n                        let zOffset = kz * i32(zStride);\n                        let newIdx = i32(globalIdx) + xOffset + yOffset + zOffset;\n\n                        let xI = firstData[newIdx];\n                        let yI = secondData[newIdx];\n                        xSum += xI;\n                        xxSum += xI * xI;\n                        ySum += yI;\n                        yySum += yI * yI;\n                        xySum += xI * yI;\n                        count ++;\n                    }\n                }\n            }\n        }\n\n        let N: f32 = f32(count);\n        let meanX = xSum / N;\n        let meanY = ySum / N;\n        let varX = (xxSum / N) - (meanX * meanX);\n        let varY = (yySum / N) - (meanY * meanY);\n        let covXY = (xySum / N) - (meanX * meanY);\n        let sigmaX = sqrt(max(0.0, varX));\n        let sigmaY = sqrt(max(0.0, varY));\n        let epsilon = 1e-6;\n        let denominator = sigmaX * sigmaY + epsilon;\n        let correlation = covXY / denominator;\n\n        outputData[globalIdx] = correlation;\n    }\n",ef="\n    struct Params {\n        xStride: u32,\n        yStride: u32,\n        zStride: u32,\n        xSize: u32,\n        ySize: u32,\n        zSize: u32,\n        workGroups: vec3<u32>,\n        kernelSize: u32,\n        kernelDepth: u32\n    };\n    @group(0) @binding(0) var<storage, read> firstData: array<f32>;\n    @group(0) @binding(1) var<storage, read> secondData: array<f32>;\n    @group(0) @binding(2) var<storage, read_write> outputData: array<f32>;\n    @group(0) @binding(3) var<uniform> params: Params;\n\n    @compute @workgroup_size(4, 4, 4)\n    fn main(@builtin(global_invocation_id) global_id: vec3<u32>) {\n        let zStride = params.zStride;\n        let yStride = params.yStride;\n        let xStride = params.xStride; \n        let xSize = params.xSize;\n        let ySize = params.ySize;\n        let zSize = params.zSize; \n        let workGroups = params.workGroups;\n        let kernelSize = params.kernelSize;\n        let kernelDepth = params.kernelDepth;\n\n        let outX = global_id.x; \n        let outY = global_id.y;\n        let outZ = global_id.z; \n\n        if (outX >= xSize || outY >= ySize || outZ >= zSize) {\n            return;\n        }\n\n        let total_threads_per_slice = workGroups.x * workGroups.y * 16;\n        let globalIdx = global_id.z * total_threads_per_slice + \n                        global_id.y * (workGroups.x * 4) + \n                        global_id.x;\n\n        let xy_radius: i32 = i32(kernelSize/2u);\n        let z_radius: i32 = i32(kernelDepth/2u);\n\n        var xyOffset: i32 = 0; //These offsets are for kernelsizes of 1. I didn't wanna rewrite everything else for that case\n        var zOffset: i32 = 0;\n        if (xy_radius == 0){\n            xyOffset = -1;\n        }\n        if (z_radius == 0){\n            zOffset = -1;\n        }\n\n        var xSum: f32 = 0.0;\n        var ySum: f32 = 0.0;\n        var numSum: f32 = 0.0;\n\n        var count: u32 = 0u;\n        for (var kx: i32 = -xy_radius + xyOffset; kx < xy_radius; kx++) {\n            for (var ky: i32 = -xy_radius + xyOffset; ky < xy_radius; ky++) {\n                for (var kz: i32 = -z_radius + zOffset; kz < z_radius; kz++){\n                    let in_coord = vec3<i32>(global_id) + vec3<i32>(kx, ky, kz);\n                    if (in_coord.x >= 0 && in_coord.x < i32(xSize) &&\n                        in_coord.y >= 0 && in_coord.y < i32(ySize) &&\n                        in_coord.z >= 0 && in_coord.z < i32(zSize)) { \n                        let xOffset = kx * i32(xStride);\n                        let yOffset = ky * i32(yStride);\n                        let zOffset = kz * i32(zStride);\n                        let newIdx = i32(globalIdx) + xOffset + yOffset + zOffset;\n                        let xI = firstData[newIdx];\n                        let yI = secondData[newIdx];\n                        xSum += xI;    \n                        ySum += yI;\n                        count ++;\n                    }\n                }\n            }\n        }\n\n        let N: f32 = f32(count);\n        let meanX = xSum / N;\n        let meanY = ySum / N;\n        \n        for (var kx: i32 = -xy_radius + xyOffset; kx < xy_radius; kx++) {\n            for (var ky: i32 = -xy_radius + xyOffset; ky < xy_radius; ky++) {\n                for (var kz: i32 = -z_radius + zOffset; kz < z_radius; kz++){\n                    let in_coord = vec3<i32>(global_id) + vec3<i32>(kx, ky, kz);\n                    if (in_coord.x >= 0 && in_coord.x < i32(xSize) &&\n                        in_coord.y >= 0 && in_coord.y < i32(ySize) &&\n                        in_coord.z >= 0 && in_coord.z < i32(zSize)) { \n                        let xOffset = kx * i32(xStride);\n                        let yOffset = ky * i32(yStride);\n                        let zOffset = kz * i32(zStride);\n                        let newIdx = i32(globalIdx) + xOffset + yOffset + zOffset;\n                        let xI = firstData[newIdx];\n                        let yI = secondData[newIdx];\n                        numSum += (xI - meanX) * (yI - meanY);\n                        count ++;\n                    }\n                }\n            }\n        }\n        outputData[globalIdx] = numSum/(N-1);;\n    }\n",ec="\n    struct Params {\n        xStride: u32,\n        yStride: u32,\n        zStride: u32,\n        xSize: u32,\n        ySize: u32,\n        zSize: u32,\n        workGroups: vec3<u32>,\n        kernelSize: u32,\n        kernelDepth: u32\n    };\n    @group(0) @binding(0) var<storage, read> firstData: array<f32>;\n    @group(0) @binding(1) var<storage, read> secondData: array<f32>;\n    @group(0) @binding(2) var<storage, read_write> outputData: array<f32>;\n    @group(0) @binding(3) var<uniform> params: Params;\n\n    @compute @workgroup_size(4, 4, 4)\n    fn main(@builtin(global_invocation_id) global_id: vec3<u32>) {\n        let zStride = params.zStride;\n        let yStride = params.yStride;\n        let xStride = params.xStride; \n        let xSize = params.xSize;\n        let ySize = params.ySize;\n        let zSize = params.zSize; \n        let workGroups = params.workGroups;\n        let kernelSize = params.kernelSize;\n        let kernelDepth = params.kernelDepth;\n\n        let outX = global_id.x; \n        let outY = global_id.y;\n        let outZ = global_id.z; \n\n        if (outX >= xSize || outY >= ySize || outZ >= zSize) {\n            return;\n        }\n\n        let total_threads_per_slice = workGroups.x * workGroups.y * 16;\n        let globalIdx = global_id.z * total_threads_per_slice + \n                        global_id.y * (workGroups.x * 4) + \n                        global_id.x;\n\n        let xy_radius: i32 = i32(kernelSize/2u);\n        let z_radius: i32 = i32(kernelDepth/2u);\n\n        var xyOffset: i32 = 0; //These offsets are for kernelsizes of 1. I didn't wanna rewrite everything else for that case\n        var zOffset: i32 = 0;\n        if (xy_radius == 0){\n            xyOffset = -1;\n        }\n        if (z_radius == 0){\n            zOffset = -1;\n        }\n\n        var xSum: f32 = 0.0;\n        var ySum: f32 = 0.0;\n\n        var count: u32 = 0u;\n        for (var kx: i32 = -xy_radius + xyOffset; kx < xy_radius; kx++) {\n            for (var ky: i32 = -xy_radius + xyOffset; ky < xy_radius; ky++) {\n                for (var kz: i32 = -z_radius + zOffset; kz < z_radius; kz++){\n                    let in_coord = vec3<i32>(global_id) + vec3<i32>(kx, ky, kz);\n                    if (in_coord.x >= 0 && in_coord.x < i32(xSize) &&\n                        in_coord.y >= 0 && in_coord.y < i32(ySize) &&\n                        in_coord.z >= 0 && in_coord.z < i32(zSize)) { \n                        let xOffset = kx * i32(xStride);\n                        let yOffset = ky * i32(yStride);\n                        let zOffset = kz * i32(zStride);\n                        let newIdx = i32(globalIdx) + xOffset + yOffset + zOffset;\n                        let xI = firstData[newIdx];\n                        let yI = secondData[newIdx];\n                        xSum += xI;    \n                        ySum += yI;\n                        count ++;\n                    }\n                }\n            }\n        }\n\n\n        let N: f32 = f32(count);\n        let meanX = xSum / N;\n        let meanY = ySum / N;\n        var numSum: f32 = 0;\n        var denomSum: f32 = 0;\n        \n        for (var kx: i32 = -xy_radius + xyOffset; kx < xy_radius; kx++) {\n            for (var ky: i32 = -xy_radius + xyOffset; ky < xy_radius; ky++) {\n                for (var kz: i32 = -z_radius + zOffset; kz < z_radius; kz++){\n                    let in_coord = vec3<i32>(global_id) + vec3<i32>(kx, ky, kz);\n                    if (in_coord.x >= 0 && in_coord.x < i32(xSize) &&\n                        in_coord.y >= 0 && in_coord.y < i32(ySize) &&\n                        in_coord.z >= 0 && in_coord.z < i32(zSize)) { \n                        let xOffset = kx * i32(xStride);\n                        let yOffset = ky * i32(yStride);\n                        let zOffset = kz * i32(zStride);\n                        let newIdx = i32(globalIdx) + xOffset + yOffset + zOffset;\n                        let xI = firstData[newIdx];\n                        let yI = secondData[newIdx];\n                        numSum += (xI - meanX)*(f32(yI) - meanY);\n                        denomSum += (f32(yI) - meanY)*(f32(yI) - meanY);\n                    }\n                }\n            }\n        }\n        outputData[globalIdx] = numSum/denomSum;;\n    }\n",em="\n    struct Params {\n        xStride: u32,\n        yStride: u32,\n        zStride: u32,\n        xSize: u32,\n        ySize: u32,\n        zSize: u32,\n        reduceDim: u32,\n        reverse: u32,\n        workGroups: vec3<u32>,\n    };\n    @group(0) @binding(0) var<storage, read> inputData: array<f32>;\n    @group(0) @binding(1) var<storage, read_write> outputData: array<f32>;\n    @group(0) @binding(2) var<uniform> params: Params;\n\n    @compute @workgroup_size(4, 4, 4)\n    fn main(@builtin(global_invocation_id) global_id: vec3<u32>) {\n        let zStride = params.zStride;\n        let yStride = params.yStride;\n        let xStride = params.xStride; \n        let xSize = params.xSize;\n        let ySize = params.ySize;\n        let zSize = params.zSize; \n        let reverse = params.reverse;\n        let workGroups = params.workGroups;\n        let reduceDim = params.reduceDim;\n\n        let outX = global_id.x; \n        let outY = global_id.y;\n        let outZ = global_id.z; \n\n        if (outX >= xSize || outY >= ySize || outZ >= zSize) {\n            return;\n        }\n        let totalSize: u32 = xSize * ySize * zSize;\n        var baseIdx = outZ * zStride + outY * yStride + outX * xStride;\n        var accum: f32 = 0;\n\n        // Iterate along the dimension we're averaging\n        if (reduceDim == 0u) { // CUMSUM along Z\n            if (reverse == u32(1)){\n                baseIdx = (zSize - outZ - 1) * zStride + outY * yStride + outX * xStride;\n            }\n            for (var z: u32 = 0u; z < outZ; z++) {\n                var newZ: u32 = z;\n                if (reverse == u32(1)){\n                    newZ = zSize - z - 1;\n                }\n                let idx = newZ * zStride + outY * yStride + outX * xStride;\n                accum += inputData[idx];\n            }\n\n        } else if (reduceDim == 1u) { // CUMSUM along Y\n            if (reverse == u32(1)){\n                baseIdx = outZ * zStride + (ySize - outY - 1)* yStride + outX * xStride;\n            }\n            for (var y: u32 = 0u; y < outY; y++) {\n                var newY: u32 = y;\n                if (reverse == u32(1)){\n                    newY = ySize - y - 1;\n                }\n                let idx = outZ * zStride + newY * yStride + outX * xStride;\n                accum += inputData[idx];\n            }\n        } else { // CUMSUM along X\n             if (reverse == u32(1)){\n                baseIdx = outZ * zStride + outY* yStride + (xSize - outX - 1) * xStride;\n            }\n            for (var x: u32 = 0u; x < outX; x++) {\n                var newX: u32 = x;\n                if (reverse == u32(1)){\n                    newX = xSize - x - 1;\n                }\n                let idx = outZ * zStride + outY * yStride + newX * xStride;\n                accum += inputData[idx];\n            }\n        }\n            outputData[baseIdx] = accum;\n    }\n",ex="\n    struct Params {\n        zStride: u32,\n        yStride: u32,\n        xStride: u32,\n        xSize: u32,\n        ySize: u32,\n        reduceDim: u32,\n        dimLength: u32,\n    };\n    @group(0) @binding(0) var<storage, read> firstData: array<f32>;\n    @group(0) @binding(1) var<storage, read> secondData: array<f32>;\n    @group(0) @binding(2) var<storage, read_write> outputData: array<f32>;\n    @group(0) @binding(3) var<uniform> params: Params;\n\n    @compute @workgroup_size(16, 16, 1)\n    fn main(@builtin(global_invocation_id) global_id: vec3<u32>) {\n        let zStride = params.zStride;\n        let yStride = params.yStride;\n        let xStride = params.xStride;\n        let xSize = params.xSize;\n        let ySize = params.ySize;\n        let reduceDim = params.reduceDim;\n        let dimLength = params.dimLength;\n                        \n        let outX = global_id.y;\n        let outY = global_id.x;\n        \n        if (outX >= xSize || outY >= ySize) {\n            return;\n        }\n\n        var xSum: f32 = 0.0;\n        var xxSum: f32 = 0.0;\n        var ySum: f32 = 0.0;\n        var yySum: f32 = 0.0;\n        var xySum: f32 = 0.0;\n        // Iterate along the dimension we're averaging\n        if (reduceDim == 0u) { // Average along Z\n            let cCoord = outX * xStride + outY * yStride;\n            for (var z: u32 = 0u; z < dimLength; z++) {\n                let inputIndex = cCoord + (z * zStride);\n                let xI = firstData[inputIndex];\n                let yI = secondData[inputIndex];\n                xSum += xI;\n                xxSum += xI * xI;\n                ySum += yI;\n                yySum += yI * yI;\n                xySum += xI * yI;\n            }\n        } else if (reduceDim == 1u) { // Average along Y\n            let cCoord = outX * xStride + outY * zStride;\n            for (var y: u32 = 0u; y < dimLength; y++) {\n                let inputIndex = cCoord + (y * yStride);\n                let xI = firstData[inputIndex];\n                let yI = secondData[inputIndex];\n                xSum += xI;\n                xxSum += xI * xI;\n                ySum += yI;\n                yySum += yI * yI;\n                xySum += xI * yI;\n            }\n        } else { // Average along X\n            let cCoord = outX * yStride + outY * zStride;\n            for (var x: u32 = 0u; x < dimLength; x++) {\n                let inputIndex = cCoord + (x * xStride);\n                let xI = firstData[inputIndex];\n                let yI = secondData[inputIndex];\n                xSum += xI;\n                xxSum += xI * xI;\n                ySum += yI;\n                yySum += yI * yI;\n                xySum += xI * yI;\n            }\n        }\n\n        let N: f32 = f32(dimLength);\n        let meanX = xSum / N;\n        let meanY = ySum / N;\n        let varX = (xxSum / N) - (meanX * meanX);\n        let varY = (yySum / N) - (meanY * meanY);\n        let covXY = (xySum / N) - (meanX * meanY);\n        let sigmaX = sqrt(max(0.0, varX));\n        let sigmaY = sqrt(max(0.0, varY));\n        let epsilon = 1e-6;\n        let denominator = sigmaX * sigmaY + epsilon;\n        let correlation = covXY / denominator;\n\n        let outputIndex = outY * xSize + outX;\n        outputData[outputIndex] = correlation;\n    }\n",ep="\n    enable f16;\n    struct Params {\n        zStride: u32,\n        yStride: u32,\n        xStride: u32,\n        xSize: u32,\n        ySize: u32,\n        reduceDim: u32,\n        dimLength: u32,\n    };\n    @group(0) @binding(0) var<storage, read> inputData: array<f16>;\n    @group(0) @binding(1) var<storage, read_write> outputData: array<f16>;\n    @group(0) @binding(2) var<uniform> params: Params;\n\n    @compute @workgroup_size(16, 16, 1)\n    fn main(@builtin(global_invocation_id) global_id: vec3<u32>) {\n        let zStride = params.zStride;\n        let yStride = params.yStride;\n        let xStride = params.xStride;\n        let xSize = params.xSize;\n        let ySize = params.ySize;\n        let reduceDim = params.reduceDim;\n        let dimLength = params.dimLength;\n                        \n        let outX = global_id.y;\n        let outY = global_id.x;\n        \n        if (outX >= xSize || outY >= ySize) {\n            return;\n        }\n",ey="\n    ".concat(ep,"\n        var sum: f32 = 0.0;\n        \n        // Iterate along the dimension we're averaging\n        if (reduceDim == 0u) { // Average along Z\n            let cCoord = outX * xStride + outY * yStride;\n            for (var z: u32 = 0u; z < dimLength; z++) {\n                let inputIndex = cCoord + (z * zStride);\n                sum += f32(inputData[inputIndex]);\n            }\n        } else if (reduceDim == 1u) { // Average along Y\n            let cCoord = outX * xStride + outY * zStride;\n            for (var y: u32 = 0u; y < dimLength; y++) {\n                let inputIndex = cCoord + (y * yStride);\n                sum += f32(inputData[inputIndex]);\n            }\n        } else { // Average along X\n            let cCoord = outX * yStride + outY * zStride;\n            for (var x: u32 = 0u; x < dimLength; x++) {\n                let inputIndex = cCoord + (x * xStride);\n                sum += f32(inputData[inputIndex]);\n            }\n        }\n        \n        let outputIndex = outY * xSize + outX;\n        outputData[outputIndex] = f16(sum / f32(dimLength));\n    }\n"),eS="\n    ".concat(ep,"\n        var min: f32 = 1e12;\n        \n        // Iterate along the dimension we're averaging\n        if (reduceDim == 0u) { // Average along Z\n            let cCoord = outX * xStride + outY * yStride;\n            for (var z: u32 = 0u; z < dimLength; z++) {\n                let inputIndex = cCoord + (z * zStride);\n                let newMin = f32(inputData[inputIndex]);\n                if (newMin < min) {\n                    min = newMin;\n                }\n            }\n        } else if (reduceDim == 1u) { // Average along Y\n            let cCoord = outX * xStride + outY * zStride;\n            for (var y: u32 = 0u; y < dimLength; y++) {\n                let inputIndex = cCoord + (y * yStride);\n                let newMin = f32(inputData[inputIndex]);\n                if (newMin < min) {\n                    min = newMin;\n                }\n            }\n        } else { // Average along X\n            let cCoord = outX * yStride + outY * zStride;\n            for (var x: u32 = 0u; x < dimLength; x++) {\n                let inputIndex = cCoord + (x * xStride);\n                let newMin = f32(inputData[inputIndex]);\n                if (newMin < min) {\n                    min = newMin;\n                }\n            }\n        }\n        \n        let outputIndex = outY * xSize + outX;\n        outputData[outputIndex] = f16(min);\n    }\n"),eg="\n    ".concat(ep,"\n        \n        var max: f32 = -1e12;\n        \n        // Iterate along the dimension we're averaging\n        if (reduceDim == 0u) { // Average along Z\n            let cCoord = outX * xStride + outY * yStride;\n            for (var z: u32 = 0u; z < dimLength; z++) {\n                let inputIndex = cCoord + (z * zStride);\n                let newMax = f32(inputData[inputIndex]);\n                if (newMax > max) {\n                    max = newMax;\n                }\n            }\n        } else if (reduceDim == 1u) { // Average along Y\n            let cCoord = outX * xStride + outY * zStride;\n            for (var y: u32 = 0u; y < dimLength; y++) {\n                let inputIndex = cCoord + (y * yStride);\n                let newMax = f32(inputData[inputIndex]);\n                if (newMax > max) {\n                    max = newMax;\n                }\n            }\n        } else { // Average along X\n            let cCoord = outX * yStride + outY * zStride;\n            for (var x: u32 = 0u; x < dimLength; x++) {\n                let inputIndex = cCoord + (x * xStride);\n                let newMax = f32(inputData[inputIndex]);\n                if (newMax > max) {\n                    max = newMax;\n                }\n            }\n        }\n        \n        let outputIndex = outY * xSize + outX;\n        outputData[outputIndex] = f16(max);\n    }\n"),ev="\n    ".concat(ep,"\n        var sum: f32 = 0.0;\n        // Iterate along the dimension we're averaging\n        if (reduceDim == 0u) { // Average along Z\n            let cCoord = outX * xStride + outY * yStride;\n            for (var z: u32 = 0u; z < dimLength; z++) {\n                let inputIndex = cCoord + (z * zStride);\n                sum += f32(inputData[inputIndex]);\n            }\n        } else if (reduceDim == 1u) { // Average along Y\n            let cCoord = outX * xStride + outY * zStride;\n            for (var y: u32 = 0u; y < dimLength; y++) {\n                let inputIndex = cCoord + (y * yStride);\n                sum += f32(inputData[inputIndex]);\n            }\n        } else { // Average along X\n            let cCoord = outX * yStride + outY * zStride;\n            for (var x: u32 = 0u; x < dimLength; x++) {\n                let inputIndex = cCoord + (x * xStride);\n                sum += f32(inputData[inputIndex]);\n            }\n        }\n        \n        let mean: f32 = sum / f32(dimLength);\n\n        var squaredDiffSum: f32 = 0.0;\n\n        // Iterate along the dimension again\n        if (reduceDim == 0u) { // Average along Z\n            let cCoord = outX * xStride + outY * yStride;\n            for (var z: u32 = 0u; z < dimLength; z++) {\n                let inputIndex = cCoord + (z * zStride);\n                let diff: f32 = mean - f32(inputData[inputIndex]);\n                squaredDiffSum += diff*diff;\n            }\n        } else if (reduceDim == 1u) { // Average along Y\n            let cCoord = outX * xStride + outY * zStride;\n            for (var y: u32 = 0u; y < dimLength; y++) {\n                let inputIndex = cCoord + (y * yStride);\n                let diff: f32 = mean - f32(inputData[inputIndex]);\n                squaredDiffSum += diff*diff;\n            }\n        } else { // Average along X\n            let cCoord = outX * yStride + outY * zStride;\n            for (var x: u32 = 0u; x < dimLength; x++) {\n                let inputIndex = cCoord + (x * xStride);\n                let diff: f32 = mean - f32(inputData[inputIndex]);\n                squaredDiffSum += diff*diff;\n            }\n        }\n\n        let stDev: f32 = sqrt(squaredDiffSum / f32(dimLength));\n        let outputIndex = outY * xSize + outX;\n        outputData[outputIndex] = f16(stDev);\n    }\n"),ez="\n    enable f16;\n    struct Params {\n        zStride: u32,\n        yStride: u32,\n        xStride: u32,\n        xSize: u32,\n        ySize: u32,\n        reduceDim: u32,\n        dimLength: u32,\n    };\n    @group(0) @binding(0) var<storage, read> inputData: array<f16>;\n    @group(0) @binding(1) var<storage, read_write> outputData: array<f32>;\n    @group(0) @binding(2) var<uniform> params: Params;\n\n    @compute @workgroup_size(16, 16, 1)\n    fn main(@builtin(global_invocation_id) global_id: vec3<u32>) {\n        let zStride = params.zStride;\n        let yStride = params.yStride;\n        let xStride = params.xStride;\n        let xSize = params.xSize;\n        let ySize = params.ySize;\n        let reduceDim = params.reduceDim;\n        let dimLength = params.dimLength;\n                        \n        let outX = global_id.y;\n        let outY = global_id.x;\n        \n        if (outX >= xSize || outY >= ySize) {\n            return;\n        }\n        \n        var accum: f32 = 0;\n        \n        // Iterate along the dimension we're averaging\n        if (reduceDim == 0u) { // Average along Z\n            let cCoord = outX * xStride + outY * yStride;\n            for (var z: u32 = 0u; z < dimLength; z++) {\n                let inputIndex = cCoord + (z * zStride);\n                accum += f32(inputData[inputIndex]);\n                \n            }\n        } else if (reduceDim == 1u) { // Average along Y\n            let cCoord = outX * xStride + outY * zStride;\n            for (var y: u32 = 0u; y < dimLength; y++) {\n                let inputIndex = cCoord + (y * yStride);\n                accum += f32(inputData[inputIndex]);\n            }\n        } else { // Average along X\n            let cCoord = outX * yStride + outY * zStride;\n            for (var x: u32 = 0u; x < dimLength; x++) {\n                let inputIndex = cCoord + (x * xStride);\n                accum += f32(inputData[inputIndex]);\n            }\n        }\n        \n        let outputIndex = outY * xSize + outX;\n        outputData[outputIndex] = accum;\n    }\n",eh="\n    ".concat(ep,"\n        let meanY: f32 = f32(dimLength)/2;\n        var sum: f32 = 0.0;\n\n\n        // Iterate along the dimension we're averaging\n        if (reduceDim == 0u) { // Average along Z\n            let cCoord = outX * xStride + outY * yStride;\n            for (var z: u32 = 0u; z < dimLength; z++) {\n                let inputIndex = cCoord + (z * zStride);\n                sum += f32(inputData[inputIndex]);\n            }\n        } else if (reduceDim == 1u) { // Average along Y\n            let cCoord = outX * xStride + outY * zStride;\n            for (var y: u32 = 0u; y < dimLength; y++) {\n                let inputIndex = cCoord + (y * yStride);\n                sum += f32(inputData[inputIndex]);\n            }\n        } else { // Average along X\n            let cCoord = outX * yStride + outY * zStride;\n            for (var x: u32 = 0u; x < dimLength; x++) {\n                let inputIndex = cCoord + (x * xStride);\n                sum += f32(inputData[inputIndex]);\n            }\n        }\n        \n        let meanX: f32 = sum / f32(dimLength);\n        var numSum: f32 = 0;\n        var denomSum: f32 = 0;\n\n        if (reduceDim == 0u) { // Average along Z\n            let cCoord = outX * xStride + outY * yStride;\n            for (var z: u32 = 0u; z < dimLength; z++) {\n                let inputIndex = cCoord + (z * zStride);\n                let xi: f32 = f32(inputData[inputIndex]);\n                numSum += (xi - meanX)*(f32(z) - meanY);\n                denomSum += (f32(z) - meanY)*(f32(z) - meanY);\n            }\n        } else if (reduceDim == 1u) { // Average along Y\n            let cCoord = outX * xStride + outY * zStride;\n            for (var y: u32 = 0u; y < dimLength; y++) {\n                let inputIndex = cCoord + (y * yStride);\n                let xi: f32 = f32(inputData[inputIndex]);\n                numSum += (xi - meanX)*(f32(y) - meanY);\n                denomSum += (f32(y) - meanY)*(f32(y) - meanY);\n            }\n        } else { // Average along X\n            let cCoord = outX * yStride + outY * zStride;\n            for (var x: u32 = 0u; x < dimLength; x++) {\n                let inputIndex = cCoord + (x * xStride);\n                let xi: f32 = f32(inputData[inputIndex]);\n                numSum += (xi - meanX)*(f32(x) - meanY);\n                denomSum += (f32(x) - meanY)*(f32(x) - meanY);\n            }\n        }\n        \n        let outputIndex = outY * xSize + outX;\n        outputData[outputIndex] = f16(numSum/denomSum);\n    }\n"),eb="\n    enable f16;\n    struct Params {\n    zStride: u32,\n    yStride: u32,\n    xStride: u32,\n    xSize: u32,\n    ySize: u32,\n    reduceDim: u32,\n    dimLength: u32,\n    };\n    @group(0) @binding(0) var<storage, read> firstData: array<f16>;\n    @group(0) @binding(1) var<storage, read> secondData: array<f16>;\n    @group(0) @binding(2) var<storage, read_write> outputData: array<f16>;\n    @group(0) @binding(3) var<uniform> params: Params;\n\n    @compute @workgroup_size(16, 16, 1)\n    fn main(@builtin(global_invocation_id) global_id: vec3<u32>) {\n        let zStride = params.zStride;\n        let yStride = params.yStride;\n        let xStride = params.xStride;\n        let xSize = params.xSize;\n        let ySize = params.ySize;\n        let reduceDim = params.reduceDim;\n        let dimLength = params.dimLength;\n                        \n        let outX = global_id.y;\n        let outY = global_id.x;\n        \n        if (outX >= xSize || outY >= ySize) {\n            return;\n        }\n\n        var ySum: f32 = 0;\n        var xSum: f32 = 0.0;\n\n        // Iterate along the dimension we're averaging\n        if (reduceDim == 0u) { \n            let cCoord = outX * xStride + outY * yStride;\n            for (var z: u32 = 0u; z < dimLength; z++) {\n                let inputIndex = cCoord + (z * zStride);\n                xSum += f32(firstData[inputIndex]);\n                ySum += f32(secondData[inputIndex]);\n            }\n        } else if (reduceDim == 1u) { \n            let cCoord = outX * xStride + outY * zStride;\n            for (var y: u32 = 0u; y < dimLength; y++) {\n                let inputIndex = cCoord + (y * yStride);\n                xSum += f32(firstData[inputIndex]);\n                ySum += f32(secondData[inputIndex]);\n            }\n        } else { \n            let cCoord = outX * yStride + outY * zStride;\n            for (var x: u32 = 0u; x < dimLength; x++) {\n                let inputIndex = cCoord + (x * xStride);\n                xSum += f32(firstData[inputIndex]);\n                ySum += f32(secondData[inputIndex]);\n            }\n        }\n        \n        let xMean: f32 = xSum / f32(dimLength);\n        let yMean: f32 = ySum / f32(dimLength);\n        var numSum: f32 = 0;\n        var denomSum: f32 = 0;\n\n        if (reduceDim == 0u) { // Average along Z\n            let cCoord = outX * xStride + outY * yStride;\n            for (var z: u32 = 0u; z < dimLength; z++) {\n                let inputIndex = cCoord + (z * zStride);\n                let xi: f32 = f32(firstData[inputIndex]);\n                let yi: f32 = f32(secondData[inputIndex]);\n                numSum += (xi - xMean)*(f32(yi) - yMean);\n                denomSum += (f32(yi) - yMean)*(f32(yi) - yMean);\n            }\n        } else if (reduceDim == 1u) { // Average along Y\n            let cCoord = outX * xStride + outY * zStride;\n            for (var y: u32 = 0u; y < dimLength; y++) {\n                let inputIndex = cCoord + (y * yStride);\n                let xi: f32 = f32(firstData[inputIndex]);\n                let yi: f32 = f32(secondData[inputIndex]);\n                numSum += (xi - xMean)*(f32(yi) - yMean);\n                denomSum += (f32(yi) - yMean)*(f32(yi) - yMean);\n            }\n        } else { // Average along X\n            let cCoord = outX * yStride + outY * zStride;\n            for (var x: u32 = 0u; x < dimLength; x++) {\n                let inputIndex = cCoord + (x * xStride);\n                let xi: f32 = f32(firstData[inputIndex]);\n                let yi: f32 = f32(secondData[inputIndex]);\n                numSum += (xi - xMean)*(f32(yi) - yMean);\n                denomSum += (f32(yi) - yMean)*(f32(yi) - yMean);\n            }\n        }\n        \n        let outputIndex = outY * xSize + outX;\n        outputData[outputIndex] = f16(numSum/(denomSum+1e-4));\n    }\n",e_="\n    enable f16;\n    struct Params {\n    zStride: u32,\n    yStride: u32,\n    xStride: u32,\n    xSize: u32,\n    ySize: u32,\n    reduceDim: u32,\n    dimLength: u32,\n    };\n    @group(0) @binding(0) var<storage, read> firstData: array<f16>;\n    @group(0) @binding(1) var<storage, read> secondData: array<f16>;\n    @group(0) @binding(2) var<storage, read_write> outputData: array<f16>;\n    @group(0) @binding(3) var<uniform> params: Params;\n\n    @compute @workgroup_size(16, 16, 1)\n    fn main(@builtin(global_invocation_id) global_id: vec3<u32>) {\n        let zStride = params.zStride;\n        let yStride = params.yStride;\n        let xStride = params.xStride;\n        let xSize = params.xSize;\n        let ySize = params.ySize;\n        let reduceDim = params.reduceDim;\n        let dimLength = params.dimLength;\n                        \n        let outX = global_id.y;\n        let outY = global_id.x;\n        \n        if (outX >= xSize || outY >= ySize) {\n            return;\n        }\n        var ySum: f32 = 0;\n        var xSum: f32 = 0.0;\n        var numSum: f32 = 0;\n\n       // Calculate base coordinate and stride for the dimension we're iterating over\n        var baseCoord: u32;\n        var iterStride: u32;\n\n        if (reduceDim == 0u) {\n            baseCoord = outX * xStride + outY * yStride;\n            iterStride = zStride;\n        } else if (reduceDim == 1u) {\n            baseCoord = outX * xStride + outY * zStride;\n            iterStride = yStride;\n        } else {\n            baseCoord = outX * yStride + outY * zStride;\n            iterStride = xStride;\n        }\n\n        // Single pass: calculate sums, means, and covariance\n        for (var i: u32 = 0u; i < dimLength; i++) {\n            let inputIndex = baseCoord + (i * iterStride);\n            let xi: f32 = f32(firstData[inputIndex]);\n            let yi: f32 = f32(secondData[inputIndex]);\n            xSum += xi;\n            ySum += yi;\n        }\n\n        let xMean: f32 = xSum / f32(dimLength);\n        let yMean: f32 = ySum / f32(dimLength);\n\n        // Second pass for covariance calculation\n        for (var i: u32 = 0u; i < dimLength; i++) {\n            let inputIndex = baseCoord + (i * iterStride);\n            let xi: f32 = f32(firstData[inputIndex]);\n            let yi: f32 = f32(secondData[inputIndex]);\n            numSum += (xi - xMean) * (yi - yMean);\n        }\n\n        let outputIndex = outY * xSize + outX;\n        outputData[outputIndex] = f16(numSum / (f32(dimLength) - 1));\n    }\n",ew="\n    enable f16;\n    struct Params {\n        xStride: u32,\n        yStride: u32,\n        zStride: u32,\n        xSize: u32,\n        ySize: u32,\n        zSize: u32,\n        workGroups: vec3<u32>,\n        kernelSize: u32,\n        kernelDepth: u32\n    };\n    @group(0) @binding(0) var<storage, read> inputData: array<f16>;\n    @group(0) @binding(1) var<storage, read_write> outputData: array<f16>;\n    @group(0) @binding(2) var<uniform> params: Params;\n    \n    @compute @workgroup_size(4, 4, 4)\n    fn main(@builtin(global_invocation_id) global_id: vec3<u32>) {\n        let zStride = params.zStride;\n        let yStride = params.yStride;\n        let xStride = params.xStride; \n        let xSize = params.xSize;\n        let ySize = params.ySize;\n        let zSize = params.zSize; \n        let workGroups = params.workGroups;\n        let kernelSize = params.kernelSize;\n        let kernelDepth = params.kernelDepth;\n\n        let outX = global_id.x; \n        let outY = global_id.y;\n        let outZ = global_id.z; \n\n        if (outX >= xSize || outY >= ySize || outZ >= zSize) {\n            return;\n        }\n\n        let total_threads_per_slice = workGroups.x * workGroups.y * 16;\n        let globalIdx = global_id.z * total_threads_per_slice + \n                        global_id.y * (workGroups.x * 4) + \n                        global_id.x;\n\n        let xy_radius: i32 = i32(kernelSize/2u);\n        let z_radius: i32 = i32(kernelDepth/2u);\n\n        var xyOffset: i32 = 0; //These offsets are for kernelsizes of 1. I didn't wanna rewrite everything else for that case\n        var zOffset: i32 = 0;\n        if (xy_radius == 0){\n            xyOffset = -1;\n        }\n        if (z_radius == 0){\n            zOffset = -1;\n        }\n",ek="\n    enable f16;\n    struct Params {\n        xStride: u32,\n        yStride: u32,\n        xSize: u32,\n        ySize: u32,\n        kernelSize: u32,\n        kernelDepth: u32\n    };\n    @group(0) @binding(0) var<storage, read> inputData: array<f16>;\n    @group(0) @binding(1) var<storage, read_write> outputData: array<f16>;\n    @group(0) @binding(2) var<uniform> params: Params;\n\n    @compute @workgroup_size(16, 16, 1)\n    fn main(@builtin(global_invocation_id) global_id: vec3<u32>,) {\n        let xStride = params.xStride; \n        let yStride = params.yStride;\n        let xSize = params.xSize;\n        let ySize = params.ySize;\n        let kernelSize = params.kernelSize;\n\n        let outX = global_id.x; \n        let outY = global_id.y;\n\n        if (outX >= xSize|| outY >= ySize) {\n            return;\n        }\n\n        let globalIdx = outY * xSize + outX;\n        let thisVal = inputData[globalIdx];\n        let isNaN: bool = thisVal != thisVal;\n        if (isNaN){\n            outputData[globalIdx] = thisVal;\n            return;\n        }   \n\n        let xy_radius: i32 = i32(kernelSize/2u);\n\n",eD="\n        ".concat(ew,"    \n        var sum: f32 = 0.0;\n        var count: u32 = 0u;\n        for (var kx: i32 = -xy_radius + xyOffset; kx < xy_radius; kx++) {\n            for (var ky: i32 = -xy_radius + xyOffset; ky < xy_radius; ky++) {\n                for (var kz: i32 = -z_radius + zOffset; kz < z_radius; kz++){\n                    let in_coord = vec3<i32>(global_id) + vec3<i32>(kx, ky, kz);\n                    if (in_coord.x >= 0 && in_coord.x < i32(xSize) &&\n                        in_coord.y >= 0 && in_coord.y < i32(ySize) &&\n                        in_coord.z >= 0 && in_coord.z < i32(zSize)) { //Ensure the sampled point is within 3D dataspace\n                        let xOffset = kx * i32(xStride);\n                        let yOffset = ky * i32(yStride);\n                        let zOffset = kz * i32(zStride);\n                        let newIdx = i32(globalIdx) + xOffset + yOffset + zOffset;\n\n                        sum += f32(inputData[u32(newIdx)]);\n                        count ++;\n                    }\n                }\n            }\n        }\n        outputData[globalIdx] = f16(sum / f32(count));\n    }\n"),eI="\n    ".concat(ew,"  \n        var minVal: f32 = 1e12;\n        var count: u32 = 0u;\n        for (var kx: i32 = -xy_radius + xyOffset; kx < xy_radius; kx++) {\n            for (var ky: i32 = -xy_radius + xyOffset; ky < xy_radius; ky++) {\n                for (var kz: i32 = -z_radius + zOffset; kz < z_radius; kz++){\n                    let in_coord = vec3<i32>(global_id) + vec3<i32>(kx, ky, kz);\n\n                    if (in_coord.x >= 0 && in_coord.x < i32(xSize) &&\n                        in_coord.y >= 0 && in_coord.y < i32(ySize) &&\n                        in_coord.z >= 0 && in_coord.z < i32(zSize)) { //Ensure the sampled point is within 3D dataspace\n                        let xOffset = kx * i32(xStride);\n                        let yOffset = ky * i32(yStride);\n                        let zOffset = kz * i32(zStride);\n                        let newIdx = i32(globalIdx) + xOffset + yOffset + zOffset;\n                        let sampledVal = f32(inputData[u32(newIdx)]);\n                        if (sampledVal < minVal){\n                            minVal = sampledVal;\n                        }\n                    }\n                }\n            }\n        }\n        \n        outputData[globalIdx] = f16(minVal);\n    }\n"),eC="\n    ".concat(ew,"  \n\n        var maxVal: f32 = -1e12;\n        var count: u32 = 0u;\n        for (var kx: i32 = -xy_radius + xyOffset; kx < xy_radius; kx++) {\n            for (var ky: i32 = -xy_radius + xyOffset; ky < xy_radius; ky++) {\n                for (var kz: i32 = -z_radius + zOffset; kz < z_radius; kz++){\n                    let in_coord = vec3<i32>(global_id) + vec3<i32>(kx, ky, kz);\n\n                    if (in_coord.x >= 0 && in_coord.x < i32(xSize) &&\n                        in_coord.y >= 0 && in_coord.y < i32(ySize) &&\n                        in_coord.z >= 0 && in_coord.z < i32(zSize)) { //Ensure the sampled point is within 3D dataspace\n                        let xOffset = kx * i32(xStride);\n                        let yOffset = ky * i32(yStride);\n                        let zOffset = kz * i32(zStride);\n                        let newIdx = i32(globalIdx) + xOffset + yOffset + zOffset;\n                        let sampledVal = f32(inputData[u32(newIdx)]);\n                        if (sampledVal > maxVal){\n                            maxVal = sampledVal;\n                        }\n                    }\n                }\n            }\n        }\n        outputData[globalIdx] = f16(maxVal);\n    }\n"),eM="\n    ".concat(ew,"  \n        var sum: f32 = 0.0;\n        var count: u32 = 0u;\n        for (var kx: i32 = -xy_radius + xyOffset; kx < xy_radius; kx++) {\n            for (var ky: i32 = -xy_radius + xyOffset; ky < xy_radius; ky++) {\n                for (var kz: i32 = -z_radius + zOffset; kz < z_radius; kz++){\n                    let in_coord = vec3<i32>(global_id) + vec3<i32>(kx, ky, kz);\n\n                    if (in_coord.x >= 0 && in_coord.x < i32(xSize) &&\n                        in_coord.y >= 0 && in_coord.y < i32(ySize) &&\n                        in_coord.z >= 0 && in_coord.z < i32(zSize)) { //Ensure the sampled point is within 3D dataspace\n                        let xOffset = kx * i32(xStride);\n                        let yOffset = ky * i32(yStride);\n                        let zOffset = kz * i32(zStride);\n                        let newIdx = i32(globalIdx) + xOffset + yOffset + zOffset;\n\n                        sum += f32(inputData[u32(newIdx)]);\n                        count ++;\n                    }\n                }\n            }\n        }\n        \n        let mean: f32 = sum / f32(count);\n\n        var squaredDiffSum: f32 = 0.0;\n\n        for (var kx: i32 = -xy_radius + xyOffset; kx < xy_radius; kx++) {\n            for (var ky: i32 = -xy_radius + xyOffset; ky < xy_radius; ky++) {\n                for (var kz: i32 = -z_radius + zOffset; kz < z_radius; kz++){\n                    let in_coord = vec3<i32>(global_id) + vec3<i32>(kx, ky, kz);\n\n                    if (in_coord.x >= 0 && in_coord.x < i32(xSize) &&\n                        in_coord.y >= 0 && in_coord.y < i32(ySize) &&\n                        in_coord.z >= 0 && in_coord.z < i32(zSize)) { //Ensure the sampled point is within 3D dataspace\n                        let xOffset = kx * i32(xStride);\n                        let yOffset = ky * i32(yStride);\n                        let zOffset = kz * i32(zStride);\n                        let newIdx = i32(globalIdx) + xOffset + yOffset + zOffset;\n\n                        let diff: f32 = mean - f32(inputData[u32(newIdx)]);\n                        squaredDiffSum += diff*diff;\n                    }\n                }\n            }\n        }\n\n        let stDev: f32 = sqrt(squaredDiffSum / f32(count));\n\n        outputData[globalIdx] = f16(stDev);\n    }\n"),eP="\n        ".concat(ek,"    \n        var sum: f32 = 0;\n        var count: u32 = 0u;\n        for (var kx: i32 = -xy_radius; kx <= xy_radius; kx++) {\n            for (var ky: i32 = -xy_radius; ky <= xy_radius; ky++) {\n                let in_coord = vec2<i32>(i32(global_id.x), i32(global_id.y)) + vec2<i32>(kx, ky);\n                if (in_coord.x >= 0 && in_coord.x < i32(xSize) &&\n                    in_coord.y >= 0 && in_coord.y < i32(ySize)) { //Ensure the sampled point is within 3D dataspace\n                    let xOffset = kx * i32(xStride);\n                    let yOffset = ky * i32(yStride);\n                    let newIdx = i32(globalIdx) + xOffset + yOffset;\n                    let newVal = f32(inputData[u32(newIdx)]);\n                    if (newVal != newVal){ //This only evaluates if newVal is NaN\n                        continue;\n                    }\n                    sum += newVal;\n                    count ++;\n                }\n            }\n        }\n        outputData[globalIdx] = f16(sum / f32(count));\n    }\n"),eO="\n    ".concat(ek,"   \n        var minVal: f32 = 1e12;\n        for (var kx: i32 = -xy_radius; kx <= xy_radius; kx++) {\n            for (var ky: i32 = -xy_radius; ky <= xy_radius; ky++) {\n                let in_coord = vec2<i32>(i32(global_id.x), i32(global_id.y)) + vec2<i32>(kx, ky);\n                if (in_coord.x >= 0 && in_coord.x < i32(xSize) &&\n                    in_coord.y >= 0 && in_coord.y < i32(ySize)) { //Ensure the sampled point is within 3D dataspace\n                    let xOffset = kx * i32(xStride);\n                    let yOffset = ky * i32(yStride);\n                    let newIdx = i32(globalIdx) + xOffset + yOffset;\n                    let newVal = f32(inputData[u32(newIdx)]);\n                    if (newVal != newVal){ //This only evaluates if newVal is NaN\n                        continue;\n                    }\n                    if (newVal < minVal){\n                        minVal = newVal;\n                    }\n                }\n            }\n        }\n        outputData[globalIdx] = f16(minVal);\n    }\n"),eB="\n    ".concat(ek,"  \n        var maxVal: f32 = -1e12;\n        for (var kx: i32 = -xy_radius; kx <= xy_radius; kx++) {\n            for (var ky: i32 = -xy_radius; ky <= xy_radius; ky++) {\n                let in_coord = vec2<i32>(i32(global_id.x), i32(global_id.y)) + vec2<i32>(kx, ky);\n                if (in_coord.x >= 0 && in_coord.x < i32(xSize) &&\n                    in_coord.y >= 0 && in_coord.y < i32(ySize)) { //Ensure the sampled point is within 3D dataspace\n                    let xOffset = kx * i32(xStride);\n                    let yOffset = ky * i32(yStride);\n                    let newIdx = i32(globalIdx) + xOffset + yOffset;\n                    let newVal = f32(inputData[u32(newIdx)]);\n                    if (newVal != newVal){ //This only evaluates if newVal is NaN\n                        continue;\n                    }\n                    if (newVal > maxVal){\n                        maxVal = newVal;\n                    }\n                }\n            }\n        }\n        outputData[globalIdx] = f16(maxVal);\n    }\n"),eY="\n     ".concat(ek,"  \n        var sum: f32 = 0.;\n        var count: u32 = 0u;\n        for (var kx: i32 = -xy_radius; kx <= xy_radius; kx++) {\n            for (var ky: i32 = -xy_radius; ky <= xy_radius; ky++) {\n                let in_coord = vec2<i32>(i32(global_id.x), i32(global_id.y)) + vec2<i32>(kx, ky);\n                if (in_coord.x >= 0 && in_coord.x < i32(xSize) &&\n                    in_coord.y >= 0 && in_coord.y < i32(ySize)) { //Ensure the sampled point is within 3D dataspace\n                    let xOffset = kx * i32(xStride);\n                    let yOffset = ky * i32(yStride);\n                    let newIdx = i32(globalIdx) + xOffset + yOffset;\n                    let newVal = f32(inputData[u32(newIdx)]);\n                    if (newVal != newVal){ //This only evaluates if newVal is NaN\n                        continue;\n                    }\n                    sum += newVal;\n                    count ++;\n                }\n            }\n        }\n        \n        let mean: f32 = sum / f32(count);\n\n        var squaredDiffSum: f32 = 0.0;\n\n        for (var kx: i32 = -xy_radius; kx <= xy_radius; kx++) {\n            for (var ky: i32 = -xy_radius; ky <= xy_radius; ky++) {\n                let in_coord = vec2<i32>(i32(global_id.x), i32(global_id.y)) + vec2<i32>(kx, ky);\n                if (in_coord.x >= 0 && in_coord.x < i32(xSize) &&\n                    in_coord.y >= 0 && in_coord.y < i32(ySize)) { //Ensure the sampled point is within 3D dataspace\n                    let xOffset = kx * i32(xStride);\n                    let yOffset = ky * i32(yStride);\n                    let newIdx = i32(globalIdx) + xOffset + yOffset;\n                    let newVal = f32(inputData[u32(newIdx)]);\n                    if (newVal != newVal){ //This only evaluates if newVal is NaN\n                        continue;\n                    }\n                    let diff: f32 = mean - newVal;\n                    squaredDiffSum += diff*diff;\n                }\n            }\n        }\n        let stDev: f32 = sqrt(squaredDiffSum / f32(count));\n\n        outputData[globalIdx] = f16(stDev);\n    }\n"),eA="\n    enable f16;\n    struct Params {\n        xStride: u32,\n        yStride: u32,\n        zStride: u32,\n        xSize: u32,\n        ySize: u32,\n        zSize: u32,\n        workGroups: vec3<u32>,\n        kernelSize: u32,\n        kernelDepth: u32\n    };\n    @group(0) @binding(0) var<storage, read> firstData: array<f16>;\n    @group(0) @binding(1) var<storage, read> secondData: array<f16>;\n    @group(0) @binding(2) var<storage, read_write> outputData: array<f16>;\n    @group(0) @binding(3) var<uniform> params: Params;\n\n    @compute @workgroup_size(4, 4, 4)\n    fn main(@builtin(global_invocation_id) global_id: vec3<u32>) {\n        let zStride = params.zStride;\n        let yStride = params.yStride;\n        let xStride = params.xStride; \n        let xSize = params.xSize;\n        let ySize = params.ySize;\n        let zSize = params.zSize; \n        let workGroups = params.workGroups;\n        let kernelSize = params.kernelSize;\n        let kernelDepth = params.kernelDepth;\n\n        let outX = global_id.x; \n        let outY = global_id.y;\n        let outZ = global_id.z; \n\n        if (outX >= xSize || outY >= ySize || outZ >= zSize) {\n            return;\n        }\n\n        let total_threads_per_slice = workGroups.x * workGroups.y * 16;\n        let globalIdx = global_id.z * total_threads_per_slice + \n                        global_id.y * (workGroups.x * 4) + \n                        global_id.x;\n\n        let xy_radius: i32 = i32(kernelSize/2u);\n        let z_radius: i32 = i32(kernelDepth/2u);\n\n        var xyOffset: i32 = 0; //These offsets are for kernelsizes of 1. I didn't wanna rewrite everything else for that case\n        var zOffset: i32 = 0;\n        if (xy_radius == 0){\n            xyOffset = -1;\n        }\n        if (z_radius == 0){\n            zOffset = -1;\n        }\n\n        var xSum: f32 = 0.0;\n        var xxSum: f32 = 0.0;\n        var ySum: f32 = 0.0;\n        var yySum: f32 = 0.0;\n        var xySum: f32 = 0.0;\n\n        var count: u32 = 0u;\n        for (var kx: i32 = -xy_radius + xyOffset; kx < xy_radius; kx++) {\n            for (var ky: i32 = -xy_radius + xyOffset; ky < xy_radius; ky++) {\n                for (var kz: i32 = -z_radius + zOffset; kz < z_radius; kz++){\n                    let in_coord = vec3<i32>(global_id) + vec3<i32>(kx, ky, kz);\n                    if (in_coord.x >= 0 && in_coord.x < i32(xSize) &&\n                        in_coord.y >= 0 && in_coord.y < i32(ySize) &&\n                        in_coord.z >= 0 && in_coord.z < i32(zSize)) { //Ensure the sampled point is within 3D dataspace\n                        let xOffset = kx * i32(xStride);\n                        let yOffset = ky * i32(yStride);\n                        let zOffset = kz * i32(zStride);\n                        let newIdx = i32(globalIdx) + xOffset + yOffset + zOffset;\n\n                        let xI = f32(firstData[newIdx]);\n                        let yI = f32(secondData[newIdx]);\n                        xSum += xI;\n                        xxSum += xI * xI;\n                        ySum += yI;\n                        yySum += yI * yI;\n                        xySum += xI * yI;\n                        count ++;\n                    }\n                }\n            }\n        }\n\n        let N: f32 = f32(count);\n        let meanX = xSum / N;\n        let meanY = ySum / N;\n        let varX = (xxSum / N) - (meanX * meanX);\n        let varY = (yySum / N) - (meanY * meanY);\n        let covXY = (xySum / N) - (meanX * meanY);\n        let sigmaX = sqrt(max(0.0, varX));\n        let sigmaY = sqrt(max(0.0, varY));\n        let epsilon = 1e-6;\n        let denominator = sigmaX * sigmaY + epsilon;\n        let correlation = covXY / denominator;\n\n        outputData[globalIdx] = f16(correlation);\n    }\n",ej="\n    enable f16;\n    struct Params {\n        xStride: u32,\n        yStride: u32,\n        zStride: u32,\n        xSize: u32,\n        ySize: u32,\n        zSize: u32,\n        workGroups: vec3<u32>,\n        kernelSize: u32,\n        kernelDepth: u32\n    };\n    @group(0) @binding(0) var<storage, read> firstData: array<f16>;\n    @group(0) @binding(1) var<storage, read> secondData: array<f16>;\n    @group(0) @binding(2) var<storage, read_write> outputData: array<f16>;\n    @group(0) @binding(3) var<uniform> params: Params;\n\n    @compute @workgroup_size(4, 4, 4)\n    fn main(@builtin(global_invocation_id) global_id: vec3<u32>) {\n        let zStride = params.zStride;\n        let yStride = params.yStride;\n        let xStride = params.xStride; \n        let xSize = params.xSize;\n        let ySize = params.ySize;\n        let zSize = params.zSize; \n        let workGroups = params.workGroups;\n        let kernelSize = params.kernelSize;\n        let kernelDepth = params.kernelDepth;\n\n        let outX = global_id.x; \n        let outY = global_id.y;\n        let outZ = global_id.z; \n\n        if (outX >= xSize || outY >= ySize || outZ >= zSize) {\n            return;\n        }\n\n        let total_threads_per_slice = workGroups.x * workGroups.y * 16;\n        let globalIdx = global_id.z * total_threads_per_slice + \n                        global_id.y * (workGroups.x * 4) + \n                        global_id.x;\n\n        let xy_radius: i32 = i32(kernelSize/2u);\n        let z_radius: i32 = i32(kernelDepth/2u);\n\n        var xyOffset: i32 = 0; //These offsets are for kernelsizes of 1. I didn't wanna rewrite everything else for that case\n        var zOffset: i32 = 0;\n        if (xy_radius == 0){\n            xyOffset = -1;\n        }\n        if (z_radius == 0){\n            zOffset = -1;\n        }\n\n        var xSum: f32 = 0.0;\n        var ySum: f32 = 0.0;\n        var numSum: f32 = 0.0;\n\n        var count: u32 = 0u;\n        for (var kx: i32 = -xy_radius + xyOffset; kx < xy_radius; kx++) {\n            for (var ky: i32 = -xy_radius + xyOffset; ky < xy_radius; ky++) {\n                for (var kz: i32 = -z_radius + zOffset; kz < z_radius; kz++){\n                    let in_coord = vec3<i32>(global_id) + vec3<i32>(kx, ky, kz);\n                    if (in_coord.x >= 0 && in_coord.x < i32(xSize) &&\n                        in_coord.y >= 0 && in_coord.y < i32(ySize) &&\n                        in_coord.z >= 0 && in_coord.z < i32(zSize)) { \n                        let xOffset = kx * i32(xStride);\n                        let yOffset = ky * i32(yStride);\n                        let zOffset = kz * i32(zStride);\n                        let newIdx = i32(globalIdx) + xOffset + yOffset + zOffset;\n                        let xI = f32(firstData[newIdx]);\n                        let yI = f32(secondData[newIdx]);\n                        xSum += xI;    \n                        ySum += yI;\n                        count ++;\n                    }\n                }\n            }\n        }\n\n        let N: f32 = f32(count);\n        let meanX = xSum / N;\n        let meanY = ySum / N;\n        \n        for (var kx: i32 = -xy_radius + xyOffset; kx < xy_radius; kx++) {\n            for (var ky: i32 = -xy_radius + xyOffset; ky < xy_radius; ky++) {\n                for (var kz: i32 = -z_radius + zOffset; kz < z_radius; kz++){\n                    let in_coord = vec3<i32>(global_id) + vec3<i32>(kx, ky, kz);\n                    if (in_coord.x >= 0 && in_coord.x < i32(xSize) &&\n                        in_coord.y >= 0 && in_coord.y < i32(ySize) &&\n                        in_coord.z >= 0 && in_coord.z < i32(zSize)) { \n                        let xOffset = kx * i32(xStride);\n                        let yOffset = ky * i32(yStride);\n                        let zOffset = kz * i32(zStride);\n                        let newIdx = i32(globalIdx) + xOffset + yOffset + zOffset;\n                        let xI = f32(firstData[newIdx]);\n                        let yI = f32(secondData[newIdx]);\n                        numSum += (xI - meanX) * (yI - meanY);\n                        count ++;\n                    }\n                }\n            }\n        }\n        outputData[globalIdx] = f16(numSum/(N-1));\n    }\n",eX="\n    enable f16;\n    struct Params {\n        xStride: u32,\n        yStride: u32,\n        zStride: u32,\n        xSize: u32,\n        ySize: u32,\n        zSize: u32,\n        workGroups: vec3<u32>,\n        kernelSize: u32,\n        kernelDepth: u32\n    };\n    @group(0) @binding(0) var<storage, read> firstData: array<f16>;\n    @group(0) @binding(1) var<storage, read> secondData: array<f16>;\n    @group(0) @binding(2) var<storage, read_write> outputData: array<f16>;\n    @group(0) @binding(3) var<uniform> params: Params;\n\n    @compute @workgroup_size(4, 4, 4)\n    fn main(@builtin(global_invocation_id) global_id: vec3<u32>) {\n        let zStride = params.zStride;\n        let yStride = params.yStride;\n        let xStride = params.xStride; \n        let xSize = params.xSize;\n        let ySize = params.ySize;\n        let zSize = params.zSize; \n        let workGroups = params.workGroups;\n        let kernelSize = params.kernelSize;\n        let kernelDepth = params.kernelDepth;\n\n        let outX = global_id.x; \n        let outY = global_id.y;\n        let outZ = global_id.z; \n\n        if (outX >= xSize || outY >= ySize || outZ >= zSize) {\n            return;\n        }\n\n        let total_threads_per_slice = workGroups.x * workGroups.y * 16;\n        let globalIdx = global_id.z * total_threads_per_slice + \n                        global_id.y * (workGroups.x * 4) + \n                        global_id.x;\n\n        let xy_radius: i32 = i32(kernelSize/2u);\n        let z_radius: i32 = i32(kernelDepth/2u);\n\n        var xyOffset: i32 = 0; //These offsets are for kernelsizes of 1. I didn't wanna rewrite everything else for that case\n        var zOffset: i32 = 0;\n        if (xy_radius == 0){\n            xyOffset = -1;\n        }\n        if (z_radius == 0){\n            zOffset = -1;\n        }\n\n        var xSum: f32 = 0.0;\n        var ySum: f32 = 0.0;\n\n        var count: u32 = 0u;\n        for (var kx: i32 = -xy_radius + xyOffset; kx < xy_radius; kx++) {\n            for (var ky: i32 = -xy_radius + xyOffset; ky < xy_radius; ky++) {\n                for (var kz: i32 = -z_radius + zOffset; kz < z_radius; kz++){\n                    let in_coord = vec3<i32>(global_id) + vec3<i32>(kx, ky, kz);\n                    if (in_coord.x >= 0 && in_coord.x < i32(xSize) &&\n                        in_coord.y >= 0 && in_coord.y < i32(ySize) &&\n                        in_coord.z >= 0 && in_coord.z < i32(zSize)) { \n                        let xOffset = kx * i32(xStride);\n                        let yOffset = ky * i32(yStride);\n                        let zOffset = kz * i32(zStride);\n                        let newIdx = i32(globalIdx) + xOffset + yOffset + zOffset;\n                        let xI = f32(firstData[newIdx]);\n                        let yI = f32(secondData[newIdx]);\n                        xSum += xI;    \n                        ySum += yI;\n                        count ++;\n                    }\n                }\n            }\n        }\n\n\n        let N: f32 = f32(count);\n        let meanX = xSum / N;\n        let meanY = ySum / N;\n        var numSum: f32 = 0;\n        var denomSum: f32 = 0;\n        \n        for (var kx: i32 = -xy_radius + xyOffset; kx < xy_radius; kx++) {\n            for (var ky: i32 = -xy_radius + xyOffset; ky < xy_radius; ky++) {\n                for (var kz: i32 = -z_radius + zOffset; kz < z_radius; kz++){\n                    let in_coord = vec3<i32>(global_id) + vec3<i32>(kx, ky, kz);\n                    if (in_coord.x >= 0 && in_coord.x < i32(xSize) &&\n                        in_coord.y >= 0 && in_coord.y < i32(ySize) &&\n                        in_coord.z >= 0 && in_coord.z < i32(zSize)) { \n                        let xOffset = kx * i32(xStride);\n                        let yOffset = ky * i32(yStride);\n                        let zOffset = kz * i32(zStride);\n                        let newIdx = i32(globalIdx) + xOffset + yOffset + zOffset;\n                        let xI = f32(firstData[newIdx]);\n                        let yI = f32(secondData[newIdx]);\n                        numSum += (xI - meanX)*(f32(yI) - meanY);\n                        denomSum += (f32(yI) - meanY)*(f32(yI) - meanY);\n                    }\n                }\n            }\n        }\n        outputData[globalIdx] = f16(numSum/denomSum);\n    }\n",eL="\n    enable f16;\n    struct Params {\n        xStride: u32,\n        yStride: u32,\n        zStride: u32,\n        xSize: u32,\n        ySize: u32,\n        zSize: u32,\n        reduceDim: u32,\n        reverse: u32,\n        workGroups: vec3<u32>,\n    };\n    @group(0) @binding(0) var<storage, read> inputData: array<f16>;\n    @group(0) @binding(1) var<storage, read_write> outputData: array<f32>;\n    @group(0) @binding(2) var<uniform> params: Params;\n\n    @compute @workgroup_size(4, 4, 4)\n    fn main(@builtin(global_invocation_id) global_id: vec3<u32>) {\n        let zStride = params.zStride;\n        let yStride = params.yStride;\n        let xStride = params.xStride; \n        let xSize = params.xSize;\n        let ySize = params.ySize;\n        let zSize = params.zSize; \n        let reverse = params.reverse;\n        let workGroups = params.workGroups;\n        let reduceDim = params.reduceDim;\n\n        let outX = global_id.x; \n        let outY = global_id.y;\n        let outZ = global_id.z; \n\n        if (outX >= xSize || outY >= ySize || outZ >= zSize) {\n            return;\n        }\n        let totalSize: u32 = xSize * ySize * zSize;\n        var baseIdx = outZ * zStride + outY * yStride + outX * xStride;\n        var accum: f32 = 0;\n\n        // Iterate along the dimension we're averaging\n        if (reduceDim == 0u) { // CUMSUM along Z\n            if (reverse == u32(1)){\n                baseIdx = (zSize - outZ - 1) * zStride + outY * yStride + outX * xStride;\n            }\n            for (var z: u32 = 0u; z < outZ; z++) {\n                var newZ: u32 = z;\n                if (reverse == u32(1)){\n                    newZ = zSize - z - 1;\n                }\n                let idx = newZ * zStride + outY * yStride + outX * xStride;\n                accum += f32(inputData[idx]);\n            }\n\n        } else if (reduceDim == 1u) { // CUMSUM along Y\n            if (reverse == u32(1)){\n                baseIdx = outZ * zStride + (ySize - outY - 1)* yStride + outX * xStride;\n            }\n            for (var y: u32 = 0u; y < outY; y++) {\n                var newY: u32 = y;\n                if (reverse == u32(1)){\n                    newY = ySize - y - 1;\n                }\n                let idx = outZ * zStride + newY * yStride + outX * xStride;\n                accum += f32(inputData[idx]);\n            }\n        } else { // CUMSUM along X\n             if (reverse == u32(1)){\n                baseIdx = outZ * zStride + outY* yStride + (xSize - outX - 1) * xStride;\n            }\n            for (var x: u32 = 0u; x < outX; x++) {\n                var newX: u32 = x;\n                if (reverse == u32(1)){\n                    newX = xSize - x - 1;\n                }\n                let idx = outZ * zStride + outY * yStride + newX * xStride;\n                accum += f32(inputData[idx]);\n            }\n        }\n            outputData[baseIdx] = accum;\n    }\n",eU="\n    enable f16;\n    struct Params {\n        zStride: u32,\n        yStride: u32,\n        xStride: u32,\n        xSize: u32,\n        ySize: u32,\n        reduceDim: u32,\n        dimLength: u32,\n    };\n    @group(0) @binding(0) var<storage, read> firstData: array<f16>;\n    @group(0) @binding(1) var<storage, read> secondData: array<f16>;\n    @group(0) @binding(2) var<storage, read_write> outputData: array<f16>;\n    @group(0) @binding(3) var<uniform> params: Params;\n\n    @compute @workgroup_size(16, 16, 1)\n    fn main(@builtin(global_invocation_id) global_id: vec3<u32>) {\n        let zStride = params.zStride;\n        let yStride = params.yStride;\n        let xStride = params.xStride;\n        let xSize = params.xSize;\n        let ySize = params.ySize;\n        let reduceDim = params.reduceDim;\n        let dimLength = params.dimLength;\n                        \n        let outX = global_id.y;\n        let outY = global_id.x;\n        \n        if (outX >= xSize || outY >= ySize) {\n            return;\n        }\n\n        var xSum: f32 = 0.0;\n        var xxSum: f32 = 0.0;\n        var ySum: f32 = 0.0;\n        var yySum: f32 = 0.0;\n        var xySum: f32 = 0.0;\n        // Iterate along the dimension we're averaging\n        if (reduceDim == 0u) { // Average along Z\n            let cCoord = outX * xStride + outY * yStride;\n            for (var z: u32 = 0u; z < dimLength; z++) {\n                let inputIndex = cCoord + (z * zStride);\n                let xI = f32(firstData[inputIndex]);\n                let yI = f32(secondData[inputIndex]);\n                xSum += xI;\n                xxSum += xI * xI;\n                ySum += yI;\n                yySum += yI * yI;\n                xySum += xI * yI;\n            }\n        } else if (reduceDim == 1u) { // Average along Y\n            let cCoord = outX * xStride + outY * zStride;\n            for (var y: u32 = 0u; y < dimLength; y++) {\n                let inputIndex = cCoord + (y * yStride);\n                let xI = f32(firstData[inputIndex]);\n                let yI = f32(secondData[inputIndex]);\n                xSum += xI;\n                xxSum += xI * xI;\n                ySum += yI;\n                yySum += yI * yI;\n                xySum += xI * yI;\n            }\n        } else { // Average along X\n            let cCoord = outX * yStride + outY * zStride;\n            for (var x: u32 = 0u; x < dimLength; x++) {\n                let inputIndex = cCoord + (x * xStride);\n                let xI = f32(firstData[inputIndex]);\n                let yI = f32(secondData[inputIndex]);\n                xSum += xI;\n                xxSum += xI * xI;\n                ySum += yI;\n                yySum += yI * yI;\n                xySum += xI * yI;\n            }\n        }\n\n        let N: f32 = f32(dimLength);\n        let meanX = xSum / N;\n        let meanY = ySum / N;\n        let varX = (xxSum / N) - (meanX * meanX);\n        let varY = (yySum / N) - (meanY * meanY);\n        let covXY = (xySum / N) - (meanX * meanY);\n        let sigmaX = sqrt(max(0.0, varX));\n        let sigmaY = sqrt(max(0.0, varY));\n        let epsilon = 1e-6;\n        let denominator = sigmaX * sigmaY + epsilon;\n        let correlation = covXY / denominator;\n\n        let outputIndex = outY * xSize + outX;\n        outputData[outputIndex] = f16(correlation);\n    }\n",eV={Mean:"MeanReduction",Min:"MinReduction",Max:"MaxReduction",StDev:"StDevReduction",CUMSUM:"CUMSUMReduction",LinearSlope:"LinearSlopeReduction"},eT={Mean:"MeanConvolution",Min:"MinConvolution",Max:"MaxConvolution",StDev:"StDevConvolution"},eN={Mean:"MeanConvolution2D",Min:"MinConvolution2D",Max:"MaxConvolution2D",StDev:"StDevConvolution2D"},eE={Correlation2D:"Correlation2D",Correlation3D:"CorrelationConvolution",TwoVarLinearSlope2D:"TwoVarLinearSlopeReduction",TwoVarLinearSlope3D:"TwoVarLinearSlopeConvolution",Covariance2D:"CovarianceReduction",Covariance3D:"CovarianceConvolution"};async function eG(e,n,t,a){var o;let l=await (null==(o=navigator.gpu)?void 0:o.requestAdapter()),u=null==l?void 0:l.limits.maxBufferSize,s=null==l?void 0:l.limits.maxStorageBufferBindingSize,d=!!l&&l.features.has("shader-f16"),f=d?await (null==l?void 0:l.requestDevice({requiredFeatures:["shader-f16"],requiredLimits:{maxBufferSize:u,maxStorageBufferBindingSize:s}})):await (null==l?void 0:l.requestDevice({requiredLimits:{maxBufferSize:u,maxStorageBufferBindingSize:s}}));if(!f)return void Error("need a browser that supports WebGPU");let{strides:c,shape:m}=n,[x,p,y]=c,S=m.filter((e,n)=>n!=t),g=m[t],v=S[0]*S[1],z=S.map(e=>Math.ceil(e/16)),h=(d?i:r)[eV[a]],b=f.createShaderModule({label:"reduction compute module",code:h}),_=f.createComputePipeline({label:"reduction compute pipeline",layout:"auto",compute:{module:b}}),w=(0,R.Wu)(h),k=(0,R.FE)(w.uniforms.params);k.set({zStride:x,yStride:p,xStride:y,xSize:S[1],ySize:S[0],reduceDim:t,dimLength:g});let D=f.createBuffer({label:"Input Buffer",size:e.byteLength*(d?1:2),usage:GPUBufferUsage.STORAGE|GPUBufferUsage.COPY_DST}),I=f.createBuffer({label:"Output Buffer",size:v*(d?2:4),usage:GPUBufferUsage.STORAGE|GPUBufferUsage.COPY_SRC}),C=f.createBuffer({size:k.arrayBuffer.byteLength,usage:GPUBufferUsage.UNIFORM|GPUBufferUsage.COPY_DST}),M=f.createBuffer({label:"Output Buffer",size:v*(d?2:4),usage:GPUBufferUsage.COPY_DST|GPUBufferUsage.MAP_READ});f.queue.writeBuffer(D,0,d?e:new Float32Array(e)),f.queue.writeBuffer(C,0,k.arrayBuffer);let P=f.createBindGroup({layout:_.getBindGroupLayout(0),entries:[{binding:0,resource:{buffer:D}},{binding:1,resource:{buffer:I}},{binding:2,resource:{buffer:C}}]}),O=f.createCommandEncoder({label:"reduction encoder"}),B=O.beginComputePass({label:"reduction compute pass"});B.setPipeline(_),B.setBindGroup(0,P),B.dispatchWorkgroups(z[0],z[1]),B.end(),O.copyBufferToBuffer(I,0,M,0,v*(d?2:4)),f.queue.submit([O.finish()]),await M.mapAsync(GPUMapMode.READ);let Y=M.getMappedRange(),A=new Float16Array(d?Y.slice():new Float32Array(Y.slice()));return M.unmap(),A}async function eR(e,n,t,a){var o;let l=await (null==(o=navigator.gpu)?void 0:o.requestAdapter()),u=null==l?void 0:l.limits.maxBufferSize,s=null==l?void 0:l.limits.maxStorageBufferBindingSize,d=!!l&&l.features.has("shader-f16"),f=d?await (null==l?void 0:l.requestDevice({requiredFeatures:["shader-f16"],requiredLimits:{maxBufferSize:u,maxStorageBufferBindingSize:s}})):await (null==l?void 0:l.requestDevice({requiredLimits:{maxBufferSize:u,maxStorageBufferBindingSize:s}}));if(!f)return void Error("need a browser that supports WebGPU");let{kernelDepth:c,kernelSize:m}=a,{strides:x,shape:p}=n,y=p[0]*p[1]*p[2],[S,g,v]=x,z=p.map(e=>Math.ceil(e/4)),h=(d?i:r)[eT[t]],b=f.createShaderModule({label:"convolution compute module",code:h}),_=f.createComputePipeline({label:"convolution compute pipeline",layout:"auto",compute:{module:b}}),w=(0,R.Wu)(h),k=(0,R.FE)(w.uniforms.params);k.set({xStride:v,yStride:g,zStride:S,xSize:p[2],ySize:p[1],zSize:p[0],workGroups:[z[2],z[1],z[0]],kernelDepth:c,kernelSize:m});let D=f.createBuffer({label:"Input Buffer",size:e.byteLength*(d?1:2),usage:GPUBufferUsage.STORAGE|GPUBufferUsage.COPY_DST}),I=f.createBuffer({label:"Output Buffer",size:y*(d?2:4),usage:GPUBufferUsage.STORAGE|GPUBufferUsage.COPY_SRC}),C=f.createBuffer({label:"Uniform Buffer",size:k.arrayBuffer.byteLength,usage:GPUBufferUsage.UNIFORM|GPUBufferUsage.COPY_DST}),M=f.createBuffer({label:"Read Buffer",size:y*(d?2:4),usage:GPUBufferUsage.COPY_DST|GPUBufferUsage.MAP_READ});f.queue.writeBuffer(D,0,d?e:new Float32Array(e)),f.queue.writeBuffer(C,0,k.arrayBuffer);let P=f.createBindGroup({layout:_.getBindGroupLayout(0),entries:[{binding:0,resource:{buffer:D}},{binding:1,resource:{buffer:I}},{binding:2,resource:{buffer:C}}]}),O=f.createCommandEncoder({label:"convolution encoder"}),B=O.beginComputePass({label:"convolution compute pass"});B.setPipeline(_),B.setBindGroup(0,P),B.dispatchWorkgroups(z[2],z[1],z[0]),B.end(),O.copyBufferToBuffer(I,0,M,0,y*(d?2:4)),f.queue.submit([O.finish()]),await M.mapAsync(GPUMapMode.READ);let Y=M.getMappedRange(),A=new Float16Array(d?Y.slice():new Float32Array(Y.slice()));return M.unmap(),A}async function eF(e,n,t,a,o){var l;let u=await (null==(l=navigator.gpu)?void 0:l.requestAdapter()),s=null==u?void 0:u.limits.maxBufferSize,d=null==u?void 0:u.limits.maxStorageBufferBindingSize,f=!!u&&u.features.has("shader-f16"),c=f?await (null==u?void 0:u.requestDevice({requiredFeatures:["shader-f16"],requiredLimits:{maxBufferSize:s,maxStorageBufferBindingSize:d}})):await (null==u?void 0:u.requestDevice({requiredLimits:{maxBufferSize:s,maxStorageBufferBindingSize:d}}));if(!c)return void Error("need a browser that supports WebGPU");let{strides:m,shape:x}=t,[p,y,S]=m,g=x.filter((e,n)=>n!=a),v=x[a],z=g[0]*g[1],h=g.map(e=>Math.ceil(e/16)),b=(f?i:r)[eE[o]],_=c.createShaderModule({label:"Multivariate2D compute module",code:b}),w=c.createComputePipeline({label:"Multivariate2D compute pipeline",layout:"auto",compute:{module:_}}),k=(0,R.Wu)(b),D=(0,R.FE)(k.uniforms.params);D.set({zStride:p,yStride:y,xStride:S,xSize:g[1],ySize:g[0],reduceDim:a,dimLength:v});let I=c.createBuffer({label:"First Input Buffer",size:e.byteLength*(f?1:2),usage:GPUBufferUsage.STORAGE|GPUBufferUsage.COPY_DST}),C=c.createBuffer({label:"Second Input Buffer",size:n.byteLength*(f?1:2),usage:GPUBufferUsage.STORAGE|GPUBufferUsage.COPY_DST}),M=c.createBuffer({label:"Output Buffer",size:z*(f?2:4),usage:GPUBufferUsage.STORAGE|GPUBufferUsage.COPY_SRC}),P=c.createBuffer({size:D.arrayBuffer.byteLength,usage:GPUBufferUsage.UNIFORM|GPUBufferUsage.COPY_DST}),O=c.createBuffer({label:"Output Buffer",size:z*(f?2:4),usage:GPUBufferUsage.COPY_DST|GPUBufferUsage.MAP_READ});c.queue.writeBuffer(I,0,f?e:new Float32Array(e)),c.queue.writeBuffer(C,0,f?n:new Float32Array(n)),c.queue.writeBuffer(P,0,D.arrayBuffer);let B=c.createBindGroup({layout:w.getBindGroupLayout(0),entries:[{binding:0,resource:{buffer:I}},{binding:1,resource:{buffer:C}},{binding:2,resource:{buffer:M}},{binding:3,resource:{buffer:P}}]}),Y=c.createCommandEncoder({label:"Multivariate2D encoder"}),A=Y.beginComputePass({label:"Multivariate2D compute pass"});A.setPipeline(w),A.setBindGroup(0,B),A.dispatchWorkgroups(h[0],h[1]),A.end(),Y.copyBufferToBuffer(M,0,O,0,z*(f?2:4)),c.queue.submit([Y.finish()]),await O.mapAsync(GPUMapMode.READ);let j=O.getMappedRange(),X=new Float16Array(f?j.slice():new Float32Array(j.slice()));return O.unmap(),X}async function eq(e,n,t,a,o){var l;let u=await (null==(l=navigator.gpu)?void 0:l.requestAdapter()),s=null==u?void 0:u.limits.maxBufferSize,d=null==u?void 0:u.limits.maxStorageBufferBindingSize,f=!!u&&u.features.has("shader-f16"),c=f?await (null==u?void 0:u.requestDevice({requiredFeatures:["shader-f16"],requiredLimits:{maxBufferSize:s,maxStorageBufferBindingSize:d}})):await (null==u?void 0:u.requestDevice({requiredLimits:{maxBufferSize:s,maxStorageBufferBindingSize:d}}));if(!c)return void Error("need a browser that supports WebGPU");let{kernelDepth:m,kernelSize:x}=a,{strides:p,shape:y}=t,[S,g,v]=p,z=y[0]*y[1]*y[2],h=y.map(e=>Math.ceil(e/4)),b=(f?i:r)[eE[o]],_=c.createShaderModule({label:"Multivariate3D compute module",code:b}),w=c.createComputePipeline({label:"Multivariate3D compute pipeline",layout:"auto",compute:{module:_}}),k=(0,R.Wu)(b),D=(0,R.FE)(k.uniforms.params);D.set({xStride:v,yStride:g,zStride:S,xSize:y[2],ySize:y[1],zSize:y[0],workGroups:[h[2],h[1],h[0]],kernelDepth:m,kernelSize:x});let I=c.createBuffer({label:"First Input Buffer",size:e.byteLength*(f?1:2),usage:GPUBufferUsage.STORAGE|GPUBufferUsage.COPY_DST}),C=c.createBuffer({label:"Second Input Buffer",size:n.byteLength*(f?1:2),usage:GPUBufferUsage.STORAGE|GPUBufferUsage.COPY_DST}),M=c.createBuffer({label:"Output Buffer",size:z*(f?2:4),usage:GPUBufferUsage.STORAGE|GPUBufferUsage.COPY_SRC}),P=c.createBuffer({size:D.arrayBuffer.byteLength,usage:GPUBufferUsage.UNIFORM|GPUBufferUsage.COPY_DST}),O=c.createBuffer({label:"Output Buffer",size:z*(f?2:4),usage:GPUBufferUsage.COPY_DST|GPUBufferUsage.MAP_READ});c.queue.writeBuffer(I,0,f?e:new Float32Array(e)),c.queue.writeBuffer(C,0,f?n:new Float32Array(n)),c.queue.writeBuffer(P,0,D.arrayBuffer);let B=c.createBindGroup({layout:w.getBindGroupLayout(0),entries:[{binding:0,resource:{buffer:I}},{binding:1,resource:{buffer:C}},{binding:2,resource:{buffer:M}},{binding:3,resource:{buffer:P}}]}),Y=c.createCommandEncoder({label:"Multivariate3D encoder"}),A=Y.beginComputePass({label:"Multivariate3D compute pass"});A.setPipeline(w),A.setBindGroup(0,B),A.dispatchWorkgroups(h[2],h[1],h[0]),A.end(),Y.copyBufferToBuffer(M,0,O,0,z*(f?2:4)),c.queue.submit([Y.finish()]),await O.mapAsync(GPUMapMode.READ);let j=O.getMappedRange(),X=new Float16Array(f?j.slice():new Float32Array(j.slice()));return O.unmap(),X}async function eZ(e,n,t,a){var o;let l=await (null==(o=navigator.gpu)?void 0:o.requestAdapter()),u=null==l?void 0:l.limits.maxBufferSize,s=null==l?void 0:l.limits.maxStorageBufferBindingSize,d=!!l&&l.features.has("shader-f16"),f=d?await (null==l?void 0:l.requestDevice({requiredFeatures:["shader-f16"],requiredLimits:{maxBufferSize:u,maxStorageBufferBindingSize:s}})):await (null==l?void 0:l.requestDevice({requiredLimits:{maxBufferSize:u,maxStorageBufferBindingSize:s}}));if(!f)return void Error("need a browser that supports WebGPU");let{strides:c,shape:m}=n,x=m[0]*m[1]*m[2],[p,y,S]=c,g=m.map(e=>Math.ceil(e/4)),v=(d?i:r).CUMSUM3D,z=f.createShaderModule({label:"cumsum3d compute module",code:v}),h=f.createComputePipeline({label:"cumsum3d compute pipeline",layout:"auto",compute:{module:z}}),b=(0,R.Wu)(v),_=(0,R.FE)(b.uniforms.params);_.set({xStride:S,yStride:y,zStride:p,xSize:m[2],ySize:m[1],zSize:m[0],reduceDim:t,reverse:a,workGroups:[g[2],g[1],g[0]]});let w=f.createBuffer({label:"Input Buffer",size:e.byteLength*(d?1:2),usage:GPUBufferUsage.STORAGE|GPUBufferUsage.COPY_DST}),k=f.createBuffer({label:"Output Buffer",size:4*x,usage:GPUBufferUsage.STORAGE|GPUBufferUsage.COPY_SRC}),D=f.createBuffer({label:"Uniform Buffer",size:_.arrayBuffer.byteLength,usage:GPUBufferUsage.UNIFORM|GPUBufferUsage.COPY_DST}),I=f.createBuffer({label:"Read Buffer",size:4*x,usage:GPUBufferUsage.COPY_DST|GPUBufferUsage.MAP_READ});f.queue.writeBuffer(w,0,d?e:new Float32Array(e)),f.queue.writeBuffer(D,0,_.arrayBuffer);let C=f.createBindGroup({layout:h.getBindGroupLayout(0),entries:[{binding:0,resource:{buffer:w}},{binding:1,resource:{buffer:k}},{binding:2,resource:{buffer:D}}]}),M=f.createCommandEncoder({label:"cumsum3d encoder"}),P=M.beginComputePass({label:"cumsum3d compute pass"});P.setPipeline(h),P.setBindGroup(0,C),P.dispatchWorkgroups(g[2],g[1],g[0]),P.end(),M.copyBufferToBuffer(k,0,I,0,4*x),f.queue.submit([M.finish()]),await I.mapAsync(GPUMapMode.READ);let O=new Float32Array(I.getMappedRange().slice());return I.unmap(),O}async function eW(e,n,t,a){var o;let l=await (null==(o=navigator.gpu)?void 0:o.requestAdapter()),u=null==l?void 0:l.limits.maxBufferSize,s=null==l?void 0:l.limits.maxStorageBufferBindingSize,d=!!l&&l.features.has("shader-f16"),f=d?await (null==l?void 0:l.requestDevice({requiredFeatures:["shader-f16"],requiredLimits:{maxBufferSize:u,maxStorageBufferBindingSize:s}})):await (null==l?void 0:l.requestDevice({requiredLimits:{maxBufferSize:u,maxStorageBufferBindingSize:s}}));if(!f)return void Error("need a browser that supports WebGPU");let{strides:c,shape:m}=n,x=m[0]*m[1],[p,y]=[c[0],c[1]],S=[Math.ceil(m[1]/16),Math.ceil(m[0]/16)],g=(d?i:r)[eN[t]],v=f.createShaderModule({label:"convolution2d compute module",code:g}),z=f.createComputePipeline({label:"convolution2d compute pipeline",layout:"auto",compute:{module:v}}),h=(0,R.Wu)(g),b=(0,R.FE)(h.uniforms.params);b.set({xStride:y,yStride:p,xSize:m[1],ySize:m[0],kernelSize:a});let _=f.createBuffer({label:"Input Buffer",size:e.byteLength*(d?1:2),usage:GPUBufferUsage.STORAGE|GPUBufferUsage.COPY_DST}),w=f.createBuffer({label:"Output Buffer",size:x*(d?2:4),usage:GPUBufferUsage.STORAGE|GPUBufferUsage.COPY_SRC}),k=f.createBuffer({label:"Uniform Buffer",size:b.arrayBuffer.byteLength,usage:GPUBufferUsage.UNIFORM|GPUBufferUsage.COPY_DST}),D=f.createBuffer({label:"Read Buffer",size:x*(d?2:4),usage:GPUBufferUsage.COPY_DST|GPUBufferUsage.MAP_READ});f.queue.writeBuffer(_,0,d?e:new Float32Array(e)),f.queue.writeBuffer(k,0,b.arrayBuffer);let I=f.createBindGroup({layout:z.getBindGroupLayout(0),entries:[{binding:0,resource:{buffer:_}},{binding:1,resource:{buffer:w}},{binding:2,resource:{buffer:k}}]}),C=f.createCommandEncoder({label:"convolution2d encoder"}),M=C.beginComputePass({label:"convolution2d compute pass"});M.setPipeline(z),M.setBindGroup(0,I),M.dispatchWorkgroups(S[0],S[1],1),M.end(),C.copyBufferToBuffer(w,0,D,0,x*(d?2:4)),f.queue.submit([C.finish()]),await D.mapAsync(GPUMapMode.READ);let P=D.getMappedRange(),O=new Float16Array(d?P.slice():new Float32Array(P.slice()));return D.unmap(),O}let eH=e=>{let{setTexture:n,ZarrDS:t}=e,{strides:r,dataShape:i,valueScales:a,isFlat:l,setIsFlat:u,setDownloading:d,setShowLoading:m,setValueScales:x}=(0,f.on)((0,c.k)(e=>({strides:e.strides,dataShape:e.dataShape,valueScales:e.valueScales,isFlat:e.isFlat,setIsFlat:e.setIsFlat,setDownloading:e.setDownloading,setShowLoading:e.setShowLoading,setValueScales:e.setValueScales}))),y=(0,f.Ws)(e=>e.setPlotType),{axis:S,execute:g,operation:v,useTwo:z,variable2:h,valueScalesOrig:b,kernelSize:_,kernelDepth:w,kernelOperation:k,reverseDirection:D,analysisStore:I,analysisMode:C,analysisArray:M,setValueScalesOrig:P,setAnalysisArray:O,setAnalysisMode:B}=(0,f.r2)((0,c.k)(e=>({axis:e.axis,execute:e.execute,operation:e.operation,useTwo:e.useTwo,variable2:e.variable2,valueScalesOrig:e.valueScalesOrig,kernelSize:e.kernelSize,kernelDepth:e.kernelDepth,kernelOperation:e.kernelOperation,reverseDirection:e.reverseDirection,analysisStore:e.analysisStore,analysisMode:e.analysisMode,analysisArray:e.analysisArray,setValueScalesOrig:e.setValueScalesOrig,setAnalysisArray:e.setAnalysisArray,setAnalysisMode:e.setAnalysisMode}))),Y=(0,f.SZ)(e=>e.slice),A=(0,s.useRef)(new Float32Array(1));return(0,s.useEffect)(()=>{let e=(0,p.Td)(I);if(!(e.length<=1)&&!l)if(m(!0),z)(async function(){if(d(!0),A.current=await t.GetArray(h,Y),d(!1),["TwoVarLinearSlope2D","Correlation2D","Covariance2D"].includes(v)){let t=i.filter((e,n)=>n!=S),l=await eF(C?M:e,A.current.data,{shape:i,strides:r},S,v);b||P(a);let[s,d]=[-1,1];["TwoVarLinearSlope2D","Covariance2D"].includes(v)&&([s,d]=(0,p.Qt)(l)),x({minVal:s,maxVal:d});let f=new Uint8Array(l.map(e=>(e-s)/(d-s)).map(e=>isNaN(e)?255:254*e)),c=new o.GYF(f,t[1],t[0],o.VT0,o.OUM);c.needsUpdate=!0,O(l),n(c),u(!0),y("flat")}else{let t=await eq(C?M:e,A.current.data,{shape:i,strides:r},{kernelDepth:w,kernelSize:_},v);b||P(a);let[l,s]=[-1,1];["TwoVarLinearSlope3D","Covariance3D"].includes(v)&&([l,s]=(0,p.Qt)(t)),x({minVal:l,maxVal:s});let d=new Uint8Array(t.map(e=>(e-l)/(s-l)).map(e=>isNaN(e)?255:254*e)),f=new o.dYF(d,i[2],i[1],i[0]);f.format=o.VT0,f.minFilter=o.hxR,f.magFilter=o.hxR,f.needsUpdate=!0,O(t),n(f),u(!1),y("volume")}})().then(e=>{B(!0),m(!1)});else if("Convolution"!=v){let t=i.filter((e,n)=>n!=S),l="CUMSUM3D"==v;!async function(){let s,d,f;if(!(s="CUMSUM3D"==v?await eZ(C?M:e,{shape:i,strides:r},S,D):await eG(C?M:e,{shape:i,strides:r},S,v)))return;["StDev","CUMSUM","CUMSUM3D","LinearSlope"].includes(v)?([d,f]=(0,p.Qt)(s),b||P(a),x({minVal:d,maxVal:f})):b?(d=b.minVal,f=b.maxVal,x(b),P(null)):(d=a.minVal,f=a.maxVal);let c=new Uint8Array(s.map(e=>(e-d)/(f-d)).map(e=>isNaN(e)?255:254*e)),g=l?new o.dYF(c,i[2],i[1],i[0]):new o.GYF(c,t[1],t[0],o.VT0,o.OUM);l&&(g.format=o.VT0,g.minFilter=o.hxR,g.magFilter=o.hxR),g.needsUpdate=!0,O(s),n(g),"CUMSUM3D"!=v&&(u(!0),y("flat")),B(!0),m(!1)}()}else eR(C?M:e,{shape:i,strides:r},k,{kernelDepth:w,kernelSize:_}).then(e=>{let t,r;if(!e)return;"StDev"==k?([t,r]=(0,p.Qt)(e),b||P(a),x({minVal:t,maxVal:r})):b?(t=b.minVal,r=b.maxVal,x(b),P(null)):(t=a.minVal,r=a.maxVal);let l=new Uint8Array(e.map(e=>(e-t)/(r-t)).map(e=>isNaN(e)?255:254*e)),s=new o.dYF(l,i[2],i[1],i[0]);s.format=o.VT0,s.minFilter=o.hxR,s.magFilter=o.hxR,s.needsUpdate=!0,O(e),n(s),u(!1),y("volume")}).then(e=>{B(!0),m(!1)})},[g]),(0,s.useEffect)(()=>{let e=(0,p.Td)(I);if(!(e.length<=1)&&l&&(m(!0),!z))if("Convolution"!=v);else{let t=i.length>2?i.slice(1):i;eW(C?M:e,{shape:t,strides:r.length>2?r.slice(1):r},k,_).then(e=>{let r,i;if(!e)return;"StDev"==k?([r,i]=(0,p.Qt)(e),b||P(a),x({minVal:r,maxVal:i})):b?(r=b.minVal,i=b.maxVal,x(b),P(null)):(r=a.minVal,i=a.maxVal);let l=new Uint8Array(e.map(e=>(e-r)/(i-r)).map(e=>isNaN(e)?255:254*e)),u=new o.GYF(l,t[1],t[0],o.VT0,o.OUM);u.needsUpdate=!0,O(e),n(u),B(!0),m(!1)})}},[g]),null},eQ=e=>{let{show:n}=e,{valueScales:t,variable:r,metadata:i}=(0,f.on)((0,c.k)(e=>({valueScales:e.valueScales,variable:e.variable,metadata:e.metadata}))),{exportImg:l,enableExport:u,includeBackground:d,includeColorbar:x,doubleSize:p,useCustomRes:y,getCbarLoc:S,getCbarNum:g,getCustomRes:v,setHideAxisControls:z,setHideAxis:b}=(0,f.qi)((0,c.k)(e=>({exportImg:e.exportImg,enableExport:e.enableExport,includeBackground:e.includeBackground,includeColorbar:e.includeColorbar,doubleSize:e.doubleSize,useCustomRes:e.useCustomRes,getCbarLoc:e.getCbarLoc,getCbarNum:e.getCbarNum,getCustomRes:e.getCustomRes,setHideAxisControls:e.setHideAxisControls,setHideAxis:e.setHideAxis}))),{gl:_,scene:w,camera:k}=(0,m.C)(),D=(0,h.$m)("--text-plot"),I=(0,h.$m)("--background");return(0,s.useEffect)(()=>{if(!n||!u)return;let e=_.domElement.width,a=_.domElement.height,l=v(),s=y?l[0]:p?2*e:e,f=y?l[1]:p?2*a:a,c=document.createElement("canvas"),m=c.getContext("2d");if(!m)return;if(c.width=s,c.height=f,d&&(m.fillStyle=I,m.fillRect(0,0,c.width,c.height)),y){let e,n=_.getSize(new o.I9Y);if(k instanceof o.ubm)e={aspect:k.aspect},k.aspect=s/f,k.updateProjectionMatrix();else if(k instanceof o.qUd){e={left:k.left,right:k.right,top:k.top,bottom:k.bottom};let n=s/f;if(n>(k.right-k.left)/(k.top-k.bottom)){let e=(k.top-k.bottom)*n,t=(k.left+k.right)/2;k.left=t-e/2,k.right=t+e/2}else{let e=(k.right-k.left)/n,t=(k.top+k.bottom)/2;k.top=t+e/2,k.bottom=t-e/2}k.updateProjectionMatrix()}_.setSize(s,f),_.render(w,k),m.drawImage(_.domElement,0,0,s,f),k instanceof o.ubm?k.aspect=e.aspect:k instanceof o.qUd&&(k.left=e.left,k.right=e.right,k.top=e.top,k.bottom=e.bottom),_.setSize(n.x,n.y),k.updateProjectionMatrix(),b(!1),z(!1),_.render(w,k)}else _.render(w,k),m.drawImage(_.domElement,0,0,s,f),_.render(w,k),b(!1),z(!1);m.fillStyle=D,m.font="".concat(p?72:36,'px "Segoe UI"'),m.fillText(r,p?40:20,p?100:50);let h=p?52:26;if(x){let n=document.getElementById("colorbar-canvas"),r=S(),a=p?Math.min(1024,.8*e):Math.min(512,.8*e),o=p?48:24,l=Math.round(s/2-a/2),u="top"===r?p?140:70:p?f-140:f-70,d="right"===r||"left"===r;if(d){let e=a;a=o,u=Math.round(f/2-(o=e)/2),l="right"===r?p?s-140:s-70:p?140:70}if(n instanceof HTMLCanvasElement)if(d){m.save();let e=l+a/2,t=u+o/2;m.translate(e,t),m.rotate(-Math.PI/2);let r=p?1024:512,i=p?48:24;m.drawImage(n,-r/2,-i/2,r,i),m.restore()}else m.drawImage(n,l,u,a,o);let c=g(),x=t.maxVal-t.minVal,y=1/(c-1),v=d?1/(c-1)*o:1/(c-1)*a;if(m.font="".concat(p?36:18,'px "Segoe UI"'),d){m.textBaseline="middle",m.textAlign="left"==r?"left":"right";for(let e=0;e<c;e++)"left"==r?m.fillText(String((t.minVal+e*y*x).toFixed(2)),l+a+6,u+o-e*v):m.fillText(String((t.minVal+e*y*x).toFixed(2)),l-6,u+o-e*v)}else{m.textBaseline="top",m.textAlign="center";for(let e=0;e<c;e++)m.fillText(String((t.minVal+e*y*x).toFixed(2)),l+e*v,u+o+6)}m.fillStyle=D,m.font="".concat(h,'px "Segoe UI" bold'),m.textAlign="center",m.fillText(null==i?void 0:i.units,l+a/2,u-h-4)}m.fillStyle="#888888",m.font="".concat(p?40:20,'px "Segoe UI", serif '),m.textAlign="left",m.textBaseline="bottom",m.fillText("browzarr.io",p?20:10,p?f-20:f-10),c.toBlob(e=>{if(!e)return;let n=URL.createObjectURL(e),t=document.createElement("a");t.download="browzarr-plot.png",t.href=n,t.click(),URL.revokeObjectURL(n)},"image/png")},[l]),(0,a.jsx)(a.Fragment,{})},e$=e=>{let{isFlat:n}=e,{resetCamera:t}=(0,f.Ws)((0,c.k)(e=>({resetCamera:e.resetCamera}))),r=(0,s.useRef)(null),i=(0,s.useRef)(!1);return(0,s.useEffect)(()=>{if(!i.current){i.current=!0;return}if(r.current){let e,t=r.current,i=performance.now(),a=t.object.position.clone(),l=t.position0.clone(),u=t.target.clone(),s=t.target0.clone(),d=t.object.zoom,f=r=>{(0,m.m)();let c=Math.min((r-i)/1e3,1);t.object.position.lerpVectors(a,l,c),t.target.lerpVectors(u,s,c),n&&(t.object.zoom=o.cj9.lerp(d,1e3,c),t.object.updateProjectionMatrix(),t.update()),c<1&&(e=requestAnimationFrame(f))};return e=requestAnimationFrame(f),()=>cancelAnimationFrame(e)}},[t]),(0,a.jsxs)(a.Fragment,{children:[n&&(0,a.jsx)(T.N,{ref:r,enableRotate:!1,enablePan:!0,maxDistance:50,minZoom:50,maxZoom:3e3}),!n&&(0,a.jsx)(T.N,{ref:r,enableRotate:!0,enablePan:!0,maxDistance:50})]})},eJ=e=>{let{ZarrDS:n}=e,{setShape:t,setDataShape:r,setFlipY:i,setValueScales:l,setMetadata:u,setDimArrays:d,setDimNames:m,setDimUnits:y,setPlotOn:g,setShowLoading:b}=(0,f.on)((0,c.k)(e=>({setShape:e.setShape,setDataShape:e.setDataShape,setFlipY:e.setFlipY,setValueScales:e.setValueScales,setMetadata:e.setMetadata,setDimArrays:e.setDimArrays,setDimNames:e.setDimNames,setDimUnits:e.setDimUnits,setPlotOn:e.setPlotOn,setShowLoading:e.setShowLoading}))),{colormap:_,variable:w,isFlat:k,metadata:D,valueScales:I,is4D:C,setIsFlat:M}=(0,f.on)((0,c.k)(e=>({colormap:e.colormap,variable:e.variable,isFlat:e.isFlat,metadata:e.metadata,valueScales:e.valueScales,is4D:e.is4D,setIsFlat:e.setIsFlat}))),{plotType:P}=(0,f.Ws)((0,c.k)(e=>({plotType:e.plotType}))),{slice:O,reFetch:B}=(0,f.SZ)((0,c.k)(e=>({slice:e.slice,reFetch:e.reFetch}))),Y=(0,s.useRef)([0,0]),A=(0,s.useRef)(0),[j,X]=(0,s.useState)(!1),[L,U]=(0,s.useState)([0,0]),[V,T]=(0,s.useState)(null),[N,R]=(0,s.useState)(!0);(0,s.useEffect)(()=>{if("Default"!=w){b(!0),R(!1);try{n.GetArray(w,O).then(e=>{let[n,i]=(0,E.oW)({data:e.data,shape:e.shape});if(n instanceof o.GYF||n instanceof o.dYF?T(n):(console.error("Invalid texture type returned from ArrayToTexture"),T(null)),e.scalingFactor){let{maxVal:n,minVal:t}=i;l({maxVal:n*Math.pow(10,e.scalingFactor),minVal:t*Math.pow(10,e.scalingFactor)})}else l(i);2==e.shape.length?M(!0):M(!1);let a=e.shape[1]/e.shape[2]*2;t(new o.Pq0(2,a,2)),r(e.shape),R(!0),g(!0),b(!1)})}catch(e){b(!1);return}n.GetAttributes(w).then(e=>{u(e);let[t,r,a]=n.GetDimArrays();C&&(t=t.slice(1),r=r.slice(1),a=a.slice(1)),d(t),m(a),t.length>2?t[1][1]<t[1][0]?i(!0):i(!1):t[0][1]<t[0][0]?i(!0):i(!1);let o=[];for(let e of r)o.push(e.units);y(o),(0,p.QB)(o,t)})}else u(null)},[B]);let F=(0,s.useMemo)(()=>({setLoc:U,setShowInfo:X,coords:Y,val:A}),[]),q=(0,s.useMemo)(()=>h.Fp,[]);return(0,a.jsxs)("div",{className:"main-canvas",style:{width:"100vw"},children:[(0,a.jsx)(eH,{setTexture:T,ZarrDS:n}),N&&(0,a.jsx)(h.PL,{units:null==D?void 0:D.units,valueScales:I}),(0,a.jsx)(q,{}),(k||"flat"==P)&&(0,a.jsx)(G,{loc:L,show:j,info:[...Y.current,A.current]}),(!k&&"flat"!=P||k&&"sphere"===P)&&(0,a.jsx)(a.Fragment,{children:(0,a.jsxs)(z.Hl,{id:"main-canvas",camera:{position:k?[0,0,5]:[-4.5,3,4.5],fov:50},frameloop:"demand",gl:{preserveDrawingBuffer:!0},children:[(0,a.jsx)(e9,{}),(0,a.jsx)(eQ,{show:N}),N&&(0,a.jsx)(nr,{}),"volume"==P&&N&&(0,a.jsxs)(a.Fragment,{children:[(0,a.jsx)(x,{volTexture:V}),(0,a.jsx)(S,{ZarrDS:n})]}),"point-cloud"==P&&N&&(0,a.jsx)(a.Fragment,{children:(0,a.jsx)(v,{textures:{texture:V,colormap:_},ZarrDS:n})}),"sphere"==P&&N&&(0,a.jsx)(e1,{texture:V,ZarrDS:n}),(0,a.jsx)(e$,{isFlat:!1})]})}),(k||"flat"==P)&&(0,a.jsx)(a.Fragment,{children:(0,a.jsxs)(z.Hl,{id:"main-canvas",camera:{position:[0,0,5],zoom:1e3},orthographic:!0,frameloop:"demand",children:[(0,a.jsx)(eQ,{show:N}),(0,a.jsx)(e9,{}),N&&(0,a.jsx)(nr,{}),(0,a.jsx)(e2,{texture:V,infoSetters:F}),(0,a.jsx)(e$,{isFlat:!0})]})})]})};function eK(e){let{points:n,tsID:t,pointSetters:r,scalers:i}=e,l=(0,s.useRef)(null),u=n.length,d=(0,s.useRef)(null),[x,p]=(0,s.useState)(!1),{setPointID:y,setPointLoc:S,setShowPointInfo:g}=r,[v,z]=(0,s.useState)(1),{pointColor:h,pointSize:b,useCustomPointColor:_}=(0,f.Ws)((0,c.k)(e=>({pointColor:e.pointColor,pointSize:e.linePointSize,showPoints:e.showPoints,useCustomPointColor:e.useCustomPointColor}))),{xScale:w,yScale:k}=i,{timeSeries:D}=(0,f.on)((0,c.k)(e=>({timeSeries:e.timeSeries}))),[I,C,M]=D[t].color,P=(0,s.useMemo)(()=>new o.Gu$(b),[b]),O=(0,s.useMemo)(()=>new o.V9B({color:new o.Q1f().setRGB(I/300,C/300,M/300).convertSRGBToLinear()}),[h,_,D]);return(0,s.useEffect)(()=>{if(l.current){let e=new o.B69;for(let t=0;t<u;t++){let r=n[t].toArray();e.position.set(r[0]*(w/2),r[1]*k,1),e.scale.set(b/v,b/v,b/v),e.updateMatrix(),l.current.setMatrixAt(t,e.matrix)}l.current.instanceMatrix.needsUpdate=!0}},[n,v,P,O,w,k,b]),(0,m.D)(e=>{let{camera:n}=e;n.zoom!==v&&z(n.zoom)}),(0,a.jsx)(a.Fragment,{children:(0,a.jsx)("mesh",{position:[0,0,5],onPointerEnter:function(e){if(l.current){let n=e.instanceId,r=new o.B69,i=new o.kn4,a=new o.Pq0;n!=d.current&&d.current&&(l.current.getMatrixAt(d.current,i),a.setFromMatrixPosition(i),r.scale.set(b/v,b/v,b/v),r.position.copy(a),r.updateMatrix(),l.current.setMatrixAt(d.current,r.matrix)),d.current=n,l.current.getMatrixAt(n,i),a.setFromMatrixPosition(i),r.scale.set(3*b/v,3*b/v,3/v),r.position.copy(a),r.updateMatrix(),l.current.setMatrixAt(e.instanceId,r.matrix),l.current.instanceMatrix.needsUpdate=!0,p(e=>!e),y([t,e.instanceId]),S([e.clientX,e.clientY]),g(!0)}},onPointerLeave:function(e){let n=e.instanceId;if(l.current){let e=new o.B69,t=new o.kn4,r=new o.Pq0;d.current&&(l.current.getMatrixAt(n,t),r.setFromMatrixPosition(t),e.scale.set(b/v,b/v,b/v),e.position.copy(r),e.updateMatrix(),l.current.setMatrixAt(n,e.matrix),l.current.instanceMatrix.needsUpdate=!0,p(e=>!e),g(n!=d.current))}},children:(0,a.jsx)("instancedMesh",{ref:l,args:[P,O,u]})})})}let e0=e=>{let{height:n,xScale:t,yScale:r,pointSetters:i}=e,{valueScales:l,timeSeries:u,colormap:d}=(0,f.on)((0,c.k)(e=>({valueScales:e.valueScales,timeSeries:e.timeSeries,colormap:e.colormap}))),{lineWidth:x,useLineColor:p,lineColor:y,showPoints:S,lineResolution:g,useCustomColor:v}=(0,f.Ws)((0,c.k)(e=>({lineWidth:e.lineWidth,linePointSize:e.linePointSize,showPoints:e.showPoints,useLineColor:e.useLineColor,lineColor:e.lineColor,lineResolution:e.lineResolution,useCustomColor:e.useCustomColor}))),{camera:z}=(0,m.C)(),{maxVal:h,minVal:b}=l,_=(0,s.useMemo)(()=>{let e={};return Object.keys(u).reverse().map((n,i)=>{let[a,l,s]=u[n].color;e[n]=new o.BKk({glslVersion:o.Wdf,uniforms:{cmap:{value:d},xScale:{value:t},yScale:{value:r},aspect:{value:window.innerWidth/window.innerHeight},thickness:{value:x},miter:{value:1},useLineColor:{value:v},useMapColors:{value:p},lineColor:{value:new o.Q1f().setRGB(a/255,l/255,s/255)},userColor:{value:new o.Q1f(y)},zoom:{value:z.zoom}},vertexShader:"attribute float direction; \nattribute vec3 next;\nattribute vec3 previous;\nattribute float normed;\n\nvarying float vNormed;\n\nuniform float zoom;\nuniform float thickness;\nuniform int miter;\nuniform float xScale; \nuniform float yScale;\n\nfloat getOrthographicZoom(mat4 projectionMatrix, float referenceWidth) {\n    float m0 = projectionMatrix[0][0]; // Scaling factor: 2/(right-left)\n    float viewWidth = 2.0 / m0; // Viewable width\n    return referenceWidth / viewWidth; // Zoom level\n}\n\nvoid main() {\n    vec3 pos = position;\n    vec3 prev = previous;\n    vec3 nex = next;\n    pos.x *= xScale/2.0;\n    pos.y *= yScale;\n    prev.x *= xScale/2.0;\n    prev.y *= yScale;\n    nex.x *= xScale/2.0;\n    nex.y *= yScale;\n\n    // Transform positions to view space (before projection)\n    float zoom = getOrthographicZoom(projectionMatrix, 2.);\n    float zoomLevel = 2. / projectionMatrix[0][0]; // Extract vertical scale\n    vec4 currentView = modelViewMatrix * vec4(pos, 1.0);\n    vec4 prevView = modelViewMatrix * vec4(prev, 1.0);\n    vec4 nextView = modelViewMatrix * vec4(nex, 1.0);\n\n    // Compute directions in view space\n    vec3 dir = vec3(0.0);\n    if (currentView.xyz == prevView.xyz) {\n        dir = normalize(nextView.xyz - currentView.xyz);\n    } else if (currentView.xyz == nextView.xyz) {\n        dir = normalize(currentView.xyz - prevView.xyz);\n    } else {\n        vec3 dirA = normalize(currentView.xyz - prevView.xyz);\n        if (miter == 1) {\n            vec3 dirB = normalize(nextView.xyz - currentView.xyz);\n            vec3 tangent = normalize(dirA + dirB);\n            vec3 perp = vec3(-dirA.y, dirA.x, 0.0); // Perpendicular in view space\n            vec3 miterVec = vec3(-tangent.y, tangent.x, 0.0);\n            float miterLen = dot(miterVec, perp);\n            miterLen = max(miterLen, 0.5); // Avoid division by zero\n            dir = tangent;\n        } else {\n            dir = dirA;\n        }\n    }\n\n    // Compute normal in view space\n    vec3 normal = vec3(-dir.y, dir.x, 0.0); // Perpendicular to direction\n    float len = thickness / zoom/500.; // Thickness in world/view space units\n    normal *= 0.5 * len * direction; // Apply thickness and direction\n\n    // Apply offset in view space\n    currentView.xyz += normal;\n\n    // Project to clip space\n    gl_Position = projectionMatrix * currentView;\n\n\n    vNormed = normed;\n    gl_PointSize = 1.0;\n}",fragmentShader:"\n                out vec4 Color;\n                uniform sampler2D cmap;\n                uniform bool useLineColor;\n                uniform bool useMapColors;\n                uniform vec3 lineColor;\n                uniform vec3 userColor;\n                varying float vNormed;\n\n                void main() {\n                    vec4 texColor = texture(cmap, vec2(vNormed, 0.1));\n                    texColor.a = 1.;\n                    Color = useLineColor ? vec4(userColor, 1.0) : useMapColors ? texColor : vec4(lineColor, 1.0) ;\n                }\n                ",depthWrite:!1})}),e},[u]);(0,s.useEffect)(()=>{if(Object.values(_))for(let e of Object.values(_)){let n=e.uniforms;n.cmap.value=d,n.xScale.value=t,n.yScale.value=r,n.aspect.value=window.innerWidth/window.innerHeight,n.thickness.value=x,n.miter.value=1,n.useLineColor.value=v,n.useMapColors.value=p,n.userColor.value=new o.Q1f(y),n.zoom.value=z.zoom,(0,m.m)()}},[d,x,t,r,window.innerWidth,window.innerHeight,p,y,z.zoom,v]);let w=(0,s.useMemo)(()=>window.innerWidth,[window.innerWidth]),k=(0,s.useMemo)(()=>window.innerHeight-n,[window.innerWidth,n]),[D,I]=(0,s.useState)({}),C=(0,s.useMemo)(()=>{let e={},n={};return Object.keys(u).map((t,r)=>{let i=u[t].data,a=i.map(e=>(e-b)/(h-b)),l=function(e,n,t){let r=(n-e)/(t-1);return Array.from({length:t},(n,t)=>e+r*t)}(-w,w,i.length),s=a.map((e,n)=>new o.Pq0(l[n],(e-.5)*k,5));n[t]=s;let d=new o.B6O(s).getPoints(s.length*g-1),f=[];for(let e=0;e<d.length;e++){let n=e/(d.length-1)*(a.length-1),t=Math.floor(n),r=Math.min(a.length-1,Math.ceil(n)),i=n-t;f.push(a[t]*(1-i)+a[r]*i)}let c=d.length,m=[],x=[],p=[],y=[],S=[],v=[];for(let e=0;e<c;e++){let n=d[e],t=d[Math.max(0,e-1)],r=d[Math.min(c-1,e+1)];m.push(...n,...n),x.push(1,-1),p.push(...t,...t),y.push(...r,...r),S.push(f[e],f[e])}for(let e=0;e<c-1;e++){let n=2*e,t=n+1,r=n+2,i=n+3;v.push(n,t,r),v.push(t,i,r)}let z=new o.LoY;z.setAttribute("position",new o.qtW(m,3)),z.setAttribute("direction",new o.qtW(x,1)),z.setAttribute("previous",new o.qtW(p,3)),z.setAttribute("next",new o.qtW(y,3)),z.setAttribute("normed",new o.qtW(S,1)),z.setIndex(new o.A$4(v,1)),e[t]=z}),I(n),e},[u,g]);return(0,s.useEffect)(()=>{(0,m.m)()},[S]),(0,a.jsx)(a.Fragment,{children:(0,a.jsxs)("group",{children:[Object.keys(u).map((e,n)=>(0,a.jsx)("mesh",{geometry:C[e],material:_[e]},"lineMesh_".concat(n))),S&&Object.keys(u).map((e,n)=>(0,a.jsx)(eK,{points:D[e],tsID:e,pointSetters:i,scalers:{xScale:t,yScale:r}},"plotPoints_".concat(n)))]})})},e2=e=>{let{texture:n,infoSetters:t}=e,{setLoc:r,setShowInfo:i,val:l,coords:u}=t,{flipY:d,colormap:m,valueScales:x,dimArrays:y,isFlat:S}=(0,f.on)((0,c.k)(e=>({flipY:e.flipY,colormap:e.colormap,valueScales:e.valueScales,dimArrays:e.dimArrays,isFlat:e.isFlat}))),{cScale:g,cOffset:v,animProg:z,nanTransparency:h,nanColor:b}=(0,f.Ws)((0,c.k)(e=>({cOffset:e.cOffset,cScale:e.cScale,resetAnim:e.resetAnim,animate:e.animate,animProg:e.animProg,nanTransparency:e.nanTransparency,nanColor:e.nanColor}))),{axis:_,analysisMode:w,analysisArray:k}=(0,f.r2)((0,c.k)(e=>({axis:e.axis,analysisMode:e.analysisMode,analysisArray:e.analysisArray}))),D=n.source.data,I=(0,s.useMemo)(()=>D.height/D.width,[D]),C=(0,s.useMemo)(()=>new o.bdM(2,2*I),[I]),M=(0,s.useRef)(!1),P=(0,s.useRef)(new o.I9Y(0,0)),O=w&&2==_,B=(0,s.useMemo)(()=>w?k:(0,p.Td)(),[w,k]),Y=(0,s.useMemo)(()=>y.length>2?y.filter((e,n)=>n!=_):y,[y,_]),A=(0,s.useMemo)(()=>new o.BKk({glslVersion:o.Wdf,uniforms:{cScale:{value:g},cOffset:{value:v},data:{value:n},cmap:{value:m},animateProg:{value:z},nanColor:{value:new o.Q1f(b)},nanAlpha:{value:1-h}},vertexShader:" // by Jeran Poehls\r\nvarying vec2 vUv;\r\n\r\nvoid main() {\r\n    vUv = uv;\r\n    gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);\r\n}",fragmentShader:S?" // Basic Shader for colors on a plane used in FlatMap with 2D data\r\nprecision highp float;\r\nprecision highp sampler3D;\r\n\r\nout vec4 color;\r\n\r\nvarying vec2 vUv;\r\n\r\nuniform sampler2D data;\r\nuniform sampler2D cmap;\r\nuniform float nanAlpha;\r\nuniform vec3 nanColor;\r\nuniform float cOffset;\r\nuniform float cScale;\r\n\r\nvoid main(){\r\n\r\n    float strength = texture2D(data, vUv).r;\r\n    bool isNaN = strength == 1.;\r\n    float sampLoc = isNaN ? strength: (strength - 0.5)*cScale + 0.5;\r\n    sampLoc = isNaN ? strength : min(sampLoc+cOffset,0.995);\r\n    color = isNaN ? vec4(nanColor, nanAlpha) : vec4(texture2D(cmap, vec2(sampLoc, 0.5)).rgb, 1.);\r\n\r\n}":"//This is for Flat Textures but with 3D textures to sample from i,e; animation\r\n\r\nuniform sampler3D data;\r\nuniform sampler2D cmap;\r\n\r\nuniform float cOffset;\r\nuniform float cScale;\r\nuniform float animateProg;\r\nuniform float nanAlpha;\r\nuniform vec3 nanColor;\r\n\r\nvarying vec2 vUv;\r\nout vec4 Color;\r\n\r\nvoid main() {\r\n\r\n    float strength = texture(data,vec3(vUv, animateProg)).r;\r\n    bool isNaN = strength == 1.;\r\n    float sampLoc = isNaN ? strength: (strength)*cScale;\r\n    sampLoc = isNaN ? strength : min(sampLoc+cOffset,0.995);\r\n    Color = isNaN ? vec4(nanColor, nanAlpha) : vec4(texture2D(cmap, vec2(sampLoc, 0.5)).rgb, 1.);\r\n\r\n}",side:o.$EB}),[]);(0,s.useEffect)(()=>{if(A){let e=A.uniforms;e.cOffset.value=v,e.data.value=n,e.cmap.value=m,e.animateProg.value=z,e.nanColor.value=new o.Q1f(b),e.nanAlpha.value=1-h,e.cScale.value=g}},[g,v,n,m,z,b,h]),(0,s.useEffect)(()=>{C.dispose()},[C]);let j=(0,s.useRef)(null),X=(0,s.useCallback)(e=>{if(M.current&&e.uv){j.current=e,r([e.clientX,e.clientY]),P.current=e.uv;let{x:n,y:t}=e.uv,i=S?w?Y[1].length:y[1].length:y[2].length,a=S?w?Y[0].length:y[0].length:y[1].length,o=Math.round(n*i-.5),s=Math.round(t*a-.5),d=i*s+o;d+=S?0:Math.floor((y[0].length-1)*z)*i*a;let f=B?B[d]:0;l.current=S&&!w?function(e,n){return e*(n.maxVal-n.minVal)+n.minVal}(f,x):f,u.current=S?w?[Y[0][s],Y[1][o]]:[y[0][s],y[1][o]]:[y[1][s],y[2][o]]}},[B,y,z]);return(0,a.jsx)(a.Fragment,{children:(0,a.jsx)("mesh",{material:A,geometry:C,scale:[w&&2==_&&d?-1:1,d||w&&2==_?-1:1,1],rotation:[0,0,O?Math.PI/2:0],onPointerEnter:()=>{i(!0),M.current=!0},onPointerLeave:()=>{i(!1),M.current=!1},onPointerMove:X})})};function e3(e){return e*Math.PI/180}let e1=e=>{let{texture:n,ZarrDS:t}=e,{colormap:r,isFlat:i}=(0,f.on)((0,c.k)(e=>({colormap:e.colormap,isFlat:e.isFlat}))),{setPlotDim:l,updateDimCoords:u,updateTimeSeries:m}=(0,f.on)((0,c.k)(e=>({setPlotDim:e.setPlotDim,updateDimCoords:e.updateDimCoords,updateTimeSeries:e.updateTimeSeries}))),{analysisMode:x,analysisArray:S}=(0,f.r2)((0,c.k)(e=>({analysisMode:e.analysisMode,analysisArray:e.analysisArray}))),{dimArrays:g,dimNames:v,dimUnits:z,timeSeries:h,dataShape:b,strides:_}=(0,f.on)((0,c.k)(e=>({dimArrays:e.dimArrays,dimNames:e.dimNames,dimUnits:e.dimUnits,timeSeries:e.timeSeries,dataShape:e.dataShape,strides:e.strides}))),{animate:w,animProg:k,cOffset:D,cScale:I,selectTS:C,lonExtent:M,latExtent:P,lonResolution:O,latResolution:B,nanColor:Y,nanTransparency:A,getColorIdx:j,incrementColorIdx:X}=(0,f.Ws)((0,c.k)(e=>({animate:e.animate,animProg:e.animProg,cOffset:e.cOffset,cScale:e.cScale,selectTS:e.selectTS,lonExtent:e.lonExtent,latExtent:e.latExtent,lonResolution:e.lonResolution,latResolution:e.latResolution,nanColor:e.nanColor,nanTransparency:e.nanTransparency,getColorIdx:e.getColorIdx,incrementColorIdx:e.incrementColorIdx}))),[L,U]=(0,s.useState)({}),[V,T]=(0,s.useState)(Array(10).fill(new o.IUQ(-1,-1,-1,-1))),{height:N,width:E}=(0,s.useMemo)(()=>null==n?void 0:n.source.data,[n]);(0,s.useEffect)(()=>{let e=Object.keys(L),n=Object.keys(h),t=(e=e.filter(e=>n.includes(e))).map(e=>L[e]);T([...t,...Array(Math.max(0,10-t.length)).fill(new o.IUQ(-1,-1,-1,-1))])},[L,h]);let[G,R]=(0,s.useMemo)(()=>{let e=B/2,n=O/2;return[[Math.max(M[0]-n,-180),Math.min(M[1]+n,180)],[Math.max(P[0]-e,-90),Math.min(P[1]+e,90)]]},[P,M,O,B]),F=(0,s.useMemo)(()=>new o.WBB(1,9),[]),q=(0,s.useMemo)(()=>new o.BKk({glslVersion:o.Wdf,uniforms:{map:{value:n},selectTS:{value:C},selectBounds:{value:V},cmap:{value:r},cOffset:{value:D},cScale:{value:I},animateProg:{value:k},latBounds:{value:new o.I9Y(e3(R[0]),e3(R[1]))},lonBounds:{value:new o.I9Y(e3(G[0]),e3(G[1]))},nanColor:{value:new o.Q1f(Y)},nanAlpha:{value:1-A}},vertexShader:d,fragmentShader:i?" // by Jeran Poehls\nprecision highp float;\nprecision highp sampler2D;\n\nout vec4 color;\n\nin vec3 aPosition;\n\nuniform sampler2D map;\nuniform sampler2D cmap;\n\nuniform float cOffset;\nuniform float cScale;\nuniform float animateProg;\nuniform bool selectTS;\nuniform vec2 latBounds;\nuniform vec2 lonBounds;\nuniform vec3 nanColor;\nuniform float nanAlpha;\n\n#define pi 3.141592653\n\nvec2 giveUV(vec3 position){\n    vec3 n = normalize(position);\n    float latitude = asin(n.y);\n    float longitude = atan(n.z, n.x);\n    latitude = (latitude - latBounds.x)/(latBounds.y - latBounds.x);\n    longitude = (longitude - lonBounds.x)/(lonBounds.y - lonBounds.x);\n\n    return vec2(1.-longitude, latitude);\n}\n\nvoid main(){\n    vec2 sampleCoord = giveUV(aPosition);\n    float strength = texture(map, sampleCoord).r;\n    bool isNaN = strength == 1.;\n    strength = isNaN ? strength : (strength - 0.5)*cScale + 0.5;\n    strength = isNaN ? strength : min(strength+cOffset,0.99);\n    color = isNaN ? vec4(nanColor, nanAlpha) : texture(cmap, vec2(strength, 0.5));\n    if (!isNaN){\n        color.a = 1.;\n    }\n\n\n}":" // by Jeran Poehls\nprecision highp float;\nprecision highp sampler3D;\n\nout vec4 color;\n\nin vec3 aPosition;\n\nuniform sampler3D map;\nuniform sampler2D cmap;\n\nuniform float cOffset;\nuniform float cScale;\nuniform float animateProg;\nuniform vec4[10] selectBounds; \nuniform bool selectTS;\nuniform vec2 latBounds;\nuniform vec2 lonBounds;\nuniform vec3 nanColor;\nuniform float nanAlpha;\n\n#define pi 3.141592653\n\nvec2 giveUV(vec3 position){\n    vec3 n = normalize(position);\n    float latitude = asin(n.y);\n    float longitude = atan(n.z, n.x);\n    latitude = (latitude - latBounds.x)/(latBounds.y - latBounds.x);\n    longitude = (longitude - lonBounds.x)/(lonBounds.y - lonBounds.x);\n\n    return vec2(1.-longitude, latitude);\n}\n\nbool isValid(vec2 sampleCoord){\n    for (int i = 0; i < 10; i++){\n        vec4 thisBound = selectBounds[i];\n        if (thisBound.x == -1.){\n            return false;\n        }\n        bool cond = (sampleCoord.x < thisBound.r || sampleCoord.x > thisBound.g || sampleCoord.y < thisBound.b ||  sampleCoord.y > thisBound.a);\n        if (!cond){\n            return true;\n        }\n    }\n    return false;\n}\n\nvoid main(){\n    vec2 sampleCoord = giveUV(aPosition);\n    bool inBounds = all(greaterThanEqual(sampleCoord, vec2(0.0))) && \n                all(lessThanEqual(sampleCoord, vec2(1.0)));\n    \n    if (inBounds) {\n    float strength = texture(map, vec3(sampleCoord, animateProg)).r;\n    bool isNaN = strength == 1.;\n    strength = isNaN ? strength : (strength)*cScale;\n    strength = isNaN ? strength : min(strength+cOffset,0.99);\n    color = isNaN ? vec4(nanColor, nanAlpha) : texture(cmap, vec2(strength, 0.5));\n    if (!isNaN){\n        color.a = 1.;\n    }\n    bool cond = isValid(sampleCoord);\n    if (!cond && selectTS){\n        color.rgb *= 0.65;\n    }\n    } else {\n        color = vec4(nanColor, 1.); // Black\n        color.a = nanAlpha;\n    }\n    \n    // color = vec4(sampleCoord, 0., 1.0);\n\n}",blending:o.NTi,side:o.hB5,transparent:!0,depthWrite:!1}),[]);(0,s.useEffect)(()=>{if(q){let e=q.uniforms;e.map.value=n,e.selectTS.value=C,e.selectBounds.value=V,e.cmap.value=r,e.cOffset.value=D,e.cScale.value=I,e.animateProg.value=k,e.latBounds.value=new o.I9Y(e3(R[0]),e3(R[1])),e.lonBounds.value=new o.I9Y(e3(G[0]),e3(G[1])),e.nanColor.value=new o.Q1f(Y),e.nanAlpha.value=1-A}},[n,k,r,D,I,w,V,C,G,R,Y,A]);let Z=q.clone();return Z.side=o.hsX,(0,a.jsxs)(a.Fragment,{children:[(0,a.jsx)("mesh",{renderOrder:1,geometry:F,material:q,onClick:e=>C&&function(e){let n=function(e,n,t){let r=Math.atan2(e.z,e.x),i=Math.asin(e.y),a=(r-e3(t[0]))/(e3(t[1])-e3(t[0])),l=(i-e3(n[0]))/(e3(n[1])-e3(n[0]));return new o.I9Y(1-a,l)}(e.point.normalize(),R,G),r=new o.Pq0(0,0,1);if(t){var i,a;let e=(0,p.PE)({data:x?S:(0,p.Td)(),shape:b,stride:_},{uv:n,normal:r}),t=r.toArray().map((e,n)=>Math.abs(e)>0?n:null).filter(e=>null!==e);l(2-t[0]);let s=(0,p.jT)({normal:r,uv:n}).map((e,n)=>e?g[n][Math.round(e*g[n].length)]:null),d=v.filter((e,n)=>null!==s[n]),f=z.filter((e,n)=>null!==s[n]);s=s.filter(e=>null!==e);let c="".concat(s[0],"_").concat(s[1]),h={color:(0,y.md)(j()/10,"Paired"),data:e};X(),m({[c]:h}),u({[c]:{first:{name:d[0],loc:null!=(i=s[0])?i:0,units:f[0]},second:{name:d[1],loc:null!=(a=s[1])?a:0,units:f[1]},plot:{units:z[2-t[0]]}}}),function(e,n){let t=Math.floor(e.x*E)+.5,r=Math.ceil(e.y*N)-.5,i=1/E,a=1/N,l={[n]:new o.IUQ(...[t/E-i/2,t/E+i/2],...[r/N-a/2,r/N+a/2])};U(e=>({...l,...e}))}(n,c)}}(e)}),(0,a.jsx)("mesh",{renderOrder:0,geometry:F,material:Z})]})};function e5(e,n,t){let[r,i]=e,a=(r-n[0])/(n[1]-n[0]),o=(i-t[0])/(t[1]-t[0]);return a-=.5,o-=.5,[a*=2,(o*=2)/2,0]}function e4(e){let[n,t]=e,r=t*Math.PI/180,i=n*Math.PI/180;return[Math.cos(r)*Math.cos(i)*1.001,1.001*Math.sin(r),Math.cos(r)*Math.sin(i)*1.001]}function e6(e){let{features:n}=e,{xRange:t,yRange:r,plotType:i,borderColor:l,lonExtent:u,latExtent:x,lonResolution:p,latResolution:y}=(0,f.Ws)((0,c.k)(e=>({xRange:e.xRange,yRange:e.yRange,plotType:e.plotType,borderColor:e.borderColor,lonExtent:e.lonExtent,latExtent:e.latExtent,lonResolution:e.lonResolution,latResolution:e.latResolution}))),{flipY:S,shape:g}=(0,f.on)((0,c.k)(e=>({flipY:e.flipY,shape:e.shape}))),[v,z]=(0,s.useMemo)(()=>{let e=y/2,n=p/2,t=[Math.max(u[0]-n,-180),Math.min(u[1]+n,180)],r=[Math.max(x[0]-e,-90),Math.min(x[1]+e,90)];return[t,r=S?[r[1],r[0]]:r]},[x,u,p,y]),[h,b]=(0,s.useState)(!1);(0,s.useEffect)(()=>{"sphere"===i?b(!0):b(!1)},[i]);let _=(0,s.useMemo)(()=>new o.BKk({glslVersion:o.Wdf,vertexShader:d,fragmentShader:"precision highp float;\r\nprecision highp sampler3D;\r\n\r\nout vec4 color;\r\n\r\nin vec3 aPosition;\r\n\r\nuniform vec2 xBounds;\r\nuniform vec2 yBounds;\r\nuniform vec3 borderColor;\r\nuniform bool trim;\r\n\r\nvoid main() {\r\n\r\n    if ((aPosition.x < xBounds.x || aPosition.x > xBounds.y || aPosition.y < yBounds.x || aPosition.y > yBounds.y) && trim){\r\n        discard;\r\n    }\r\n\r\n    color = vec4(borderColor, 1.0);\r\n}",uniforms:{xBounds:{value:new o.I9Y(t[0],t[1])},yBounds:{value:new o.I9Y(r[0]/g.x,r[1]/g.x)},borderColor:{value:new o.Q1f(l)},trim:{value:!h}}}),[]);(0,s.useEffect)(()=>{if(_){let e=_.uniforms;e.xBounds.value=new o.I9Y(t[0],t[1]),e.yBounds.value=new o.I9Y(r[0]/g.x,r[1]/g.x),e.borderColor.value=new o.Q1f(l),e.trim.value=!h,(0,m.m)()}},[t,r,l,h]);let w=(0,s.useMemo)(()=>n.flatMap((e,n)=>{let t=[];if("LineString"===e.geometry.type){let n=[];e.geometry.coordinates.forEach(e=>{let[t,r]=e,[i,a,l]=h?e4([-t,r]):e5([t,r],v,z);n.push(new o.Pq0(i,a,l))});let r=new Float32Array(3*n.length);n.forEach((e,n)=>{r.set([e.x,e.y,e.z],3*n)});let i=new o.LoY;i.setAttribute("position",new o.THS(r,3)),t.push(i)}else"MultiPolygon"===e.geometry.type?e.geometry.coordinates.forEach((e,n)=>{let r=n,i=e[0],a=[];i.forEach(e=>{let[n,t]=e;r++;let[i,l,u]=h?e4([-n,t]):e5([n,t],v,z);a.push(new o.Pq0(i,l,u))});let l=new Float32Array(3*a.length);a.forEach((e,n)=>{l.set([e.x,e.y,e.z],3*n)});let u=new o.LoY;u.setAttribute("position",new o.THS(l,3)),t.push(u)}):("Polygon"===e.geometry.type?[e.geometry.coordinates]:e.geometry.coordinates).forEach(e=>{let n=[];e.forEach(e=>{e.forEach(e=>{let[t,r]=e,[i,a,l]=h?e4([-t,r]):e5([t,r],v,z);n.push(new o.Pq0(i,a,l))})});let r=new Float32Array(3*n.length);n.forEach((e,n)=>{r.set([e.x,e.y,e.z],3*n)});let i=new o.LoY;i.setAttribute("position",new o.THS(r,3)),t.push(i)});return t}),[n,h,S,v,z]),k=(0,s.useMemo)(()=>w.map((e,n)=>{let t=new o.N1A(e,_);return(0,a.jsx)("primitive",{object:t},"border-".concat(n))}),[w,_]);return(0,a.jsx)(a.Fragment,{children:k})}let e9=()=>{let[e,n]=(0,s.useState)(null),[t,r]=(0,s.useState)(null),[i,o]=(0,s.useState)(!1),{dataShape:l,is4D:u}=(0,f.on)((0,c.k)(e=>({dataShape:e.dataShape,is4D:e.is4D}))),{zRange:d,plotType:x,showBorders:p,timeScale:y}=(0,f.Ws)((0,c.k)(e=>({zRange:e.zRange,plotType:e.plotType,showBorders:e.showBorders,timeScale:e.timeScale}))),{analysisMode:S,axis:g}=(0,f.r2)((0,c.k)(e=>({analysisMode:e.analysisMode,axis:e.axis}))),[v,z]=(0,s.useState)(!1);(0,s.useEffect)(()=>{"sphere"===x?z(!0):z(!1)},[x]),(0,m.D)(e=>{let{camera:n}=e;!v&&(Math.abs(n.rotation.z)>Math.PI/2?o(!0):i&&o(!1))}),(0,s.useEffect)(()=>{fetch("./ne_110m_coastline.json").then(e=>e.json()).then(e=>n(e.features)),fetch("./ne_110m_admin_0_countries.json").then(e=>e.json()).then(e=>r(e.features))},[]);let h="point-cloud"==x,b=l[0]/l[2]*y;return(0,a.jsxs)("group",{visible:p&&!(S&&0!=g),position:v?[0,0,0]:[0,0,i?d[0]*(h?b:1):d[1]*(h?b:1)],children:[e&&(0,a.jsx)(e6,{features:e}),t&&(0,a.jsx)(e6,{features:t})]})};var e8=t(8004),e7=t(1409),ne=t(2821);let nn=e=>{let{flipX:n,flipY:t,flipDown:r}=e,{dimArrays:i,dimNames:l,dimUnits:u,shape:d,dataShape:m}=(0,f.on)((0,c.k)(e=>({dimArrays:e.dimArrays,dimNames:e.dimNames,dimUnits:e.dimUnits,shape:e.shape,dataShape:e.dataShape}))),{xRange:x,yRange:y,zRange:S,plotType:g,timeScale:v,animProg:z}=(0,f.Ws)((0,c.k)(e=>({xRange:e.xRange,yRange:e.yRange,zRange:e.zRange,plotType:e.plotType,timeScale:e.timeScale,animProg:e.animProg}))),{hideAxis:b,hideAxisControls:_}=(0,f.qi)((0,c.k)(e=>({hideAxis:e.hideAxis,hideAxisControls:e.hideAxisControls}))),w=[i[0].length,i[1].length,i[2].length],[k,D]=(0,s.useState)(7),[I,C]=(0,s.useState)(7),[M,P]=(0,s.useState)(7),O=(0,s.useMemo)(()=>"point-cloud"==g,[g]),B=(0,s.useMemo)(()=>m[0]/m[1]*v/2,[m,v]),Y=(0,s.useMemo)(()=>d.y/d.x,[d]),A=(0,h.$m)("--text-plot"),j=(0,s.useMemo)(()=>{if(A)return new o.Q1f(A).getHex()},[A]),X=(0,s.useMemo)(()=>new ne.G({color:j||0,linewidth:2}),[j]),L=(0,s.useMemo)(()=>{let e=new e8.n().setPositions([x[0]-.025,0,0,x[1]+.025,0,0]);return new e7.b(e,X)},[x,X]),U=(0,s.useMemo)(()=>{let e=new e8.n().setPositions([0,y[0]*Y,0,0,y[1]*Y+.025,0]);return new e7.b(e,X)},[y,Y,X]),T=(0,s.useMemo)(()=>{let e=new e8.n().setPositions([0,0,O?S[0]*B-.025:S[0]-.025,0,0,O?S[1]*B+.025:S[1]+.025]);return new e7.b(e,X)},[S,B,O,X]),N=(0,s.useMemo)(()=>{let e=new e8.n().setPositions([0,0,0,0,0,.05]);return new e7.b(e,X)},[X]),E=k/(k-1),G=1/(k-1),R=I/(I-1),F=1/(I-1),q=M/(M-1),Z=1/(M-1);return(0,a.jsxs)("group",{visible:"sphere"!=g&&"flat"!=g&&!b,children:[(0,a.jsxs)("group",{position:[0,Y*y[0],0],children:[(0,a.jsxs)("group",{position:[0,0,n?O?S[0]*B-.025:S[0]-.025:O?S[1]*B+.025:S[1]+.025],rotation:[r?n?-Math.PI/2:Math.PI/2:0,0,0],children:[(0,a.jsx)("primitive",{object:L},"xLine"),Array(k).fill(null).map((e,t)=>(x[0]+1)/2<=t*E/k&&(x[1]+1)/2>=t*E/k&&(0,a.jsxs)("group",{position:[-1+t*E/(k/2),0,0],children:[(0,a.jsx)("primitive",{object:N.clone(),rotation:[0,n?Math.PI:0,0]},t),(0,a.jsx)(V.E,{anchorX:0==t?n?"right":"left":t==k-1?n?"left":"right":"center",anchorY:"top",fontSize:.05,color:j,"material-depthTest":!1,rotation:[-Math.PI/2,0,n?Math.PI:0],position:[0,0,n?-.05:.05],children:(0,p.SB)(i[2][Math.floor((w[2]-1)*t*G)],u[2])},"textX_".concat(t))]},"xGroup_".concat(t))),(0,a.jsxs)("group",{rotation:[-Math.PI/2,0,n?Math.PI:0],position:[(x[0]+x[1])/2,0,n?-.2:.2],children:[(0,a.jsx)(V.E,{anchorX:"center",anchorY:"top",fontSize:.1,color:j,"material-depthTest":!1,children:l[2]},"xTitle"),(0,a.jsxs)("group",{visible:!_,children:[k<20&&(0,a.jsx)(V.E,{anchorX:"center",anchorY:"middle",fontSize:.2,color:j,"material-depthTest":!1,position:[.2,-.2,0],onClick:e=>D(e=>Math.min(e+1,20)),onPointerEnter:e=>document.body.style.cursor="pointer",onPointerLeave:e=>document.body.style.cursor="default",children:"+"},"xAdd"),k>1&&(0,a.jsx)(V.E,{anchorX:"center",anchorY:"middle",fontSize:.2,color:j,"material-depthTest":!1,position:[-.2,-.2,0],onClick:e=>D(e=>Math.max(e-1,1)),onPointerEnter:e=>document.body.style.cursor="pointer",onPointerLeave:e=>document.body.style.cursor="default",children:"-"},"xSub")]})]})]}),(0,a.jsxs)("group",{position:[t?x[1]+.025:x[0]-.025,0,0],rotation:[0,0,r?t?-Math.PI/2:Math.PI/2:0],children:[(0,a.jsx)("primitive",{object:T},"zLine"),Array(M).fill(null).map((e,n)=>(S[0]+1)/2<=n*q/M&&(S[1]+1)/2>=n*q/M&&(0,a.jsxs)("group",{position:[0,0,O?-B+n*q/(M/2)*B:-1+n*q/(M/2)],children:[(0,a.jsx)("primitive",{object:N.clone(),rotation:[0,t?Math.PI/2:-Math.PI/2,0]},n),(0,a.jsx)(V.E,{anchorX:0==n?t?"right":"left":n==M-1?t?"left":"right":"center",anchorY:"top",fontSize:.04,color:j,"material-depthTest":!1,rotation:[-Math.PI/2,0,t?Math.PI/2:-Math.PI/2],position:[t?.05:-.05,0,0],children:(0,p.SB)(i[0][(Math.floor((w[0]-1)*n*Z)+Math.floor(w[0]*z))%w[0]],u[0])},"textY_".concat(n))]},"zGroup_".concat(n))),(0,a.jsxs)("group",{rotation:[-Math.PI/2,0,t?Math.PI/2:-Math.PI/2],position:[t?.2:-.2,0,O?(S[0]+S[1])/2*B:(S[0]+S[1])/2],children:[(0,a.jsx)(V.E,{anchorX:"center",anchorY:"top",fontSize:.1,color:j,"material-depthTest":!1,children:l[0]},"zTitle"),(0,a.jsxs)("group",{visible:!_,children:[M<20&&(0,a.jsx)(V.E,{anchorX:"center",anchorY:"middle",fontSize:.2,color:j,"material-depthTest":!1,position:[.2,-.2,0],onClick:e=>P(e=>Math.min(e+1,20)),onPointerEnter:e=>document.body.style.cursor="pointer",onPointerLeave:e=>document.body.style.cursor="default",children:"+"},"zAdd"),M>1&&(0,a.jsx)(V.E,{anchorX:"center",anchorY:"middle",fontSize:.2,color:j,"material-depthTest":!1,position:[-.2,-.2,0],onClick:e=>P(e=>Math.max(e-1,1)),onPointerEnter:e=>document.body.style.cursor="pointer",onPointerLeave:e=>document.body.style.cursor="default",children:"-"},"zSub")]})]})]})]}),(0,a.jsxs)("group",{position:[t?x[0]-.025:x[1]+.025,0,n?O?S[0]*B-.025:S[0]-.025:O?S[1]*B+.025:S[1]+.025],children:[(0,a.jsx)("primitive",{object:U},"yLine"),Array(I).fill(null).map((e,r)=>(y[0]+1)/2<=r*R/I&&(y[1]+1)/2>=r*R/I&&(0,a.jsxs)("group",{position:[0,-d.y/2+r*R/(I/2)*Y,0],children:[(0,a.jsx)("primitive",{object:N.clone(),rotation:[0,t?-Math.PI/2:Math.PI/2,0]},r),(0,a.jsx)(V.E,{anchorX:t?n?"left":"right":n?"right":"left",anchorY:"middle",fontSize:.05,color:j,"material-depthTest":!1,rotation:[0,n?Math.PI:0,0],position:[t?-.07:.07,0,0],children:(0,p.SB)(i[1][Math.floor((w[1]-1)*r*F)],u[1])},"text_".concat(r))]},"yGroup_".concat(r))),(0,a.jsxs)("group",{rotation:[0,n?Math.PI:0,0],position:[t?-.25:.25,(y[0]+y[1])/2*Y,0],children:[(0,a.jsx)(V.E,{anchorX:t?n?"left":"right":n?"right":"left",anchorY:"middle",fontSize:.1,color:j,"material-depthTest":!1,children:l[1]},"yTitle"),(0,a.jsxs)("group",{visible:!_,children:[I<20&&(0,a.jsx)(V.E,{anchorX:"center",anchorY:"middle",fontSize:.2,color:j,"material-depthTest":!1,position:[t==n?.2:-.2,.2,0],onClick:e=>C(e=>Math.min(e+1,20)),onPointerEnter:e=>document.body.style.cursor="pointer",onPointerLeave:e=>document.body.style.cursor="default",children:"+"},"zAdd"),I>1&&(0,a.jsx)(V.E,{anchorX:"center",anchorY:"middle",fontSize:.2,color:j,"material-depthTest":!1,position:[t==n?.2:-.2,-.2,0],onClick:e=>C(e=>Math.max(e-1,1)),onPointerEnter:e=>document.body.style.cursor="pointer",onPointerLeave:e=>document.body.style.cursor="default",children:"-"},"zSub")]})]})]})]})},nt=()=>{let{dimArrays:e,dimNames:n,dimUnits:t}=(0,f.on)((0,c.k)(e=>({dimArrays:e.dimArrays,dimNames:e.dimNames,dimUnits:e.dimUnits}))),{plotType:r}=(0,f.Ws)((0,c.k)(e=>({plotType:e.plotType}))),{hideAxis:i,hideAxisControls:l}=(0,f.qi)((0,c.k)(e=>({hideAxis:e.hideAxis,hideAxisControls:e.hideAxisControls}))),{analysisMode:u,axis:d}=(0,f.r2)((0,c.k)(e=>({analysisMode:e.analysisMode,axis:e.axis}))),m=2==e.length,x=(0,s.useMemo)(()=>u&&!m?e.filter((e,n)=>n!=d).map(e=>e.length):e.map(e=>e.length),[d,e,u]),y=(0,s.useMemo)(()=>u&&2==d&&!m,[d,u]),S=y?x.length-2:x.length-1,g=y?x.length-1:x.length-2,[v,z]=(0,s.useState)(7),[b,_]=(0,s.useState)(7),{axisArrays:w,axisUnits:k,axisNames:D}=(0,s.useMemo)(()=>u&&!m?{axisArrays:e.filter((e,n)=>n!=d),axisUnits:t.filter((e,n)=>n!=d),axisNames:n.filter((e,n)=>n!=d)}:{axisArrays:e,axisUnits:t,axisNames:n},[u,e,t,n]),I=(0,s.useMemo)(()=>(u,x[g]/x[S]),[x,u,d]),C=(0,h.$m)("--text-plot"),M=(0,s.useMemo)(()=>{if(C)return new o.Q1f(C).getHex()},[C]),P=(0,s.useMemo)(()=>new ne.G({color:M||0,linewidth:2}),[M]),O=(0,s.useMemo)(()=>{let e=new e8.n().setPositions([-1/(y?I:1)-.025,0,0,1/(y?I:1)+.025,0,0]);return new e7.b(e,P)},[P,y,I]),B=(0,s.useMemo)(()=>{let e=new e8.n().setPositions([0,-(y?1:I)-.025,0,0,(y?1:I)+.025,0]);return new e7.b(e,P)},[I,P,y,I]),Y=(0,s.useMemo)(()=>{let e=new e8.n().setPositions([0,0,0,0,0,.05]);return new e7.b(e,P)},[P,y]),A=v/(v-1),j=1/(v-1),X=b/(b-1),L=1/(b-1);return(0,a.jsxs)("group",{visible:"flat"==r&&!i,children:[(0,a.jsxs)("group",{position:[0,-(y?1:I)-.025,0],rotation:[Math.PI/2,0,0],children:[(0,a.jsx)("primitive",{object:O},"xLine"),Array(v).fill(null).map((e,n)=>v>1&&(0,a.jsxs)("group",{position:[-(y?1/I:1)+n*A/(v/2)*(y?1/I:1),0,0],children:[(0,a.jsx)("primitive",{object:Y.clone(),rotation:[0,0,0]},n),(0,a.jsx)(V.E,{anchorX:"center",anchorY:"top",fontSize:.05,color:M,"material-depthTest":!1,rotation:[-Math.PI/2,0,0],position:[0,0,.05],children:(0,p.SB)(w[S][Math.floor((x[S]-1)*n*j)],k[S])},"textX_".concat(n))]},"xGroup_".concat(n))),(0,a.jsxs)("group",{rotation:[-Math.PI/2,0,0],position:[0,0,.2],children:[(0,a.jsx)(V.E,{anchorX:"center",anchorY:"top",fontSize:.1,color:M,"material-depthTest":!1,children:D[S]},"xTitle"),(0,a.jsxs)("group",{visible:!l,children:[v<20&&(0,a.jsx)(V.E,{anchorX:"center",anchorY:"middle",fontSize:.15,color:M,"material-depthTest":!1,position:[.2,-.15,0],onClick:e=>z(e=>Math.min(e+1,20)),onPointerEnter:e=>document.body.style.cursor="pointer",onPointerLeave:e=>document.body.style.cursor="default",children:"+"},"xAdd"),v>1&&(0,a.jsx)(V.E,{anchorX:"center",anchorY:"middle",fontSize:.15,color:M,"material-depthTest":!1,position:[-.2,-.15,0],onClick:e=>z(e=>Math.max(e-1,1)),onPointerEnter:e=>document.body.style.cursor="pointer",onPointerLeave:e=>document.body.style.cursor="default",children:"-"},"xSub")]})]})]}),(0,a.jsxs)("group",{position:[-(y?1/I:1)-.025,0,0],children:[(0,a.jsx)("primitive",{object:B},"yLine"),Array(b).fill(null).map((e,n)=>b>1&&(0,a.jsxs)("group",{position:[0,-(y?1:I)+n*X/(b/2)*(y?1:I),0],rotation:[0,0,Math.PI],children:[(0,a.jsx)("primitive",{object:Y.clone(),rotation:[0,Math.PI/2,0]},n),(0,a.jsx)(V.E,{anchorX:"right",anchorY:"middle",fontSize:.05,color:M,"material-depthTest":!1,rotation:[0,0,-Math.PI],position:[.07,0,0],children:(0,p.SB)(w[g][Math.floor((x[g]-1)*n*L)],k[g])},"text_".concat(n))]},"yGroup_".concat(n))),(0,a.jsxs)("group",{rotation:[0,0,0],position:[-.25,0,0],children:[(0,a.jsx)(V.E,{anchorX:"right",anchorY:"middle",fontSize:.1,color:M,"material-depthTest":!1,children:D[g]},"yTitle"),(0,a.jsxs)("group",{visible:!l,children:[b<20&&(0,a.jsx)(V.E,{anchorX:"center",anchorY:"middle",fontSize:.15,color:M,"material-depthTest":!1,position:[-.1,.2,0],onClick:e=>_(e=>Math.min(e+1,20)),onPointerEnter:e=>document.body.style.cursor="pointer",onPointerLeave:e=>document.body.style.cursor="default",children:"+"},"zAdd"),b>1&&(0,a.jsx)(V.E,{anchorX:"center",anchorY:"middle",fontSize:.15,color:M,"material-depthTest":!1,position:[-.1,-.2,0],onClick:e=>_(e=>Math.max(e-1,1)),onPointerEnter:e=>document.body.style.cursor="pointer",onPointerLeave:e=>document.body.style.cursor="default",children:"-"},"zSub")]})]})]})]})},nr=()=>{let[e,n]=(0,s.useState)(!1),[t,r]=(0,s.useState)(!1),[i,o]=(0,s.useState)(!1),{isFlat:l}=(0,f.on)((0,c.k)(e=>({isFlat:e.isFlat})));return(0,m.D)(a=>{let{camera:l}=a,u=Math.abs(l.rotation.z)>Math.PI/2;e!==u&&n(u);let s=l.rotation.z>0&&l.rotation.x<0||l.rotation.z<=0&&l.rotation.x>0;t!==s&&r(s);let d=l.rotation.x>0||l.position.y<=0;i!==d&&o(d)}),(0,a.jsxs)(a.Fragment,{children:[!l&&(0,a.jsx)(nn,{flipX:e,flipY:t,flipDown:i}),(0,a.jsx)(nt,{})]})};var ni=t(3463);let na=()=>{let e=(0,s.useRef)(null),{gl:n}=(0,m.C)(),{setMaxTextureSize:t,setMax3DTextureSize:r}=(0,f.Ws)((0,c.k)(e=>({setMaxTextureSize:e.setMaxTextureSize,setMax3DTextureSize:e.setMax3DTextureSize})));(0,s.useEffect)(()=>{let e=n.getContext();r(e.getParameter(e.MAX_3D_TEXTURE_SIZE)),t(e.getParameter(e.MAX_TEXTURE_SIZE))},[]);let{colormap:i}=(0,f.on)((0,c.k)(e=>({colormap:e.colormap}))),{spherePositions:l,cubePositions:u,planePositions:d}=(0,s.useMemo)(()=>{let e=new Float32Array(46875),n=new Float32Array(46875),t=new Float32Array(46875),r=Math.PI*(3-Math.sqrt(5));for(let n=0;n<15625;n++){let t=1-n/15624*2,i=Math.sqrt(1-t*t),a=r*n,o=Math.cos(a)*i,l=Math.sin(a)*i;e[3*n]=1.2*o,e[3*n+1]=1.2*t,e[3*n+2]=1.2*l}let i=0;for(let e=0;e<25;e++)for(let t=0;t<25;t++)for(let r=0;r<25;r++)n[3*i]=(e/25-.5)*2,n[3*i+1]=(t/25-.5)*2,n[3*i+2]=(r/25-.5)*2,i++;i=0;for(let e=0;e<125;e++)for(let n=0;n<125;n++)t[3*i]=(e/125-.5)*2.5,t[3*i+1]=(n/125-.5)*2.5,t[3*i+2]=0,i++;return{spherePositions:e,cubePositions:n,planePositions:t}},[15625]),x=(0,s.useMemo)(()=>new o.BKk({glslVersion:o.Wdf,uniforms:{uSphereMix:{value:1},uCubeMix:{value:0},uPlaneMix:{value:0},uTime:{value:0},cmap:{value:i}},vertexShader:"uniform float uSphereMix;\r\nuniform float uCubeMix;\r\nuniform float uPlaneMix;\r\nuniform float uSize;\r\nuniform float uTime;\r\nuniform sampler2D cmap;\r\n\r\nattribute vec3 aSpherePosition;\r\nattribute vec3 aCubePosition;\r\nattribute vec3 aPlanePosition;\r\n\r\nvarying vec3 vColor; \r\n\r\nvoid main() {\r\n    // Linearly interpolate between the three shapes using the mix uniforms\r\n    vec3 pos = mix(aSpherePosition, aCubePosition, uCubeMix);\r\n    pos = mix(pos, aPlanePosition, uPlaneMix);\r\n\r\n    // Add a slight sine wave animation to make it more dynamic\r\n    // pos.y += sin(pos.x * 50.0 + uTime) * 0.005;\r\n    // pos.x += cos(pos.y * 50.0 + uTime) * 0.005;\r\n\r\n    float minBrightness = 0.2;\r\n    float maxBrightness = 0.96;\r\n\r\n    float r = sin(pos.z + (uTime * 0.2 ) )  ;\r\n    float g = cos(pos.y + (uTime * 0.3 ) );\r\n    float b = cos(pos.x+pos.y + (uTime * 0.5));\r\n\r\n    vColor = vec3(r, g, b);\r\n    float mag = min(((sin(r+g+b) + 1.) /2.), 0.996) ;\r\n    vec4 sampled = texture(cmap, vec2(mag, 0.5));\r\n    vColor = sampled.rgb;\r\n    // Calculate luminance (perceived brightness)\r\n\r\n    vec4 modelPosition = modelMatrix * vec4(pos, 1.0);\r\n    vec4 viewPosition = viewMatrix * modelPosition;\r\n    vec4 projectedPosition = projectionMatrix * viewPosition;\r\n\r\n    gl_Position = projectedPosition;\r\n\r\n    // Make points smaller as they are further away (perspective)\r\n    gl_PointSize = (15.0 / -viewPosition.z);\r\n}\r\n\r\n",fragmentShader:"// Fragment Shader\r\n\r\nin vec3 vColor;\r\nout vec4 Color;\r\n\r\nvoid main() {\r\n    // Simple white color for the points\r\n    Color = vec4(vColor, 0.8);\r\n}"}),[]);return(0,s.useEffect)(()=>{let e=null;if(x){let n=x.uniforms;(e=ni.Ay.timeline({repeat:-1,yoyo:!1})).to(n.uCubeMix,{value:1,duration:2,delay:3,ease:"power2.inOut"}),e.to(n.uCubeMix,{value:0,duration:2,delay:3,ease:"power2.inOut"}),e.to(n.uPlaneMix,{value:1,duration:2,ease:"power2.inOut"},"<"),e.to(n.uPlaneMix,{value:0,duration:2,delay:3,ease:"power2.inOut"})}return()=>{e&&e.kill()}},[]),(0,m.D)(n=>{x&&(x.uniforms.uTime.value=n.clock.getElapsedTime()),e.current&&(e.current.rotation.y+=.001,e.current.rotation.x+=.001)}),(0,s.useEffect)(()=>{x&&(x.uniforms.cmap.value=i)},[i]),(0,a.jsx)("points",{ref:e,material:x,children:(0,a.jsxs)("bufferGeometry",{children:[(0,a.jsx)("bufferAttribute",{attach:"attributes-position",args:[l,3],count:15625}),(0,a.jsx)("bufferAttribute",{attach:"attributes-aSpherePosition",args:[l,3],count:15625}),(0,a.jsx)("bufferAttribute",{attach:"attributes-aCubePosition",args:[u,3],count:15625}),(0,a.jsx)("bufferAttribute",{attach:"attributes-aPlanePosition",args:[d,3],count:15625})]})})},no=()=>(0,a.jsx)("div",{className:"w-[100vw] h-[100vh]",children:(0,a.jsx)(z.Hl,{camera:{position:[0,0,3]},children:(0,a.jsx)(na,{})})});o.l2R.enabled=!0;let nl=function(){let{initStore:e,timeSeries:n,variable:t,metadata:r,plotOn:i,setZMeta:o,setVariables:d,setPlotOn:m,setTitleDescription:x}=(0,f.on)((0,c.k)(e=>({initStore:e.initStore,timeSeries:e.timeSeries,variable:e.variable,metadata:e.metadata,plotOn:e.plotOn,setZMeta:e.setZMeta,setVariables:e.setVariables,setPlotOn:e.setPlotOn,setTitleDescription:e.setTitleDescription}))),{currentStore:p,setCurrentStore:y}=(0,f.SZ)((0,c.k)(e=>({currentStore:e.currentStore,setCurrentStore:e.setCurrentStore})));(0,s.useEffect)(()=>{e.startsWith("local")||y((0,u.Oe)(e))},[e,y]);let S=(0,s.useMemo)(()=>new u.Y5(p),[p]);return(0,s.useEffect)(()=>{let e=!0;(0,l.tz)(p).then(n=>{e&&x(n)});let n=(0,l.Tk)(p),t=(0,l.Bi)(n);return n.then(e=>o(e)),t.then(e=>d(e)),()=>{e=!1}},[p,o,d,x]),(0,a.jsxs)(a.Fragment,{children:[(0,a.jsx)(h.oU,{}),"Default"==t&&(0,a.jsx)(no,{}),(0,a.jsx)(h.$D,{}),!i&&(0,a.jsx)(h.Fp,{}),(0,a.jsx)(h.Rh,{}),"Default"!=t&&(0,a.jsx)(eJ,{ZarrDS:S}),r&&(0,a.jsx)(h.OS,{data:r}),Object.keys(n).length>=1&&(0,a.jsx)(U,{})]})}},7181:()=>{}},e=>{e.O(0,[956,693,197,669,813,444,755,858,56,667,800,645,812,959,152,195,499,100,970,984,65,340,437,769,98,53,225,358],()=>e(e.s=1536)),_N_E=e.O()}]);