(self.webpackChunk_N_E=self.webpackChunk_N_E||[]).push([[974],{1931:(e,n,t)=>{"use strict";t.d(n,{default:()=>ek});var r=t(6496),i=t(2331),a=t(3278),o=t(1718),l=t(4364);let s=" // by Jeran Poehls\r\n\r\nout vec3 vOrigin;\r\nout vec3 vDirection;\r\nout vec3 aPosition;\r\n\r\nout vec2 Vuv;\r\n\r\nvoid main() {\r\n    vec4 worldPos = modelViewMatrix * vec4( position, 1.0 );\r\n    \r\n    aPosition = position; //Pass out position for sphere frag\r\n    vOrigin = vec3( inverse( modelMatrix ) * vec4( cameraPosition, 1.0 ) ).xyz;\r\n    vDirection = position - vOrigin;\r\n    Vuv = uv;\r\n    gl_Position = projectionMatrix * worldPos;\r\n}",u="uniform sampler2D cmap;\r\nuniform float cOffset;\r\nuniform float cScale;\r\n\r\nvarying float vStrength;\r\n\r\nout vec4 Color;\r\n\r\n\r\nvoid main() {\r\n    float strength = vStrength;\r\n\r\n    strength *= cScale;\r\n    strength = min(strength+cOffset,0.996);\r\n\r\n    vec3 sampColor = texture(cmap, vec2(strength, 0.5)).rgb;\r\n\r\n    Color = vec4(sampColor, 1.0);\r\n    \r\n}";var c=t(9691),d=t(4078),f=t(4728);let m=e=>{let{volTexture:n}=e,{shape:t,colormap:a,flipY:o,textureArrayDepths:u}=(0,c.on)((0,d.k)(e=>({shape:e.shape,colormap:e.colormap,flipY:e.flipY,textureArrayDepths:e.textureArrayDepths}))),{valueRange:m,xRange:p,yRange:x,zRange:v,quality:h,useOrtho:S,animProg:g,cScale:y,cOffset:z,useFragOpt:w,transparency:b,nanTransparency:I,nanColor:_,vTransferRange:C,vTransferScale:D}=(0,c.Ws)((0,d.k)(e=>({valueRange:e.valueRange,xRange:e.xRange,yRange:e.yRange,zRange:e.zRange,quality:e.quality,useOrtho:e.useOrtho,animProg:e.animProg,cScale:e.cScale,cOffset:e.cOffset,useFragOpt:e.useFragOpt,transparency:e.transparency,nanTransparency:e.nanTransparency,nanColor:e.nanColor,vTransferRange:e.vTransferRange,vTransferScale:e.vTransferScale}))),P=(0,l.useRef)(null),M=t.y/t.x,k=(0,l.useMemo)(()=>new i.BKk({glslVersion:i.Wdf,uniforms:{modelViewMatrixInverse:{value:new i.kn4},map:{value:n},textureDepths:{value:new i.Pq0(u[2],u[1],u[0])},cmap:{value:a},cOffset:{value:z},cScale:{value:y},threshold:{value:new i.I9Y(m[0],m[1])},scale:{value:t},flatBounds:{value:new i.IUQ(-p[1],-p[0],v[0],v[1])},vertBounds:{value:new i.I9Y(x[0]*M,x[1]*M)},steps:{value:h},animateProg:{value:g},transparency:{value:b},opacityMag:{value:D},useClipScale:{value:C},nanAlpha:{value:1-I},nanColor:{value:new i.Q1f(_)}},vertexShader:S?" // by Jeran Poehls\r\n\r\nout vec3 vOrigin;\r\nout vec3 vDirection;\r\n\r\nuniform mat4 modelViewMatrixInverse;\r\n\r\nvoid main() {\r\n  // For orthographic: origin is on the box surface\r\n  vOrigin = position;\r\n\r\n  // Camera direction in object space (parallel for all fragments)\r\n  vec4 viewDir = modelViewMatrixInverse * vec4(0.0, 0.0, -1.0, 0.0);\r\n  vDirection = normalize(viewDir.xyz);\r\n\r\n  gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);\r\n}":s,fragmentShader:w?"// This is an optimized version of the original Volumetric shader\r\n\r\nprecision highp float;\r\nprecision highp sampler3D;\r\n\r\nin vec3 vOrigin;\r\nin vec3 vDirection;\r\n\r\nout vec4 color;\r\n\r\nuniform sampler3D map;\r\nuniform sampler2D cmap;\r\n\r\nuniform float cOffset;\r\nuniform float cScale;\r\nuniform vec3 scale;\r\nuniform vec2 threshold;\r\nuniform float steps;\r\nuniform vec4 flatBounds;\r\nuniform vec2 vertBounds;\r\nuniform float animateProg;\r\nuniform float transparency;\r\nuniform float nanAlpha;\r\nuniform vec3 nanColor;\r\n\r\nvec2 hitBox(vec3 orig, vec3 dir) {\r\n    vec3 box_min = vec3(-(scale * 0.5));\r\n    vec3 box_max = vec3(scale * 0.5);\r\n    vec3 inv_dir = 1.0 / dir;\r\n    vec3 tmin_tmp = (box_min - orig) * inv_dir;\r\n    vec3 tmax_tmp = (box_max - orig) * inv_dir;\r\n    vec3 tmin = min(tmin_tmp, tmax_tmp);\r\n    vec3 tmax = max(tmin_tmp, tmax_tmp);\r\n    float t0 = max(tmin.x, max(tmin.y, tmin.z));\r\n    float t1 = min(tmax.x, min(tmax.y, tmax.z));\r\n    return vec2(t0, t1);\r\n}\r\n\r\nfloat sample1( vec3 p ) {\r\n    return texture( map, p ).r;\r\n}\r\n\r\n#define epsilon 0.0001\r\n\r\nvoid main() {\r\n    vec3 rayDir = normalize(vDirection);\r\n    vec2 bounds = hitBox(vOrigin, rayDir);\r\n\r\n    if (bounds.x > bounds.y) discard;\r\n\r\n    bounds.x = max(bounds.x, 0.0);\r\n\r\n    vec3 p = vOrigin + bounds.x * rayDir;\r\n    vec3 inc = 1.0 / abs(rayDir);\r\n\r\n    //Step Sizes\r\n    float fineDelta = min(inc.x, min(inc.y, inc.z)) / steps;\r\n\r\n    float coarseDelta = min(inc.x, min(inc.y, inc.z))/50.;\r\n\r\n    float delta = fineDelta;\r\n\r\n    vec4 accumColor = vec4(0.0);\r\n    float alphaAcc = 0.0;\r\n\r\n    float t = bounds.x;\r\n    int countdown = 0;\r\n    bool useCoarseStep = false;\r\n\r\n    while (t < bounds.y) {\r\n        vec3 p = vOrigin + rayDir * t;\r\n        \r\n        // --- Boundary checks ---\r\n        if (p.x < flatBounds.x || p.x > flatBounds.y ||\r\n            p.z < flatBounds.z || p.z > flatBounds.w ||\r\n            p.y < vertBounds.x || p.y > vertBounds.y) {\r\n\r\n            t += useCoarseStep ? coarseDelta : fineDelta;\r\n            continue;\r\n        }\r\n\r\n        vec3 texCoord = p / scale + 0.5;\r\n        texCoord.z = mod(texCoord.z + animateProg, 1.0001);\r\n        float d = sample1(texCoord);\r\n\r\n        bool cond = nanAlpha == 0. ? (d > threshold.x) && (d < threshold.y) : (d > threshold.x) && (d < threshold.y+.01); //We skip over nans if the transparency is enabled\r\n        \r\n        if (cond) {\r\n            // Hit something interesting - switch to fine stepping\r\n            if (useCoarseStep) {\r\n                useCoarseStep = false;\r\n                countdown = 40;\r\n                // Step back to ensure we don't miss the boundary\r\n                t -= coarseDelta;\r\n                continue;\r\n            }\r\n            if (d == 1.){\r\n                accumColor.rgb += (1.0 - alphaAcc) * pow(nanAlpha, 5.) * nanColor.rgb;\r\n                alphaAcc += pow(nanAlpha, 5.);\r\n            }\r\n            else{\r\n                float sampLoc = (d - 0.5)*cScale + 0.5;\r\n                sampLoc = min(sampLoc+cOffset,0.99);\r\n                vec4 col = texture(cmap, vec2(sampLoc, 0.5));\r\n                float alpha = pow(max(sampLoc, 0.001), transparency);\r\n                accumColor.rgb += (1.0 - alphaAcc) * alpha * col.rgb;\r\n                alphaAcc += alpha * (1.0 - alphaAcc);\r\n            }      \r\n\r\n            if (alphaAcc >= 1.0) break;\r\n            \r\n            t += fineDelta;\r\n        }\r\n        else {\r\n            // Nothing interesting here\r\n            if (countdown > 0) {\r\n                countdown--;\r\n                t += fineDelta; // Continue with fine steps while countdown > 0\r\n            } else {\r\n                useCoarseStep = true;\r\n                t += coarseDelta; // Switch to coarse steps\r\n            }\r\n        }\r\n    }\r\n    accumColor.a = alphaAcc; // Set the final accumulated alpha\r\n    color = accumColor;\r\n    if (color.a == 0.0) discard;\r\n}\r\n":"// by Jeran Poehls\r\nprecision highp float;\r\nprecision highp sampler3D;\r\n\r\nin vec3 vOrigin;\r\nin vec3 vDirection;\r\n\r\nout vec4 color;\r\n\r\nuniform sampler3D map[14]; // We are limited to 16 textures. Cmap counts as one. 15 is weird so we use 14. \r\nuniform sampler2D cmap;\r\nuniform vec3 textureDepths;\r\n\r\nuniform float cOffset;\r\nuniform float cScale;\r\nuniform vec3 scale;\r\nuniform vec2 threshold;\r\nuniform float steps;\r\nuniform vec4 flatBounds;\r\nuniform vec2 vertBounds;\r\nuniform float animateProg;\r\nuniform float transparency;\r\nuniform float nanAlpha;\r\nuniform vec3 nanColor;\r\nuniform float opacityMag;\r\nuniform bool useClipScale;\r\n\r\n\r\nvec2 hitBox(vec3 orig, vec3 dir) {\r\n    vec3 box_min = vec3(-(scale * 0.5));\r\n    vec3 box_max = vec3(scale * 0.5);\r\n    vec3 inv_dir = 1.0 / dir;\r\n    vec3 tmin_tmp = (box_min - orig) * inv_dir;\r\n    vec3 tmax_tmp = (box_max - orig) * inv_dir;\r\n    vec3 tmin = min(tmin_tmp, tmax_tmp);\r\n    vec3 tmax = max(tmin_tmp, tmax_tmp);\r\n    float t0 = max(tmin.x, max(tmin.y, tmin.z));\r\n    float t1 = min(tmax.x, min(tmax.y, tmax.z));\r\n    return vec2(t0, t1);\r\n}\r\n\r\nfloat sample1(vec3 p, int index) { // Shader doesn't support dynamic indexing so we gotta use switching\r\n    if (index == 0) return texture(map[0], p).r;\r\n    else if (index == 1) return texture(map[1], p).r;\r\n    else if (index == 2) return texture(map[2], p).r;\r\n    else if (index == 3) return texture(map[3], p).r;\r\n    else if (index == 4) return texture(map[4], p).r;\r\n    else if (index == 5) return texture(map[5], p).r;\r\n    else if (index == 6) return texture(map[6], p).r;\r\n    else if (index == 7) return texture(map[7], p).r;\r\n    else if (index == 8) return texture(map[8], p).r;\r\n    else if (index == 9) return texture(map[9], p).r;\r\n    else if (index == 10) return texture(map[10], p).r;\r\n    else if (index == 11) return texture(map[11], p).r;\r\n    else if (index == 12) return texture(map[12], p).r;\r\n    else if (index == 13) return texture(map[13], p).r;\r\n    else return 0.0;\r\n}\r\n\r\n\r\n\r\n#define epsilon 0.000001\r\n\r\nvoid main() {\r\n    vec3 rayDir = normalize(vDirection);\r\n    vec2 bounds = hitBox(vOrigin, rayDir);\r\n\r\n    if (bounds.x > bounds.y) discard;\r\n\r\n    bounds.x = max(bounds.x, 0.0);\r\n\r\n    vec3 p = vOrigin + bounds.x * rayDir;\r\n    vec3 inc = 1.0 / abs(rayDir);\r\n    float delta = min(inc.x, min(inc.y, inc.z));\r\n    delta /= steps;\r\n    vec4 accumColor = vec4(0.0);\r\n    float alphaAcc = 0.0;\r\n\r\n    int zStepSize = int(textureDepths.y) * int(textureDepths.x); \r\n    int yStepSize = int(textureDepths.x); \r\n\r\n    for (float t = bounds.x; t < bounds.y; t += delta) {\r\n        p = vOrigin + rayDir * t;\r\n        if (p.x > -flatBounds.x || p.x < -flatBounds.y) { \r\n            continue;\r\n        }\r\n        if (-p.z > -flatBounds.z || -p.z < -flatBounds.w) {\r\n            continue;\r\n        }\r\n        if (p.y < vertBounds.x || p.y > vertBounds.y) {\r\n            continue;\r\n        }\r\n\r\n        vec3 texCoord = p / scale + 0.5;\r\n        texCoord.z = mod(texCoord.z + animateProg, 1.0001);\r\n        texCoord = clamp(texCoord, vec3(0.0), 1. - vec3(epsilon)); // This prevents the the very end of the dimensions having floating point errors\r\n\r\n        ivec3 idx = clamp(ivec3(texCoord * textureDepths), ivec3(0), ivec3(textureDepths) - 1);\r\n        int textureIdx = idx.z * zStepSize + idx.y * yStepSize + idx.x;\r\n        vec3 localCoord = texCoord * (textureDepths);  \r\n        localCoord = fract(localCoord);\r\n        float d = sample1(localCoord, textureIdx);\r\n\r\n        bool cond = nanAlpha == 0. ? (d >= threshold.x) && (d <= threshold.y) : (d >= threshold.x) && (d <= threshold.y); //We skip over nans if the transparency is enabled\r\n        \r\n        if (cond) {\r\n            if (d == 1.){\r\n                accumColor.rgb += (1.0 - alphaAcc) * pow(nanAlpha, 5.) * nanColor.rgb;\r\n                alphaAcc += pow(nanAlpha, 5.);\r\n            }\r\n            else{\r\n                float sampLoc = d*cScale;\r\n                sampLoc = min(sampLoc+cOffset,0.99);\r\n                vec4 col = texture(cmap, vec2(sampLoc, 0.5));\r\n                float alpha;\r\n                if (useClipScale){\r\n                    float normalizedOpacity = clamp((sampLoc - threshold.x) / (threshold.y - threshold.x), 0.0, 1.0);\r\n                    alpha = pow(max(normalizedOpacity, 0.001), transparency*opacityMag);\r\n                } else {\r\n                    alpha = pow(max(sampLoc, 0.001), transparency*opacityMag);\r\n                }\r\n                accumColor.rgb += (1.0 - alphaAcc) * alpha * col.rgb;\r\n                alphaAcc += alpha * (1.0 - alphaAcc);\r\n            }      \r\n\r\n            if (alphaAcc >= 1.0) break;\r\n        }\r\n    }\r\n\r\n    accumColor.a = alphaAcc; // Set the final accumulated alpha\r\n    color = accumColor;\r\n    if (color.a == 0.0) discard;\r\n}\r\n",transparent:!0,blending:i.NTi,depthWrite:!1,side:S?i.hB5:i.hsX}),[w,S]),T=(0,l.useMemo)(()=>new i.iNn(t.x,t.y,t.z),[t]);return(0,l.useEffect)(()=>{if(k){let e=k.uniforms;e.map.value=n,e.cmap.value=a,e.cOffset.value=z,e.cScale.value=y,e.threshold.value.set(m[0],m[1]),e.scale.value=t,e.flatBounds.value.set(-p[1],-p[0],v[0],v[1]),e.vertBounds.value.set(x[0]*M,x[1]*M),e.steps.value=h,e.animateProg.value=g,e.transparency.value=b,e.nanAlpha.value=1-I,e.nanColor.value.set(_),e.opacityMag.value=D,e.useClipScale.value=C,(0,f.m)()}},[n,t,a,z,y,m,p,x,v,M,h,g,b,I,_,D,C]),(0,f.D)(e=>{let{camera:n}=e;S&&P.current&&k&&(P.current.modelViewMatrix.multiplyMatrices(n.matrixWorldInverse,P.current.matrixWorld),k.uniforms.modelViewMatrixInverse.value.copy(P.current.modelViewMatrix).invert())}),(0,r.jsx)(r.Fragment,{children:(0,r.jsx)("mesh",{ref:P,geometry:T,scale:[1,o?-1:1,1],children:(0,r.jsx)("primitive",{attach:"material",object:k})})})};var p=t(4759),x=t(2801);let v=e=>{let{ZarrDS:n}=e,{setTimeSeries:t,setPlotDim:a,setDimCoords:o,updateTimeSeries:s,updateDimCoords:u}=(0,c.on)((0,d.k)(e=>({setTimeSeries:e.setTimeSeries,setPlotDim:e.setPlotDim,setDimCoords:e.setDimCoords,updateTimeSeries:e.updateTimeSeries,updateDimCoords:e.updateDimCoords}))),{analysisMode:f,analysisArray:m}=(0,c.r2)((0,d.k)(e=>({analysisMode:e.analysisMode,analysisArray:e.analysisArray}))),{shape:v,dataShape:h,strides:S,dimArrays:g,dimNames:y,dimUnits:z}=(0,c.on)((0,d.k)(e=>({shape:e.shape,dataShape:e.dataShape,strides:e.strides,dimArrays:e.dimArrays,dimNames:e.dimNames,dimUnits:e.dimUnits}))),{selectTS:w,getColorIdx:b,incrementColorIdx:I}=(0,c.Ws)((0,d.k)(e=>({selectTS:e.selectTS,getColorIdx:e.getColorIdx,incrementColorIdx:e.incrementColorIdx}))),_=(0,l.useRef)(0),C=(0,l.useMemo)(()=>new i.iNn(1,1,1),[]);return(0,l.useEffect)(()=>()=>{C.dispose()},[]),(0,r.jsx)(r.Fragment,{children:(0,r.jsx)("mesh",{geometry:C,scale:v,onClick:e=>{e.stopPropagation(),e.intersections.length>0&&w&&function(e){e.point;let r=e.uv,i=e.normal,l=(0,p._8)(i);if(l!=_.current&&(t({}),o({})),_.current=l,n){var c,d;let e=(0,p.PE)({data:f?m:(0,p.Td)(),shape:h,stride:S},{uv:r,normal:i}),n=i.toArray().map((e,n)=>Math.abs(e)>0?n:null).filter(e=>null!==e);a(2-n[0]);let t=(0,p.jT)({normal:i,uv:r}).map((e,n)=>e?g[n][Math.round(e*g[n].length)]:null),o=y.filter((e,n)=>null!==t[n]),l=z.filter((e,n)=>null!==t[n]);t=t.filter(e=>null!==e);let v="".concat(t[0],"_").concat(t[1]);s({[v]:{color:(0,x.md)(b()/10,"Paired"),data:e}}),I(),u({[v]:{first:{name:o[0],loc:null!=(c=t[0])?c:0,units:l[0]},second:{name:o[1],loc:null!=(d=t[1])?d:0,units:l[1]},plot:{units:z[2-n[0]]}}})}}(e.intersections[0])},children:(0,r.jsx)("meshBasicMaterial",{transparent:!0,opacity:0})})})},h=e=>{let{dimensions:n,ZarrDS:t,setters:i}=e,{width:a,height:o,depth:s}=n,{setPoints:u,setStride:f,setDimWidth:m}=i,v=(0,c.Ws)(e=>e.selectTS),{dimArrays:h,dimUnits:S,dimNames:g,strides:y,dataShape:z,setPlotDim:w,setTimeSeries:b,updateTimeSeries:I,setDimCoords:_,updateDimCoords:C}=(0,c.on)((0,d.k)(e=>({dimArrays:e.dimArrays,dimUnits:e.dimUnits,dimNames:e.dimNames,strides:e.strides,dataShape:e.dataShape,setPlotDim:e.setPlotDim,setTimeSeries:e.setTimeSeries,updateTimeSeries:e.updateTimeSeries,setDimCoords:e.setDimCoords,updateDimCoords:e.updateDimCoords}))),{analysisMode:D,analysisArray:P}=(0,c.r2)((0,d.k)(e=>({analysisMode:e.analysisMode,analysisArray:e.analysisArray}))),{timeScale:M,zSlice:k,ySlice:T,xSlice:O,getColorIdx:B,incrementColorIdx:A}=(0,c.Ws)((0,d.k)(e=>({timeScale:e.timeScale,zSlice:e.zSlice,ySlice:e.ySlice,xSlice:e.xSlice,getColorIdx:e.getColorIdx,incrementColorIdx:e.incrementColorIdx}))),j=[h[0].slice(k[0],k[1]?k[1]:void 0),h[1].slice(T[0],T[1]?T[1]:void 0),h.length>2?h[2].slice(O[0],O[1]?O[1]:void 0):[]],U=(0,l.useRef)(null),N=z[2]/500,E=(0,l.useMemo)(()=>z[0]/z[2]*M,[z,M]),V=(0,l.useMemo)(()=>z[1]/z[2],[z]);return(0,r.jsxs)("mesh",{scale:[2*N,2*V*N,2*E*N],position:[-.002,-.002,.002],onClick:function(e){if(!v)return;let n=e.uv,r=e.normal,i=(0,p._8)(r);if(i!=U.current&&(b({}),_({}),u({})),U.current=i,t){var l,c;let e=(0,p.PE)({data:D?P:(0,p.Td)(),shape:z,stride:y},{uv:n,normal:r}),t=r.toArray().map((e,n)=>Math.abs(e)>0?n:null).filter(e=>null!==e);w(2-t[0]);let i=(0,p.jT)({normal:r,uv:n}),d=i.map((e,n)=>e?j[n][Math.round(e*j[n].length-.5)]:null),v=g.filter((e,n)=>null!==d[n]),h=S.filter((e,n)=>null!==d[n]);d=d.filter(e=>null!==e);let b="".concat(d[0],"_").concat(d[1]),_={color:(0,x.md)(B()/10,"Paired"),data:e};A(),I({[b]:_}),C({[b]:{first:{name:v[0],loc:null!=(l=d[0])?l:0,units:h[0]},second:{name:v[1],loc:null!=(c=d[1])?c:0,units:h[1]},plot:{units:S[2-t[0]]}}});let M=[s,o,a].filter((e,n)=>null!=i[n]),k=[s,o,a].filter((e,n)=>null==i[n]),T=i.filter(e=>null!=e),O=y.filter((e,n)=>null!=i[n]),U=Math.round(T[0]*M[0]-.5),N=Math.round(T[1]*M[1]-.5),E=U*O[0]+N*O[1],V=y.filter((e,n)=>null==i[n]);m(k[0]),u(e=>({...{[b]:E},...e})),f(V[0])}},children:[(0,r.jsx)("boxGeometry",{}),(0,r.jsx)("meshBasicMaterial",{transparent:!0,opacity:0})]})},S=e=>{let{textures:n,ZarrDS:t}=e,{colormap:a}=n,{timeSeries:o,flipY:s,dataShape:u,textureData:f}=(0,c.on)((0,d.k)(e=>({timeSeries:e.timeSeries,flipY:e.flipY,dataShape:e.dataShape,textureData:e.textureData}))),{scalePoints:m,scaleIntensity:p,pointSize:x,cScale:v,cOffset:S,valueRange:g,animProg:y,selectTS:z,timeScale:w,xRange:b,yRange:I,zRange:_}=(0,c.Ws)((0,d.k)(e=>({scalePoints:e.scalePoints,scaleIntensity:e.scaleIntensity,pointSize:e.pointSize,cScale:e.cScale,cOffset:e.cOffset,valueRange:e.valueRange,animProg:e.animProg,selectTS:e.selectTS,timeScale:e.timeScale,xRange:e.xRange,yRange:e.yRange,zRange:e.zRange}))),[C,D]=(0,l.useState)({}),[P,M]=(0,l.useState)(Array(10).fill(-1)),[k,T]=(0,l.useState)(1),[O,B]=(0,l.useState)(0);(0,l.useEffect)(()=>{let e=Object.keys(C),n=Object.keys(o),t=(e=e.filter(e=>n.includes(e))).map(e=>C[e]);M([...t,...Array(Math.max(0,10-t.length)).fill(-1)])},[o,C]);let{data:A,width:j,height:U,depth:N}=(0,l.useMemo)(()=>{let[e,n,t]=u;return{data:f,width:t,height:n,depth:e}},[f,u]),E=(0,l.useMemo)(()=>{let e=new i.LoY;e.setAttribute("value",new i.baL(A,1));let n=N*U*j;return e.setDrawRange(0,n),e},[A]),V=(0,l.useMemo)(()=>new i.BKk({glslVersion:i.Wdf,uniforms:{pointSize:{value:x},cmap:{value:a},cOffset:{value:S},cScale:{value:v},valueRange:{value:new i.I9Y(g[0],g[1])},scalePoints:{value:m},scaleIntensity:{value:p},startIDs:{value:P},stride:{value:k},showTransect:{value:z},dimWidth:{value:O},timeScale:{value:w},animateProg:{value:y},shape:{value:new i.Pq0(N,U,j)},flatBounds:{value:new i.IUQ(b[0],b[1],_[0],_[1])},vertBounds:{value:new i.I9Y(I[0],I[1])}},vertexShader:"attribute float value;\r\n\r\nout float vValue;\r\n\r\nflat out int highlight;\r\n\r\nuniform float pointSize;\r\nuniform bool scalePoints;\r\nuniform float scaleIntensity;\r\nuniform vec2 valueRange;\r\nuniform int[10] startIDs;\r\nuniform int stride;\r\nuniform int dimWidth;\r\nuniform bool showTransect;\r\nuniform float timeScale;\r\nuniform float animateProg;\r\nuniform vec4 flatBounds;\r\nuniform vec2 vertBounds;\r\nuniform vec3 shape;\r\n\r\nbool isValidPoint(){\r\n    for (int i = 0; i < 10; i++){\r\n        if (startIDs[i] == -1){\r\n            return false;\r\n        }\r\n        int rePos = gl_VertexID - startIDs[i];\r\n        bool isValid = rePos % stride == 0;\r\n        bool secondary = gl_VertexID < (startIDs[i] + dimWidth*stride) && gl_VertexID > startIDs[i];\r\n        isValid = isValid && secondary;\r\n        if (isValid){\r\n            return true;\r\n        }\r\n    }\r\n    return false;\r\n}\r\n\r\nvec3 computePosition(int vertexID) {\r\n    int depth = int(shape.x);\r\n    int height = int(shape.y);\r\n    int width = int(shape.z);\r\n\r\n    int sliceSize = width * height;\r\n\r\n    int z = vertexID / sliceSize;\r\n    int y = (vertexID % sliceSize) / width;\r\n    int x = vertexID % width;\r\n\r\n    float px = (float(x) - (float(width)/2.)) / 500.;\r\n    float py = (float(y) - (float(height)/2.)) / 500.;\r\n    float pz = (float(z) - (float(depth )/2.)) /500.;\r\n\r\n    return vec3(px * 2.0, py * 2.0, pz * 2.0);\r\n}\r\n\r\nvoid main() {\r\n    vValue = float(value)/255.;\r\n    vec3 scaledPos = computePosition(gl_VertexID);\r\n    float depthSize = float(shape.x)/500.;\r\n    float globalScale = float(shape.z)/600.;\r\n\r\n    scaledPos.z += depthSize;\r\n    scaledPos.z = mod(scaledPos.z + animateProg*depthSize*2., depthSize*2.);\r\n    scaledPos.z -= depthSize;\r\n\r\n    scaledPos.z *= timeScale;\r\n    gl_Position = projectionMatrix * modelViewMatrix * vec4(scaledPos, 1.0);\r\n\r\n    float pointScale = pointSize/gl_Position.w;\r\n    pointScale = scalePoints ? pointScale*pow(vValue,scaleIntensity) : pointScale;\r\n\r\n    bool isValid = isValidPoint();\r\n    highlight = isValid ? 1 : 0;\r\n    \r\n    if (value == 255. || (pointScale*gl_Position.w < 0.75 && scalePoints)){ //Hide points that are invisible or get too small when scalled\r\n        gl_Position = vec4(2.0, 2.0, 2.0, 1.0);\r\n    }\r\n\r\n    if (vValue < valueRange.x || vValue > valueRange.y){ //Hide points that are outside of value range\r\n        gl_Position = vec4(2.0, 2.0, 2.0, 1.0);\r\n    }\r\n\r\n    float scaleX = float(shape.z) / 500.0; //width scaling\r\n    float scaleY = float(shape.y) / 500.0; //height scaling\r\n    float scaleZ = float(shape.x) / 500.0; //depth scaling\r\n    \r\n    vec2 scaledXBounds = vec2(flatBounds.x, flatBounds.y) * scaleX;\r\n    vec2 scaledZBounds = vec2(flatBounds.z, flatBounds.w) * scaleZ * timeScale;\r\n    vec2 scaledYBounds = vec2(vertBounds.x, vertBounds.y) * scaleY;\r\n    \r\n    bool xCheck = scaledPos.x < scaledXBounds.x || scaledPos.x > scaledXBounds.y;\r\n    bool zCheck = scaledPos.z < scaledZBounds.x || scaledPos.z > scaledZBounds.y;\r\n    bool yCheck = scaledPos.y < scaledYBounds.x || scaledPos.y > scaledYBounds.y;\r\n\r\n    if (xCheck || zCheck || yCheck){ //Hide points that are clipped\r\n        gl_Position = vec4(2.0, 2.0, 2.0, 1.0);\r\n    }\r\n    \r\n    if (showTransect){\r\n        gl_PointSize = isValid ? pointScale*5.*globalScale : pointScale;\r\n    }\r\n    else{\r\n        gl_PointSize =  pointScale;\r\n    }\r\n\r\n}\r\n",fragmentShader:"out vec4 Color;\r\n\r\nin float vValue;\r\nflat in int highlight;\r\n\r\n\r\nuniform sampler2D cmap;\r\nuniform float cScale;\r\nuniform float cOffset;\r\nuniform bool showTransect;\r\n\r\nvoid main() {\r\n    float sampLoc = vValue == 1. ? vValue : (vValue - 0.5)*cScale + 0.5;\r\n    sampLoc = vValue == 1. ? vValue : min(sampLoc+cOffset,0.99);\r\n    vec4 color = texture(cmap, vec2(sampLoc, 0.5));\r\n    color.a = 1.;\r\n    Color = color;\r\n    if (showTransect){\r\n        Color = highlight == 1 ? color : color * vec4(vec3(0.4),1.);\r\n    }\r\n    else{\r\n        Color = color;\r\n    }\r\n}\r\n",depthWrite:!0,depthTest:!0,transparent:!1,blending:i.NTi,side:i.$EB}),[]);return(0,l.useEffect)(()=>{if(V){let e=V.uniforms;e.pointSize.value=x,e.cmap.value=a,e.cOffset.value=S,e.cScale.value=v,e.valueRange.value.set(g[0],g[1]),e.scalePoints.value=m,e.scaleIntensity.value=p,e.startIDs.value=P,e.stride.value=k,e.showTransect.value=z,e.dimWidth.value=O,e.timeScale.value=w,e.animateProg.value=y,e.flatBounds.value.set(b[0],b[1],_[0],_[1]),e.vertBounds.value.set(I[0],I[1])}},[x,a,S,v,g,m,p,P,k,z,y,w,b,I,_]),(0,r.jsxs)(r.Fragment,{children:[(0,r.jsx)("mesh",{scale:[1,s?-1:1,1],children:(0,r.jsx)("points",{geometry:E,material:V,frustumCulled:!1})}),(0,r.jsx)(h,{dimensions:{width:j,height:U,depth:N},ZarrDS:t,setters:{setPoints:D,setStride:T,setDimWidth:B}})]})};var g=t(2908),y=t(9212);t(8365);var z=t(3432);t(4634);var w=t(5196),b=t(8279);function I(e){let{...n}=e;return(0,r.jsx)(w.bL,{"data-slot":"dropdown-menu",...n})}function _(e){let{...n}=e;return(0,r.jsx)(w.l9,{"data-slot":"dropdown-menu-trigger",...n})}function C(e){let{className:n,sideOffset:t=4,...i}=e;return(0,r.jsx)(w.ZL,{children:(0,r.jsx)(w.UC,{"data-slot":"dropdown-menu-content",sideOffset:t,className:(0,b.cn)("bg-popover text-popover-foreground data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0 data-[state=closed]:zoom-out-95 data-[state=open]:zoom-in-95 data-[side=bottom]:slide-in-from-top-2 data-[side=left]:slide-in-from-right-2 data-[side=right]:slide-in-from-left-2 data-[side=top]:slide-in-from-bottom-2 z-50 max-h-(--radix-dropdown-menu-content-available-height) min-w-[8rem] origin-(--radix-dropdown-menu-content-transform-origin) overflow-x-hidden overflow-y-auto rounded-md border p-1 shadow-md",n),...i})})}function D(e){let{...n}=e;return(0,r.jsx)(w.YJ,{"data-slot":"dropdown-menu-group",...n})}function P(e){let{className:n,inset:t,variant:i="default",...a}=e;return(0,r.jsx)(w.q7,{"data-slot":"dropdown-menu-item","data-inset":t,"data-variant":i,className:(0,b.cn)("focus:bg-accent focus:text-accent-foreground data-[variant=destructive]:text-destructive data-[variant=destructive]:focus:bg-destructive/10 dark:data-[variant=destructive]:focus:bg-destructive/20 data-[variant=destructive]:focus:text-destructive data-[variant=destructive]:*:[svg]:!text-destructive [&_svg:not([class*='text-'])]:text-muted-foreground relative flex cursor-default items-center gap-2 rounded-sm px-2 py-1.5 text-sm outline-hidden select-none data-[disabled]:pointer-events-none data-[disabled]:opacity-50 data-[inset]:pl-8 [&_svg]:pointer-events-none [&_svg]:shrink-0 [&_svg:not([class*='size-'])]:size-4",n),...a})}function M(e){let{className:n,...t}=e;return(0,r.jsx)(w.wv,{"data-slot":"dropdown-menu-separator",className:(0,b.cn)("bg-border -mx-1 my-1 h-px",n),...t})}var k=t(6883);let T=l.memo(function(){let{showPoints:e,linePointSize:n,pointColor:t,useCustomPointColor:i,setLinePointSize:a,setPointColor:o,setUseCustomPointColor:l}=(0,c.Ws)((0,d.k)(e=>({showPoints:e.showPoints,linePointSize:e.linePointSize,pointColor:e.pointColor,useCustomPointColor:e.useCustomPointColor,setLinePointSize:e.setLinePointSize,setPointColor:e.setPointColor,setUseCustomPointColor:e.setUseCustomPointColor})));return e?(0,r.jsxs)(r.Fragment,{children:[(0,r.jsxs)("div",{className:"w-full flex items-center mb-2",children:[(0,r.jsx)("div",{className:"w-[40%]",children:(0,r.jsx)("b",{children:"Point Size"})}),(0,r.jsx)(k.A,{min:1,max:10,step:.1,value:[n],className:"flex-1 my-2",onValueChange:e=>a(e[0])})]}),(0,r.jsxs)("div",{className:"w-full flex items-center mb-2",children:[(0,r.jsx)("div",{className:"w-[40%]",children:(0,r.jsx)("b",{children:"Point Color"})}),i&&(0,r.jsx)("input",{type:"color",title:"Point Color",value:t,onChange:e=>o(e.target.value)}),(0,r.jsxs)(z.$,{className:"h-8 px-2 py-1",variant:"outline",onClick:()=>l(!i),children:["Use",i?" Browzarr Color":" Custom Color"]})]})]}):null}),O=l.memo(function(){let{lineWidth:e,lineColor:n,useLineColor:t,lineResolution:i,useCustomColor:a,setLineWidth:o,setLineColor:l,setUseLineColor:s,setLineResolution:u,setUseCustomColor:f}=(0,c.Ws)((0,d.k)(e=>({lineWidth:e.lineWidth,lineColor:e.lineColor,useLineColor:e.useLineColor,lineResolution:e.lineResolution,useCustomColor:e.useCustomColor,setLineWidth:e.setLineWidth,setLineColor:e.setLineColor,setUseLineColor:e.setUseLineColor,setLineResolution:e.setLineResolution,setUseCustomColor:e.setUseCustomColor})));return(0,r.jsxs)(r.Fragment,{children:[(0,r.jsxs)("div",{className:"w-full flex items-center mb-2",children:[(0,r.jsx)("div",{className:"w-[40%]",children:(0,r.jsx)("b",{children:"Line Width"})}),(0,r.jsx)(k.A,{min:1,max:10,step:.2,value:[e],className:"flex-1 my-2",onValueChange:e=>o(e[0])})]}),(0,r.jsxs)("div",{className:"w-full flex items-center mb-2",children:[(0,r.jsx)("div",{className:"w-[40%]",children:(0,r.jsx)("b",{children:"Line Resolution"})}),(0,r.jsx)(k.A,{min:1,max:10,step:1,value:[i],className:"flex-1 my-2",onValueChange:e=>u(e[0])})]}),(0,r.jsxs)("div",{className:"w-full flex items-center",children:[(0,r.jsx)("div",{className:"w-[40%]",children:(0,r.jsx)("b",{children:"Line Color"})}),a&&(0,r.jsx)("input",{type:"color",title:"Line Color",value:n,onChange:e=>l(e.target.value)}),!a&&(0,r.jsxs)(z.$,{className:"h-8 px-2 py-5",variant:"outline",onClick:()=>s(!t),children:["Use ",(0,r.jsx)("br",{}),t?"Individual Color":"Plot Color"]}),(0,r.jsxs)(z.$,{className:"h-8 px-2 py-5",variant:"outline",onClick:()=>f(!a),children:["Use ",(0,r.jsx)("br",{}),a?"Browzarr Color":"Custom Color"]})]})]})}),B=l.memo(function(e){let{menuRef:n}=e,{showPoints:t,setShowPoints:i}=(0,c.Ws)((0,d.k)(e=>({showPoints:e.showPoints,setShowPoints:e.setShowPoints})));return(0,r.jsx)("div",{className:"plotline-options",children:(0,r.jsxs)(I,{onOpenChange:e=>n.current=e,children:[(0,r.jsx)(_,{asChild:!0,children:(0,r.jsx)(z.$,{className:"cursor-pointer",variant:"outline",children:"Line Options"})}),(0,r.jsxs)(C,{className:"w-80 items-center",align:"center",children:[(0,r.jsx)(D,{onClick:e=>e.preventDefault(),children:(0,r.jsx)(P,{children:(0,r.jsx)(z.$,{variant:"outline",onClick:e=>{e.preventDefault(),i(!t)},children:t?"Hide Points":"Show Points"})})}),(0,r.jsx)(T,{}),(0,r.jsx)(M,{}),(0,r.jsx)(O,{})]})]})})});var A=t(3268),j=t(3628);function U(e){let{pointID:n,pointLoc:t,showPointInfo:i,plotUnits:a}=e,{plotDim:o,dimArrays:s,dimNames:u,dimUnits:f,timeSeries:m}=(0,c.on)((0,d.k)(e=>({plotDim:e.plotDim,dimArrays:e.dimArrays,dimNames:e.dimNames,dimUnits:e.dimUnits,timeSeries:e.timeSeries}))),x=0,v=0;if(Object.entries(n).length>0&&Object.entries(m).length>0){let[e,t]=n;x=m[e].data[t],v=s[o][t]}let[h,S]=t,[g,y]=(0,l.useState)(!1);return(0,l.useEffect)(()=>{if(!i){let e=setTimeout(()=>{y(!1)},100);return()=>clearTimeout(e)}y(!0)},[i]),(0,r.jsx)(r.Fragment,{children:g&&(0,r.jsxs)("div",{className:"point-info",style:{left:"".concat(h,"px"),top:"".concat(S,"px")},children:["".concat(x.toFixed(2)).concat(a),(0,r.jsx)("br",{}),"".concat(u[o],": ").concat((0,p.SB)(v,f[o]),"       \n        ")]})})}function N(e){let{open:n,height:t}=e,{coords:i,timeSeries:a,setDimCoords:o,setTimeSeries:s}=(0,c.on)((0,d.k)(e=>({coords:e.dimCoords,timeSeries:e.timeSeries,setDimCoords:e.setDimCoords,setTimeSeries:e.setTimeSeries}))),[u,f]=(0,l.useState)(!1),m=(0,l.useRef)([0,Math.round(.255*window.innerHeight)]),x=(0,l.useRef)([0,Math.round(.255*window.innerHeight)]),[v,h]=(0,l.useState)([0,Math.round(.255*window.innerHeight)]);function S(e){if(u){let n=m.current[0]-e.clientX,t=m.current[1]-e.clientY,r=Math.min(Math.max(x.current[0]-n,10),window.innerWidth-120),i=Math.max(x.current[1]+t,0);h([Math.min(r,window.innerWidth-100),Math.min(i,window.innerHeight-100)])}}function g(){f(!1)}(0,l.useEffect)(()=>(u&&(document.addEventListener("mousemove",S),document.addEventListener("mouseup",g)),()=>{document.removeEventListener("mousemove",S),document.removeEventListener("mouseup",g)}),[u]);let y=v[0]<window.innerWidth/2;return(0,r.jsx)(r.Fragment,{children:(0,r.jsx)("div",{className:"coord-container",onPointerDown:function(e){m.current=[e.clientX,e.clientY],x.current=[...v],f(!0)},onPointerMove:S,onPointerUp:()=>f(!1),style:{left:"".concat(v[0],"px"),bottom:"".concat(v[1],"px"),transform:n?"":"translateX(".concat((y?-1:1)*window.innerWidth,"px) translateY(").concat(-t,"px)"),transition:"transform 0.5s ease"},children:Object.keys(i).length>0&&Object.keys(i).reverse().map((e,n)=>(0,r.jsxs)("div",{className:"plot-coords",style:{background:"rgb(".concat(a[e].color,")"),justifyContent:"space-between"},children:[(0,r.jsx)("b",{children:"".concat(i[e].first.name,": ")}),"".concat((0,p.SB)(i[e].first.loc,i[e].first.units)),(0,r.jsx)("br",{}),(0,r.jsx)("b",{children:"".concat(i[e].second.name,": ")}),"".concat((0,p.SB)(i[e].second.loc,i[e].second.units)),(0,r.jsx)(A.Xr4,{onClick:()=>(function(e){let{[e]:n,...t}=i;o(t);let{[e]:r,...l}=a;s(l)})(e),style:{cursor:"pointer",zIndex:3},size:24})]},e))})})}function E(){let[e,n]=(0,l.useState)(["",0]),[t,i]=(0,l.useState)([0,0]),[a,o]=(0,l.useState)(!1),[s,u]=(0,l.useState)(Math.round(window.innerHeight-.25*window.innerHeight)),{metadata:f,timeSeries:m}=(0,c.on)((0,d.k)(e=>({metadata:e.metadata,timeSeries:e.timeSeries}))),p=f?f.units:"Default",[x,v]=(0,l.useState)(!0),[h,S]=(0,l.useState)(!1),z=(0,l.useRef)(null),w=(0,l.useRef)(!1),[b,I]=(0,l.useState)(1),[_,C]=(0,l.useState)(1),D=(0,l.useRef)(null);return(0,l.useEffect)(()=>{let e=()=>{let e=Math.round(window.innerHeight-.25*window.innerHeight);u(e),document.documentElement.style.setProperty("--plot-height","".concat(e,"px"))};return window.addEventListener("orientationchange",e),window.addEventListener("resize",e),()=>{window.removeEventListener("orientationchange",e),window.removeEventListener("resize",e)}},[]),(0,l.useEffect)(()=>{function e(e){!z.current||z.current.contains(e.target)||w.current||h||(D.current&&clearTimeout(D.current),D.current=setTimeout(()=>{v(!1),D.current=null},100))}return x&&document.addEventListener("mousedown",e),()=>{document.removeEventListener("mousedown",e),D.current&&(clearTimeout(D.current),D.current=null)}},[x,h]),(0,l.useEffect)(()=>{D.current&&(clearTimeout(D.current),D.current=null),x||v(!0)},[m]),(0,l.useEffect)(()=>{document.documentElement.style.setProperty("--plot-height","".concat(s,"px"))},[s]),(0,r.jsxs)(r.Fragment,{children:[(0,r.jsx)(y.de,{onClick:()=>{v(!0)}}),(0,r.jsxs)("div",{ref:z,className:"plot-canvas",style:{transform:x?"":"translateY(".concat(s,"px)")},children:[(0,r.jsx)(j.LBY,{style:{position:"absolute",top:5,left:5,color:h?"":"gray",zIndex:5,cursor:"pointer"},onClick:()=>{S(e=>!e)},size:20}),(0,r.jsx)(B,{menuRef:w}),a&&(0,r.jsx)(U,{pointID:e,pointLoc:t,showPointInfo:a,plotUnits:p}),(0,r.jsx)(y.A,{height:s,setHeight:u}),(0,r.jsx)(y.gj,{scale:b,setScale:I}),(0,r.jsx)(y.LC,{scale:_,setScale:C}),(0,r.jsxs)(g.Hl,{orthographic:!0,camera:{position:[0,0,100]},frameloop:"demand",children:[(0,r.jsx)(ec,{height:s,yScale:b,pointSetters:{setPointID:n,setPointLoc:i,setShowPointInfo:o},xScale:_}),(0,r.jsx)(R,{height:s,yScale:b,xScale:_})]}),(0,r.jsx)(N,{open:x,height:s})]})]})}var V=t(1855),L=t(9841);function R(e){let{colorTicks:n="grey",tickSize:t=4,fontSize:i=14,showGrid:a=!0,gridOpacity:o=.5,height:s,yScale:u=1,xScale:m=1}=e,{camera:x}=(0,f.C)(),[v,h]=(0,l.useState)({left:0,right:0,top:0,bottom:0}),{dimCoords:S,dimArrays:g,plotDim:y,valueScales:z}=(0,c.on)((0,d.k)(e=>({dimCoords:e.dimCoords,dimArrays:e.dimArrays,plotDim:e.plotDim,valueScales:e.valueScales}))),{zSlice:w,ySlice:b,xSlice:I}=(0,c.Ws)((0,d.k)(e=>({zSlice:e.zSlice,ySlice:e.ySlice,xSlice:e.xSlice}))),_=[g[0].slice(w[0],w[1]?w[1]:void 0),g[1].slice(b[0],b[1]?b[1]:void 0),g[2].slice(I[0],I[1]?I[1]:void 0)][y],C=_.length,D=z.maxVal-z.minVal,P=(0,l.useMemo)(()=>{let e=["Jan","Feb","Mar","Apr","May","Jun","Jul","Aug","Sep","Oct","Nov","Dec"];if(_){if(_.every(e=>"bigint"==typeof e)){let n=Object.keys(S).length>0?Object.keys(S)[0]:null,[t,r]=n?(0,p.lt)(S[n].plot.units):[1,0],i=[];for(let n=0;n<_.length;n++){let a=new Date(Number(_[n])*t+r),o="".concat(a.getDate().toString().padStart(2,"0")," ").concat(e[a.getMonth()],"\n").concat(a.getFullYear());i.push(o)}return i}return _.map(e=>String(e))}},[_,S]),M=(0,l.useMemo)(()=>{let e=window.innerWidth,n=window.innerHeight-s;return{left:-e/2+x.position.x,right:e/2+x.position.x,top:n/2+x.position.y,bottom:-n/2+x.position.y}},[]),[k,T]=(0,l.useState)(x.zoom),O=(0,l.useMemo)(()=>{let e=1/x.zoom;return{tickSize:t*e,fontSize:i/e,labelOffset:t*e}},[x.zoom,t,i]);(0,f.D)(()=>{x.zoom!==k&&T(x.zoom);let e=window.innerWidth/x.zoom,n=(window.innerHeight-s)/x.zoom,t={left:-e/2+x.position.x,right:e/2+x.position.x,top:n/2+x.position.y,bottom:-n/2+x.position.y};JSON.stringify(v)!=JSON.stringify(t)&&h(t)});let B=(0,l.useRef)(null),A=(0,l.useRef)(null);(0,l.useEffect)(()=>(B.current&&clearTimeout(B.current),A.current&&(B.current=setTimeout(()=>{A.current&&A.current.reset()},100)),()=>{null!==B.current&&clearTimeout(B.current)}),[s]);let j=(v.top+v.bottom)/2,U=(v.left+v.right)/2;return(0,r.jsxs)("group",{children:[a&&(0,r.jsxs)(r.Fragment,{children:[Array.from({length:10},(e,t)=>{var i;if(0===t||9===t)return null;let a=+Math.round(v.left/1)+(Math.round(v.right/1)-Math.round(v.left/1))*(t/9),s=a/m/(M.right-M.left)+.5;return(0,r.jsxs)(l.Fragment,{children:[(0,r.jsx)("group",{position:[a,j,0],children:(0,r.jsxs)("line",{children:[(0,r.jsx)("bufferGeometry",{children:(0,r.jsx)("float32BufferAttribute",{attach:"attributes-position",args:[new Float32Array([0,v.top-j,0,0,v.bottom-j,0]),3]})}),(0,r.jsx)("lineDashedMaterial",{color:n,opacity:o,transparent:!0,dashSize:.5,gapSize:.5})]},"vgrid-".concat(t))}),(0,r.jsxs)("group",{position:[a,v.top,0],children:[(0,r.jsxs)("line",{children:[(0,r.jsx)("bufferGeometry",{children:(0,r.jsx)("float32BufferAttribute",{attach:"attributes-position",args:[new Float32Array([0,0,0,0,-O.tickSize,0]),3]})}),(0,r.jsx)("lineBasicMaterial",{color:n})]}),0!==t&&9!==t&&(0,r.jsx)(V.E,{position:[0,O.tickSize/4-O.labelOffset,0],fontSize:O.fontSize/k**2,color:n,anchorX:"center",anchorY:"top",children:null!=(i=null==P?void 0:P[Math.round(s*C-.5)])?i:""})]},"top-tick-".concat(t))]},"vert-group-".concat(t))}),Array.from({length:8},(e,t)=>{if(0===t||7===t)return null;let i=v.bottom+(v.top-v.bottom)*(t/7),a=i/u/(v.top-v.bottom)/k+.5;return(0,r.jsxs)(l.Fragment,{children:[(0,r.jsx)("group",{position:[U,i,0],children:(0,r.jsxs)("line",{children:[(0,r.jsx)("bufferGeometry",{children:(0,r.jsx)("float32BufferAttribute",{attach:"attributes-position",args:[new Float32Array([v.left-U,0,0,v.right-U,0,0]),3]})}),(0,r.jsx)("lineDashedMaterial",{color:n,opacity:o,transparent:!0,dashSize:0,gapSize:.5,linewidth:1})]})},"hgrid-".concat(t)),(0,r.jsxs)("group",{position:[v.right,i,0],children:[(0,r.jsxs)("line",{children:[(0,r.jsx)("bufferGeometry",{children:(0,r.jsx)("float32BufferAttribute",{attach:"attributes-position",args:[new Float32Array([0,0,0,-O.tickSize,0,0]),3]})}),(0,r.jsx)("lineBasicMaterial",{color:n})]}),0!==t&&7!==t&&(0,r.jsx)(V.E,{position:[-O.tickSize-O.labelOffset,0,0],fontSize:O.fontSize/k**2,color:n,anchorX:"right",anchorY:"middle",children:(z.minVal+a*D).toFixed(1)})]},"right-tick-".concat(t))]},"vert-group-".concat(t))})]}),(0,r.jsx)(L.N,{ref:A,enableRotate:!1,enablePan:!0,enableZoom:!0,zoomSpeed:.85,maxDistance:500,maxZoom:20,minZoom:.5})]})}var Y=t(5659);t(7343);let F=e=>{let{loc:n,show:t,info:i}=e,{dimNames:a,dimUnits:o}=(0,c.on)((0,d.k)(e=>({dimNames:e.dimNames,dimUnits:e.dimUnits}))),s=(0,c.r2)(e=>e.axis),u=(0,l.useMemo)(()=>a.length<3?[a[0],a[1]]:a.filter((e,n)=>n!=s),[a,s]),f=(0,l.useMemo)(()=>a.length<3?[o[0],o[1]]:o.filter((e,n)=>n!=s),[o,s]);return(0,r.jsxs)("div",{className:"analysis-overlay",style:{left:"".concat(n[0]+10,"px"),top:"".concat(n[1]+10,"px"),display:t?"":"none"},children:["".concat(u[0],": ").concat(t&&(0,p.SB)(i[0],f[0])),(0,r.jsx)("br",{}),"".concat(u[1],": ").concat(t&&(0,p.SB)(i[1],f[1])),(0,r.jsx)("br",{}),"Value: ".concat(Math.round(100*i[2])/100)]})};var X=t(8131);let G=e=>{let n="f16"===e?"enable f16;":"",t="\n        ".concat(n,"\n        struct Params {\n            zStride: u32,\n            yStride: u32,\n            xStride: u32,\n            xSize: u32,\n            ySize: u32,\n            reduceDim: u32,\n            dimLength: u32,\n        };\n        @group(0) @binding(0) var<storage, read> inputData: array<").concat(e,">;\n        @group(0) @binding(1) var<storage, read_write> outputData: array<").concat(e,">;\n        @group(0) @binding(2) var<uniform> params: Params;\n\n        @compute @workgroup_size(16, 16, 1)\n        fn main(@builtin(global_invocation_id) global_id: vec3<u32>) {\n            let zStride = params.zStride;\n            let yStride = params.yStride;\n            let xStride = params.xStride;\n            let xSize = params.xSize;\n            let ySize = params.ySize;\n            let reduceDim = params.reduceDim;\n            let dimLength = params.dimLength;\n                            \n            let outX = global_id.y;\n            let outY = global_id.x;\n            \n            if (outX >= xSize || outY >= ySize) {\n                return;\n            }\n    "),r="\n        ".concat(n,"\n        struct Params {\n            xStride: u32,\n            yStride: u32,\n            zStride: u32,\n            xSize: u32,\n            ySize: u32,\n            zSize: u32,\n            workGroups: vec3<u32>,\n            kernelSize: u32,\n            kernelDepth: u32\n        };\n        @group(0) @binding(0) var<storage, read> inputData: array<").concat(e,">;\n        @group(0) @binding(1) var<storage, read_write> outputData: array<").concat(e,">;\n        @group(0) @binding(2) var<uniform> params: Params;\n        \n        @compute @workgroup_size(4, 4, 4)\n        fn main(@builtin(global_invocation_id) global_id: vec3<u32>) {\n            let zStride = params.zStride;\n            let yStride = params.yStride;\n            let xStride = params.xStride; \n            let xSize = params.xSize;\n            let ySize = params.ySize;\n            let zSize = params.zSize; \n            let workGroups = params.workGroups;\n            let kernelSize = params.kernelSize;\n            let kernelDepth = params.kernelDepth;\n\n            let outX = global_id.x; \n            let outY = global_id.y;\n            let outZ = global_id.z; \n\n            if (outX >= xSize || outY >= ySize || outZ >= zSize) {\n                return;\n            }\n\n            let total_threads_per_slice = workGroups.x * workGroups.y * 16;\n            let globalIdx = global_id.z * total_threads_per_slice + \n                            global_id.y * (workGroups.x * 4) + \n                            global_id.x;\n\n            let xy_radius: i32 = i32(kernelSize/2u);\n            let z_radius: i32 = i32(kernelDepth/2u);\n\n            let xy_start: i32 = select(-xy_radius, 0, kernelSize == 1u);\n            let xy_end: i32 = select(xy_radius + 1, 1, kernelSize == 1u);\n            let z_start: i32 = select(-z_radius, 0, kernelDepth == 1u);\n            let z_end: i32 = select(z_radius + 1, 1, kernelDepth == 1u);\n    "),i="\n        ".concat(n,"\n        struct Params {\n            xStride: u32,\n            yStride: u32,\n            xSize: u32,\n            ySize: u32,\n            kernelSize: u32,\n            kernelDepth: u32\n        };\n        @group(0) @binding(0) var<storage, read> inputData: array<").concat(e,">;\n        @group(0) @binding(1) var<storage, read_write> outputData: array<").concat(e,">;\n        @group(0) @binding(2) var<uniform> params: Params;\n\n        @compute @workgroup_size(16, 16, 1)\n        fn main(@builtin(global_invocation_id) global_id: vec3<u32>,) {\n            let xStride = params.xStride; \n            let yStride = params.yStride;\n            let xSize = params.xSize;\n            let ySize = params.ySize;\n            let kernelSize = params.kernelSize;\n\n            let outX = global_id.x; \n            let outY = global_id.y;\n\n            if (outX >= xSize|| outY >= ySize) {\n                return;\n            }\n\n            let globalIdx = outY * xSize + outX;\n            let thisVal = inputData[globalIdx];\n            let isNaN: bool = thisVal != thisVal;\n            if (isNaN){\n                outputData[globalIdx] = thisVal;\n                return;\n            }   \n\n            let xy_radius: i32 = i32(kernelSize/2u);\n\n    ");return{MeanReduction:"\n        ".concat(t,"\n            var sum: f32 = 0.0;\n            \n            // Iterate along the dimension we're averaging\n            if (reduceDim == 0u) { // Average along Z\n                let cCoord = outX * xStride + outY * yStride;\n                for (var z: u32 = 0u; z < dimLength; z++) {\n                    let inputIndex = cCoord + (z * zStride);\n                    let newVal = f32(inputData[u32(inputIndex)]);\n                    if (newVal != newVal){ //This only evaluates if newVal is NaN\n                        continue;\n                    }\n                    sum += newVal;\n                }\n            } else if (reduceDim == 1u) { // Average along Y\n                let cCoord = outX * xStride + outY * zStride;\n                for (var y: u32 = 0u; y < dimLength; y++) {\n                    let inputIndex = cCoord + (y * yStride);\n                    let newVal = f32(inputData[u32(inputIndex)]);\n                    if (newVal != newVal){ //This only evaluates if newVal is NaN\n                        continue;\n                    }\n                    sum += newVal;\n                }\n            } else { // Average along X\n                let cCoord = outX * yStride + outY * zStride;\n                for (var x: u32 = 0u; x < dimLength; x++) {\n                    let inputIndex = cCoord + (x * xStride);\n                    let newVal = f32(inputData[u32(inputIndex)]);\n                    if (newVal != newVal){ //This only evaluates if newVal is NaN\n                        continue;\n                    }\n                    sum += newVal;\n                }\n            }\n            \n            let outputIndex = outY * xSize + outX;\n            outputData[outputIndex] = ").concat(e,"(sum / f32(dimLength));\n        }\n    "),MinReduction:"\n        ".concat(t,"\n            var min: f32 = 1e12;\n            \n            // Iterate along the dimension we're averaging\n            if (reduceDim == 0u) { // Average along Z\n                let cCoord = outX * xStride + outY * yStride;\n                for (var z: u32 = 0u; z < dimLength; z++) {\n                    let inputIndex = cCoord + (z * zStride);\n                    let newMin = f32(inputData[inputIndex]);\n                    if (newMin < min) {\n                        min = newMin;\n                    }\n                }\n            } else if (reduceDim == 1u) { // Average along Y\n                let cCoord = outX * xStride + outY * zStride;\n                for (var y: u32 = 0u; y < dimLength; y++) {\n                    let inputIndex = cCoord + (y * yStride);\n                    let newMin = f32(inputData[inputIndex]);\n                    if (newMin < min) {\n                        min = newMin;\n                    }\n                }\n            } else { // Average along X\n                let cCoord = outX * yStride + outY * zStride;\n                for (var x: u32 = 0u; x < dimLength; x++) {\n                    let inputIndex = cCoord + (x * xStride);\n                    let newMin = f32(inputData[inputIndex]);\n                    if (newMin < min) {\n                        min = newMin;\n                    }\n                }\n            }\n            \n            let outputIndex = outY * xSize + outX;\n            outputData[outputIndex] = ").concat(e,"(min);\n        }\n    "),MaxReduction:"\n        ".concat(t,"\n            \n            var max: f32 = -1e12;\n            \n            // Iterate along the dimension we're averaging\n            if (reduceDim == 0u) { // Average along Z\n                let cCoord = outX * xStride + outY * yStride;\n                for (var z: u32 = 0u; z < dimLength; z++) {\n                    let inputIndex = cCoord + (z * zStride);\n                    let newMax = f32(inputData[inputIndex]);\n                    if (newMax > max) {\n                        max = newMax;\n                    }\n                }\n            } else if (reduceDim == 1u) { // Average along Y\n                let cCoord = outX * xStride + outY * zStride;\n                for (var y: u32 = 0u; y < dimLength; y++) {\n                    let inputIndex = cCoord + (y * yStride);\n                    let newMax = f32(inputData[inputIndex]);\n                    if (newMax > max) {\n                        max = newMax;\n                    }\n                }\n            } else { // Average along X\n                let cCoord = outX * yStride + outY * zStride;\n                for (var x: u32 = 0u; x < dimLength; x++) {\n                    let inputIndex = cCoord + (x * xStride);\n                    let newMax = f32(inputData[inputIndex]);\n                    if (newMax > max) {\n                        max = newMax;\n                    }\n                }\n            }\n            \n            let outputIndex = outY * xSize + outX;\n            outputData[outputIndex] = ").concat(e,"(max);\n        }\n    "),StDevReduction:"\n        ".concat(t,"\n            var sum: f32 = 0.0;\n            // Iterate along the dimension we're averaging\n            if (reduceDim == 0u) { // Average along Z\n                let cCoord = outX * xStride + outY * yStride;\n                for (var z: u32 = 0u; z < dimLength; z++) {\n                    let inputIndex = cCoord + (z * zStride);\n                    let newVal = f32(inputData[u32(inputIndex)]);\n                    if (newVal != newVal){ //This only evaluates if newVal is NaN\n                        continue;\n                    }\n                    sum += newVal;\n                }\n            } else if (reduceDim == 1u) { // Average along Y\n                let cCoord = outX * xStride + outY * zStride;\n                for (var y: u32 = 0u; y < dimLength; y++) {\n                    let inputIndex = cCoord + (y * yStride);\n                    let newVal = f32(inputData[u32(inputIndex)]);\n                    if (newVal != newVal){ //This only evaluates if newVal is NaN\n                        continue;\n                    }\n                    sum += newVal;\n                }\n            } else { // Average along X\n                let cCoord = outX * yStride + outY * zStride;\n                for (var x: u32 = 0u; x < dimLength; x++) {\n                    let inputIndex = cCoord + (x * xStride);\n                    let newVal = f32(inputData[u32(inputIndex)]);\n                    if (newVal != newVal){ //This only evaluates if newVal is NaN\n                        continue;\n                    }\n                    sum += newVal;\n                }\n            }\n            \n            let mean: f32 = sum / f32(dimLength);\n\n            var squaredDiffSum: f32 = 0.0;\n\n            // Iterate along the dimension again\n            if (reduceDim == 0u) { // Average along Z\n                let cCoord = outX * xStride + outY * yStride;\n                for (var z: u32 = 0u; z < dimLength; z++) {\n                    let inputIndex = cCoord + (z * zStride);\n                    let newVal = f32(inputData[u32(inputIndex)]);\n                    if (newVal != newVal){ //This only evaluates if newVal is NaN\n                        continue;\n                    }\n                    let diff: f32 = mean - newVal;\n                    squaredDiffSum += diff*diff;\n                }\n            } else if (reduceDim == 1u) { // Average along Y\n                let cCoord = outX * xStride + outY * zStride;\n                for (var y: u32 = 0u; y < dimLength; y++) {\n                    let inputIndex = cCoord + (y * yStride);\n                    let newVal = f32(inputData[u32(inputIndex)]);\n                    if (newVal != newVal){ //This only evaluates if newVal is NaN\n                        continue;\n                    }\n                    let diff: f32 = mean - newVal;\n                    squaredDiffSum += diff*diff;\n                }\n            } else { // Average along X\n                let cCoord = outX * yStride + outY * zStride;\n                for (var x: u32 = 0u; x < dimLength; x++) {\n                    let inputIndex = cCoord + (x * xStride);\n                    let newVal = f32(inputData[u32(inputIndex)]);\n                    if (newVal != newVal){ //This only evaluates if newVal is NaN\n                        continue;\n                    }\n                    let diff: f32 = mean - newVal;\n                    squaredDiffSum += diff*diff;\n                }\n            }\n\n            let stDev: f32 = sqrt(squaredDiffSum / f32(dimLength));\n            let outputIndex = outY * xSize + outX;\n            outputData[outputIndex] = ").concat(e,"(stDev);\n        }\n    "),CUMSUMReduction:"\n        ".concat(n,"\n        struct Params {\n            zStride: u32,\n            yStride: u32,\n            xStride: u32,\n            xSize: u32,\n            ySize: u32,\n            reduceDim: u32,\n            dimLength: u32,\n        };\n        @group(0) @binding(0) var<storage, read> inputData: array<").concat(e,">;\n        @group(0) @binding(1) var<storage, read_write> outputData: array<f32>;\n        @group(0) @binding(2) var<uniform> params: Params;\n\n        @compute @workgroup_size(16, 16, 1)\n        fn main(@builtin(global_invocation_id) global_id: vec3<u32>) {\n            let zStride = params.zStride;\n            let yStride = params.yStride;\n            let xStride = params.xStride;\n            let xSize = params.xSize;\n            let ySize = params.ySize;\n            let reduceDim = params.reduceDim;\n            let dimLength = params.dimLength;\n                            \n            let outX = global_id.y;\n            let outY = global_id.x;\n            \n            if (outX >= xSize || outY >= ySize) {\n                return;\n            }\n            \n            var accum: f32 = 0;\n            \n            // Iterate along the dimension we're averaging\n            if (reduceDim == 0u) { // Average along Z\n                let cCoord = outX * xStride + outY * yStride;\n                for (var z: u32 = 0u; z < dimLength; z++) {\n                    let inputIndex = cCoord + (z * zStride);\n                    accum += f32(inputData[inputIndex]);\n                    \n                }\n            } else if (reduceDim == 1u) { // Average along Y\n                let cCoord = outX * xStride + outY * zStride;\n                for (var y: u32 = 0u; y < dimLength; y++) {\n                    let inputIndex = cCoord + (y * yStride);\n                    accum += f32(inputData[inputIndex]);\n                }\n            } else { // Average along X\n                let cCoord = outX * yStride + outY * zStride;\n                for (var x: u32 = 0u; x < dimLength; x++) {\n                    let inputIndex = cCoord + (x * xStride);\n                    accum += f32(inputData[inputIndex]);\n                }\n            }\n            \n            let outputIndex = outY * xSize + outX;\n            outputData[outputIndex] = accum;\n        }\n    "),LinearSlopeReduction:"\n        ".concat(t,"\n            let meanY: f32 = f32(dimLength)/2;\n            var sum: f32 = 0.0;\n\n\n            // Iterate along the dimension we're averaging\n            if (reduceDim == 0u) { // Average along Z\n                let cCoord = outX * xStride + outY * yStride;\n                for (var z: u32 = 0u; z < dimLength; z++) {\n                    let inputIndex = cCoord + (z * zStride);\n                    sum += f32(inputData[inputIndex]);\n                }\n            } else if (reduceDim == 1u) { // Average along Y\n                let cCoord = outX * xStride + outY * zStride;\n                for (var y: u32 = 0u; y < dimLength; y++) {\n                    let inputIndex = cCoord + (y * yStride);\n                    sum += f32(inputData[inputIndex]);\n                }\n            } else { // Average along X\n                let cCoord = outX * yStride + outY * zStride;\n                for (var x: u32 = 0u; x < dimLength; x++) {\n                    let inputIndex = cCoord + (x * xStride);\n                    sum += f32(inputData[inputIndex]);\n                }\n            }\n            \n            let meanX: f32 = sum / f32(dimLength);\n            var numSum: f32 = 0;\n            var denomSum: f32 = 0;\n\n            if (reduceDim == 0u) { // Average along Z\n                let cCoord = outX * xStride + outY * yStride;\n                for (var z: u32 = 0u; z < dimLength; z++) {\n                    let inputIndex = cCoord + (z * zStride);\n                    let xi: f32 = f32(inputData[inputIndex]);\n                    numSum += (xi - meanX)*(f32(z) - meanY);\n                    denomSum += (f32(z) - meanY)*(f32(z) - meanY);\n                }\n            } else if (reduceDim == 1u) { // Average along Y\n                let cCoord = outX * xStride + outY * zStride;\n                for (var y: u32 = 0u; y < dimLength; y++) {\n                    let inputIndex = cCoord + (y * yStride);\n                    let xi: f32 = f32(inputData[inputIndex]);\n                    numSum += (xi - meanX)*(f32(y) - meanY);\n                    denomSum += (f32(y) - meanY)*(f32(y) - meanY);\n                }\n            } else { // Average along X\n                let cCoord = outX * yStride + outY * zStride;\n                for (var x: u32 = 0u; x < dimLength; x++) {\n                    let inputIndex = cCoord + (x * xStride);\n                    let xi: f32 = f32(inputData[inputIndex]);\n                    numSum += (xi - meanX)*(f32(x) - meanY);\n                    denomSum += (f32(x) - meanY)*(f32(x) - meanY);\n                }\n            }\n            \n            let outputIndex = outY * xSize + outX;\n            outputData[outputIndex] = ").concat(e,"(numSum/denomSum);\n        }\n    "),TwoVarLinearSlopeReduction:"\n        ".concat(n,"\n        struct Params {\n        zStride: u32,\n        yStride: u32,\n        xStride: u32,\n        xSize: u32,\n        ySize: u32,\n        reduceDim: u32,\n        dimLength: u32,\n        };\n        @group(0) @binding(0) var<storage, read> firstData: array<").concat(e,">;\n        @group(0) @binding(1) var<storage, read> secondData: array<").concat(e,">;\n        @group(0) @binding(2) var<storage, read_write> outputData: array<").concat(e,">;\n        @group(0) @binding(3) var<uniform> params: Params;\n\n        @compute @workgroup_size(16, 16, 1)\n        fn main(@builtin(global_invocation_id) global_id: vec3<u32>) {\n            let zStride = params.zStride;\n            let yStride = params.yStride;\n            let xStride = params.xStride;\n            let xSize = params.xSize;\n            let ySize = params.ySize;\n            let reduceDim = params.reduceDim;\n            let dimLength = params.dimLength;\n                            \n            let outX = global_id.y;\n            let outY = global_id.x;\n            \n            if (outX >= xSize || outY >= ySize) {\n                return;\n            }\n\n            var ySum: f32 = 0;\n            var xSum: f32 = 0.0;\n\n            // Iterate along the dimension we're averaging\n            if (reduceDim == 0u) { \n                let cCoord = outX * xStride + outY * yStride;\n                for (var z: u32 = 0u; z < dimLength; z++) {\n                    let inputIndex = cCoord + (z * zStride);\n                    let xi: f32 = f32(firstData[inputIndex]);\n                    let yi: f32 = f32(secondData[inputIndex]);\n                    if (xi != xi || yi != yi){ //This only evaluates if a value is NaN\n                        continue;\n                    }\n                    xSum += f32(firstData[inputIndex]);\n                    ySum += f32(secondData[inputIndex]);\n                }\n            } else if (reduceDim == 1u) { \n                let cCoord = outX * xStride + outY * zStride;\n                for (var y: u32 = 0u; y < dimLength; y++) {\n                    let inputIndex = cCoord + (y * yStride);\n                    let xi: f32 = f32(firstData[inputIndex]);\n                    let yi: f32 = f32(secondData[inputIndex]);\n                    if (xi != xi || yi != yi){ //This only evaluates if a value is NaN\n                        continue;\n                    }\n                    xSum += f32(firstData[inputIndex]);\n                    ySum += f32(secondData[inputIndex]);\n                }\n            } else { \n                let cCoord = outX * yStride + outY * zStride;\n                for (var x: u32 = 0u; x < dimLength; x++) {\n                    let inputIndex = cCoord + (x * xStride);\n                    let xi: f32 = f32(firstData[inputIndex]);\n                    let yi: f32 = f32(secondData[inputIndex]);\n                    if (xi != xi || yi != yi){ //This only evaluates if a value is NaN\n                        continue;\n                    }\n                    xSum += f32(firstData[inputIndex]);\n                    ySum += f32(secondData[inputIndex]);\n                }\n            }\n            \n            let xMean: f32 = xSum / f32(dimLength);\n            let yMean: f32 = ySum / f32(dimLength);\n            var numSum: f32 = 0;\n            var denomSum: f32 = 0;\n\n            if (reduceDim == 0u) { // Average along Z\n                let cCoord = outX * xStride + outY * yStride;\n                for (var z: u32 = 0u; z < dimLength; z++) {\n                    let inputIndex = cCoord + (z * zStride);\n                    let xi: f32 = f32(firstData[inputIndex]);\n                    let yi: f32 = f32(secondData[inputIndex]);\n                    if (xi != xi || yi != yi){ //This only evaluates if a value is NaN\n                        continue;\n                    }\n                    numSum += (xi - xMean)*(f32(yi) - yMean);\n                    denomSum += (f32(yi) - yMean)*(f32(yi) - yMean);\n                }\n            } else if (reduceDim == 1u) { // Average along Y\n                let cCoord = outX * xStride + outY * zStride;\n                for (var y: u32 = 0u; y < dimLength; y++) {\n                    let inputIndex = cCoord + (y * yStride);\n                    let xi: f32 = f32(firstData[inputIndex]);\n                    let yi: f32 = f32(secondData[inputIndex]);\n                    if (xi != xi || yi != yi){ //This only evaluates if a value is NaN\n                        continue;\n                    }\n                    numSum += (xi - xMean)*(f32(yi) - yMean);\n                    denomSum += (f32(yi) - yMean)*(f32(yi) - yMean);\n                }\n            } else { // Average along X\n                let cCoord = outX * yStride + outY * zStride;\n                for (var x: u32 = 0u; x < dimLength; x++) {\n                    let inputIndex = cCoord + (x * xStride);\n                    let xi: f32 = f32(firstData[inputIndex]);\n                    let yi: f32 = f32(secondData[inputIndex]);\n                    if (xi != xi || yi != yi){ //This only evaluates if a value is NaN\n                        continue;\n                    }\n                    numSum += (xi - xMean)*(f32(yi) - yMean);\n                    denomSum += (f32(yi) - yMean)*(f32(yi) - yMean);\n                }\n            }\n            \n            let outputIndex = outY * xSize + outX;\n            outputData[outputIndex] = ").concat(e,"(numSum/(denomSum+1e-4));\n        }\n    "),CovarianceReduction:"\n        ".concat(n,"\n        struct Params {\n        zStride: u32,\n        yStride: u32,\n        xStride: u32,\n        xSize: u32,\n        ySize: u32,\n        reduceDim: u32,\n        dimLength: u32,\n        };\n        @group(0) @binding(0) var<storage, read> firstData: array<").concat(e,">;\n        @group(0) @binding(1) var<storage, read> secondData: array<").concat(e,">;\n        @group(0) @binding(2) var<storage, read_write> outputData: array<").concat(e,">;\n        @group(0) @binding(3) var<uniform> params: Params;\n\n        @compute @workgroup_size(16, 16, 1)\n        fn main(@builtin(global_invocation_id) global_id: vec3<u32>) {\n            let zStride = params.zStride;\n            let yStride = params.yStride;\n            let xStride = params.xStride;\n            let xSize = params.xSize;\n            let ySize = params.ySize;\n            let reduceDim = params.reduceDim;\n            let dimLength = params.dimLength;\n                            \n            let outX = global_id.y;\n            let outY = global_id.x;\n            \n            if (outX >= xSize || outY >= ySize) {\n                return;\n            }\n            var ySum: f32 = 0;\n            var xSum: f32 = 0.0;\n            var numSum: f32 = 0;\n\n        // Calculate base coordinate and stride for the dimension we're iterating over\n            var baseCoord: u32;\n            var iterStride: u32;\n\n            if (reduceDim == 0u) {\n                baseCoord = outX * xStride + outY * yStride;\n                iterStride = zStride;\n            } else if (reduceDim == 1u) {\n                baseCoord = outX * xStride + outY * zStride;\n                iterStride = yStride;\n            } else {\n                baseCoord = outX * yStride + outY * zStride;\n                iterStride = xStride;\n            }\n\n            // Single pass: calculate sums, means, and covariance\n            for (var i: u32 = 0u; i < dimLength; i++) {\n                let inputIndex = baseCoord + (i * iterStride);\n                let xi: f32 = f32(firstData[inputIndex]);\n                let yi: f32 = f32(secondData[inputIndex]);\n                if (xi != xi || yi != yi){ //This only evaluates if a value is NaN\n                    continue;\n                }\n                xSum += xi;\n                ySum += yi;\n            }\n\n            let xMean: f32 = xSum / f32(dimLength);\n            let yMean: f32 = ySum / f32(dimLength);\n\n            // Second pass for covariance calculation\n            for (var i: u32 = 0u; i < dimLength; i++) {\n                let inputIndex = baseCoord + (i * iterStride);\n                let xi: f32 = f32(firstData[inputIndex]);\n                let yi: f32 = f32(secondData[inputIndex]);\n                if (xi != xi || yi != yi){ //This only evaluates if a value is NaN\n                    continue;\n                }\n                numSum += (xi - xMean) * (yi - yMean);\n            }\n\n            let outputIndex = outY * xSize + outX;\n            outputData[outputIndex] = ").concat(e,"(numSum / (f32(dimLength) - 1));\n        }\n    "),CorrelationReduction:"\n        ".concat(n,"\n        struct Params {\n            zStride: u32,\n            yStride: u32,\n            xStride: u32,\n            xSize: u32,\n            ySize: u32,\n            reduceDim: u32,\n            dimLength: u32,\n        };\n        @group(0) @binding(0) var<storage, read> firstData: array<").concat(e,">;\n        @group(0) @binding(1) var<storage, read> secondData: array<").concat(e,">;\n        @group(0) @binding(2) var<storage, read_write> outputData: array<").concat(e,">;\n        @group(0) @binding(3) var<uniform> params: Params;\n\n        @compute @workgroup_size(16, 16, 1)\n        fn main(@builtin(global_invocation_id) global_id: vec3<u32>) {\n            let zStride = params.zStride;\n            let yStride = params.yStride;\n            let xStride = params.xStride;\n            let xSize = params.xSize;\n            let ySize = params.ySize;\n            let reduceDim = params.reduceDim;\n            let dimLength = params.dimLength;\n                            \n            let outX = global_id.y;\n            let outY = global_id.x;\n            \n            if (outX >= xSize || outY >= ySize) {\n                return;\n            }\n\n            var xSum: f32 = 0.0;\n            var xxSum: f32 = 0.0;\n            var ySum: f32 = 0.0;\n            var yySum: f32 = 0.0;\n            var xySum: f32 = 0.0;\n            // Iterate along the dimension we're averaging\n            if (reduceDim == 0u) { // Average along Z\n                let cCoord = outX * xStride + outY * yStride;\n                for (var z: u32 = 0u; z < dimLength; z++) {\n                    let inputIndex = cCoord + (z * zStride);\n                    let xI = f32(firstData[inputIndex]);\n                    let yI = f32(secondData[inputIndex]);\n                    if (xI != xI || yI != yI){ //This only evaluates if a value is NaN\n                        continue;\n                    }\n                    xSum += xI;\n                    xxSum += xI * xI;\n                    ySum += yI;\n                    yySum += yI * yI;\n                    xySum += xI * yI;\n                }\n            } else if (reduceDim == 1u) { // Average along Y\n                let cCoord = outX * xStride + outY * zStride;\n                for (var y: u32 = 0u; y < dimLength; y++) {\n                    let inputIndex = cCoord + (y * yStride);\n                    let xI = f32(firstData[inputIndex]);\n                    let yI = f32(secondData[inputIndex]);\n                    if (xI != xI || yI != yI){ //This only evaluates if a value is NaN\n                        continue;\n                    }\n                    xSum += xI;\n                    xxSum += xI * xI;\n                    ySum += yI;\n                    yySum += yI * yI;\n                    xySum += xI * yI;\n                }\n            } else { // Average along X\n                let cCoord = outX * yStride + outY * zStride;\n                for (var x: u32 = 0u; x < dimLength; x++) {\n                    let inputIndex = cCoord + (x * xStride);\n                    let xI = f32(firstData[inputIndex]);\n                    let yI = f32(secondData[inputIndex]);\n                    if (xI != xI || yI != yI){ //This only evaluates if a value is NaN\n                        continue;\n                    }\n                    xSum += xI;\n                    xxSum += xI * xI;\n                    ySum += yI;\n                    yySum += yI * yI;\n                    xySum += xI * yI;\n                }\n            }\n\n            let N: f32 = f32(dimLength);\n            let meanX = xSum / N;\n            let meanY = ySum / N;\n            let varX = (xxSum / N) - (meanX * meanX);\n            let varY = (yySum / N) - (meanY * meanY);\n            let covXY = (xySum / N) - (meanX * meanY);\n            let sigmaX = sqrt(max(0.0, varX));\n            let sigmaY = sqrt(max(0.0, varY));\n            let epsilon = 1e-6;\n            let denominator = sigmaX * sigmaY + epsilon;\n            let correlation = covXY / denominator;\n\n            let outputIndex = outY * xSize + outX;\n            outputData[outputIndex] = ").concat(e,"(correlation);\n        }\n    "),MeanConvolution:"\n            ".concat(r,"    \n            var sum: f32 = 0.0;\n            var count: u32 = 0u;\n            for (var kx: i32 = xy_start; kx < xy_end; kx++) {\n                for (var ky: i32 = xy_start; ky < xy_end; ky++) {\n                    for (var kz: i32 = z_start; kz < z_end; kz++){\n                        let in_coord = vec3<i32>(global_id) + vec3<i32>(kx, ky, kz);\n                        if (in_coord.x >= 0 && in_coord.x < i32(xSize) &&\n                            in_coord.y >= 0 && in_coord.y < i32(ySize) &&\n                            in_coord.z >= 0 && in_coord.z < i32(zSize)) { //Ensure the sampled point is within 3D dataspace\n                            let xOffset = kx * i32(xStride);\n                            let yOffset = ky * i32(yStride);\n                            let zOffset = kz * i32(zStride);\n                            let newIdx = i32(globalIdx) + xOffset + yOffset + zOffset;\n\n                            sum += f32(inputData[u32(newIdx)]);\n                            count ++;\n                        }\n                    }\n                }\n            }\n            outputData[globalIdx] = ").concat(e,"(sum / f32(count));\n        }\n    "),MinConvolution:"\n        ".concat(r,"  \n            var minVal: f32 = 1e12;\n            var count: u32 = 0u;\n            for (var kx: i32 = xy_start; kx < xy_end; kx++) {\n                for (var ky: i32 = xy_start; ky < xy_end; ky++) {\n                    for (var kz: i32 = z_start; kz < z_end; kz++){\n                        let in_coord = vec3<i32>(global_id) + vec3<i32>(kx, ky, kz);\n\n                        if (in_coord.x >= 0 && in_coord.x < i32(xSize) &&\n                            in_coord.y >= 0 && in_coord.y < i32(ySize) &&\n                            in_coord.z >= 0 && in_coord.z < i32(zSize)) { //Ensure the sampled point is within 3D dataspace\n                            let xOffset = kx * i32(xStride);\n                            let yOffset = ky * i32(yStride);\n                            let zOffset = kz * i32(zStride);\n                            let newIdx = i32(globalIdx) + xOffset + yOffset + zOffset;\n                            let sampledVal = f32(inputData[u32(newIdx)]);\n                            if (sampledVal < minVal){\n                                minVal = sampledVal;\n                            }\n                        }\n                    }\n                }\n            }\n            \n            outputData[globalIdx] = ").concat(e,"(minVal);\n        }\n    "),MaxConvolution:"\n        ".concat(r,"  \n\n            var maxVal: f32 = -1e12;\n            var count: u32 = 0u;\n            for (var kx: i32 = xy_start; kx < xy_end; kx++) {\n                for (var ky: i32 = xy_start; ky < xy_end; ky++) {\n                    for (var kz: i32 = z_start; kz < z_end; kz++){\n                        let in_coord = vec3<i32>(global_id) + vec3<i32>(kx, ky, kz);\n\n                        if (in_coord.x >= 0 && in_coord.x < i32(xSize) &&\n                            in_coord.y >= 0 && in_coord.y < i32(ySize) &&\n                            in_coord.z >= 0 && in_coord.z < i32(zSize)) { //Ensure the sampled point is within 3D dataspace\n                            let xOffset = kx * i32(xStride);\n                            let yOffset = ky * i32(yStride);\n                            let zOffset = kz * i32(zStride);\n                            let newIdx = i32(globalIdx) + xOffset + yOffset + zOffset;\n                            let sampledVal = f32(inputData[u32(newIdx)]);\n                            if (sampledVal > maxVal){\n                                maxVal = sampledVal;\n                            }\n                        }\n                    }\n                }\n            }\n            outputData[globalIdx] = ").concat(e,"(maxVal);\n        }\n    "),StDevConvolution:"\n        ".concat(r,"  \n            var sum: f32 = 0.0;\n            var count: u32 = 0u;\n            for (var kx: i32 = xy_start; kx < xy_end; kx++) {\n                for (var ky: i32 = xy_start; ky < xy_end; ky++) {\n                    for (var kz: i32 = z_start; kz < z_end; kz++){\n                        let in_coord = vec3<i32>(global_id) + vec3<i32>(kx, ky, kz);\n\n                        if (in_coord.x >= 0 && in_coord.x < i32(xSize) &&\n                            in_coord.y >= 0 && in_coord.y < i32(ySize) &&\n                            in_coord.z >= 0 && in_coord.z < i32(zSize)) { //Ensure the sampled point is within 3D dataspace\n                            let xOffset = kx * i32(xStride);\n                            let yOffset = ky * i32(yStride);\n                            let zOffset = kz * i32(zStride);\n                            let newIdx = i32(globalIdx) + xOffset + yOffset + zOffset;\n                            let newVal = f32(inputData[u32(newIdx)]);\n                            if (newVal != newVal){ //This only evaluates if newVal is NaN\n                                continue;\n                            }\n                            sum += newVal;\n                            count ++;\n                        }\n                    }\n                }\n            }\n            \n            let mean: f32 = sum / f32(count);\n\n            var squaredDiffSum: f32 = 0.0;\n\n            for (var kx: i32 = xy_start; kx < xy_end; kx++) {\n                for (var ky: i32 = xy_start; ky < xy_end; ky++) {\n                    for (var kz: i32 = z_start; kz < z_end; kz++){\n                        let in_coord = vec3<i32>(global_id) + vec3<i32>(kx, ky, kz);\n\n                        if (in_coord.x >= 0 && in_coord.x < i32(xSize) &&\n                            in_coord.y >= 0 && in_coord.y < i32(ySize) &&\n                            in_coord.z >= 0 && in_coord.z < i32(zSize)) { //Ensure the sampled point is within 3D dataspace\n                            let xOffset = kx * i32(xStride);\n                            let yOffset = ky * i32(yStride);\n                            let zOffset = kz * i32(zStride);\n                            let newIdx = i32(globalIdx) + xOffset + yOffset + zOffset;\n                            let newVal = f32(inputData[u32(newIdx)]);\n                            if (newVal != newVal){ //This only evaluates if newVal is NaN\n                                continue;\n                            }\n                            let diff: f32 = mean - newVal;\n                            squaredDiffSum += diff*diff;\n                        }\n                    }\n                }\n            }\n\n            let stDev: f32 = sqrt(squaredDiffSum / f32(count));\n\n            outputData[globalIdx] = ").concat(e,"(stDev);\n        }\n    "),CorrelationConvolution:"\n        ".concat(n,"\n        struct Params {\n            xStride: u32,\n            yStride: u32,\n            zStride: u32,\n            xSize: u32,\n            ySize: u32,\n            zSize: u32,\n            workGroups: vec3<u32>,\n            kernelSize: u32,\n            kernelDepth: u32\n        };\n        @group(0) @binding(0) var<storage, read> firstData: array<").concat(e,">;\n        @group(0) @binding(1) var<storage, read> secondData: array<").concat(e,">;\n        @group(0) @binding(2) var<storage, read_write> outputData: array<").concat(e,">;\n        @group(0) @binding(3) var<uniform> params: Params;\n\n        @compute @workgroup_size(4, 4, 4)\n        fn main(@builtin(global_invocation_id) global_id: vec3<u32>) {\n            let zStride = params.zStride;\n            let yStride = params.yStride;\n            let xStride = params.xStride; \n            let xSize = params.xSize;\n            let ySize = params.ySize;\n            let zSize = params.zSize; \n            let workGroups = params.workGroups;\n            let kernelSize = params.kernelSize;\n            let kernelDepth = params.kernelDepth;\n\n            let outX = global_id.x; \n            let outY = global_id.y;\n            let outZ = global_id.z; \n\n            if (outX >= xSize || outY >= ySize || outZ >= zSize) {\n                return;\n            }\n\n            let total_threads_per_slice = workGroups.x * workGroups.y * 16;\n            let globalIdx = global_id.z * total_threads_per_slice + \n                            global_id.y * (workGroups.x * 4) + \n                            global_id.x;\n\n            let xy_radius: i32 = i32(kernelSize/2u);\n            let z_radius: i32 = i32(kernelDepth/2u);\n\n            var xyOffset: i32 = 0; //These offsets are for kernelsizes of 1. I didn't wanna rewrite everything else for that case\n            var zOffset: i32 = 0;\n            if (xy_radius == 0){\n                xyOffset = -1;\n            }\n            if (z_radius == 0){\n                zOffset = -1;\n            }\n\n            var xSum: f32 = 0.0;\n            var xxSum: f32 = 0.0;\n            var ySum: f32 = 0.0;\n            var yySum: f32 = 0.0;\n            var xySum: f32 = 0.0;\n\n            var count: u32 = 0u;\n            for (var kx: i32 = -xy_radius + xyOffset; kx < xy_radius; kx++) {\n                for (var ky: i32 = -xy_radius + xyOffset; ky < xy_radius; ky++) {\n                    for (var kz: i32 = -z_radius + zOffset; kz < z_radius; kz++){\n                        let in_coord = vec3<i32>(global_id) + vec3<i32>(kx, ky, kz);\n                        if (in_coord.x >= 0 && in_coord.x < i32(xSize) &&\n                            in_coord.y >= 0 && in_coord.y < i32(ySize) &&\n                            in_coord.z >= 0 && in_coord.z < i32(zSize)) { //Ensure the sampled point is within 3D dataspace\n                            let xOffset = kx * i32(xStride);\n                            let yOffset = ky * i32(yStride);\n                            let zOffset = kz * i32(zStride);\n                            let newIdx = i32(globalIdx) + xOffset + yOffset + zOffset;\n\n                            let xI = f32(firstData[newIdx]);\n                            let yI = f32(secondData[newIdx]);\n                            if (xI != xI || yI != yI){ //This only evaluates if a value is NaN\n                                continue;\n                            }\n                            xSum += xI;\n                            xxSum += xI * xI;\n                            ySum += yI;\n                            yySum += yI * yI;\n                            xySum += xI * yI;\n                            count ++;\n                        }\n                    }\n                }\n            }\n\n            let N: f32 = f32(count);\n            let meanX = xSum / N;\n            let meanY = ySum / N;\n            let varX = (xxSum / N) - (meanX * meanX);\n            let varY = (yySum / N) - (meanY * meanY);\n            let covXY = (xySum / N) - (meanX * meanY);\n            let sigmaX = sqrt(max(0.0, varX));\n            let sigmaY = sqrt(max(0.0, varY));\n            let epsilon = 1e-6;\n            let denominator = sigmaX * sigmaY + epsilon;\n            let correlation = covXY / denominator;\n\n            outputData[globalIdx] = ").concat(e,"(correlation);\n        }\n    "),CovarianceConvolution:"\n        ".concat(n,"\n        struct Params {\n            xStride: u32,\n            yStride: u32,\n            zStride: u32,\n            xSize: u32,\n            ySize: u32,\n            zSize: u32,\n            workGroups: vec3<u32>,\n            kernelSize: u32,\n            kernelDepth: u32\n        };\n        @group(0) @binding(0) var<storage, read> firstData: array<").concat(e,">;\n        @group(0) @binding(1) var<storage, read> secondData: array<").concat(e,">;\n        @group(0) @binding(2) var<storage, read_write> outputData: array<").concat(e,">;\n        @group(0) @binding(3) var<uniform> params: Params;\n\n        @compute @workgroup_size(4, 4, 4)\n        fn main(@builtin(global_invocation_id) global_id: vec3<u32>) {\n            let zStride = params.zStride;\n            let yStride = params.yStride;\n            let xStride = params.xStride; \n            let xSize = params.xSize;\n            let ySize = params.ySize;\n            let zSize = params.zSize; \n            let workGroups = params.workGroups;\n            let kernelSize = params.kernelSize;\n            let kernelDepth = params.kernelDepth;\n\n            let outX = global_id.x; \n            let outY = global_id.y;\n            let outZ = global_id.z; \n\n            if (outX >= xSize || outY >= ySize || outZ >= zSize) {\n                return;\n            }\n\n            let total_threads_per_slice = workGroups.x * workGroups.y * 16;\n            let globalIdx = global_id.z * total_threads_per_slice + \n                            global_id.y * (workGroups.x * 4) + \n                            global_id.x;\n\n            let xy_radius: i32 = i32(kernelSize/2u);\n            let z_radius: i32 = i32(kernelDepth/2u);\n\n            var xyOffset: i32 = 0; //These offsets are for kernelsizes of 1. I didn't wanna rewrite everything else for that case\n            var zOffset: i32 = 0;\n            if (xy_radius == 0){\n                xyOffset = -1;\n            }\n            if (z_radius == 0){\n                zOffset = -1;\n            }\n\n            var xSum: f32 = 0.0;\n            var ySum: f32 = 0.0;\n            var numSum: f32 = 0.0;\n\n            var count: u32 = 0u;\n            for (var kx: i32 = -xy_radius + xyOffset; kx < xy_radius; kx++) {\n                for (var ky: i32 = -xy_radius + xyOffset; ky < xy_radius; ky++) {\n                    for (var kz: i32 = -z_radius + zOffset; kz < z_radius; kz++){\n                        let in_coord = vec3<i32>(global_id) + vec3<i32>(kx, ky, kz);\n                        if (in_coord.x >= 0 && in_coord.x < i32(xSize) &&\n                            in_coord.y >= 0 && in_coord.y < i32(ySize) &&\n                            in_coord.z >= 0 && in_coord.z < i32(zSize)) { \n                            let xOffset = kx * i32(xStride);\n                            let yOffset = ky * i32(yStride);\n                            let zOffset = kz * i32(zStride);\n                            let newIdx = i32(globalIdx) + xOffset + yOffset + zOffset;\n                            let xI = f32(firstData[newIdx]);\n                            let yI = f32(secondData[newIdx]);\n                            if (xI != xI || yI != yI){ //This only evaluates if a value is NaN\n                                continue;\n                            }\n                            xSum += xI;    \n                            ySum += yI;\n                            count ++;\n                        }\n                    }\n                }\n            }\n\n            let N: f32 = f32(count);\n            let meanX = xSum / N;\n            let meanY = ySum / N;\n            \n            for (var kx: i32 = -xy_radius + xyOffset; kx < xy_radius; kx++) {\n                for (var ky: i32 = -xy_radius + xyOffset; ky < xy_radius; ky++) {\n                    for (var kz: i32 = -z_radius + zOffset; kz < z_radius; kz++){\n                        let in_coord = vec3<i32>(global_id) + vec3<i32>(kx, ky, kz);\n                        if (in_coord.x >= 0 && in_coord.x < i32(xSize) &&\n                            in_coord.y >= 0 && in_coord.y < i32(ySize) &&\n                            in_coord.z >= 0 && in_coord.z < i32(zSize)) { \n                            let xOffset = kx * i32(xStride);\n                            let yOffset = ky * i32(yStride);\n                            let zOffset = kz * i32(zStride);\n                            let newIdx = i32(globalIdx) + xOffset + yOffset + zOffset;\n                            let xI = f32(firstData[newIdx]);\n                            let yI = f32(secondData[newIdx]);\n                            if (xI != xI || yI != yI){ //This only evaluates if a value is NaN\n                                continue;\n                            }\n                            numSum += (xI - meanX) * (yI - meanY);\n                            count ++;\n                        }\n                    }\n                }\n            }\n            outputData[globalIdx] = ").concat(e,"(numSum/(N-1));\n        }\n    "),TwoVarLinearSlopeConvolution:"\n        ".concat(n,"\n        struct Params {\n            xStride: u32,\n            yStride: u32,\n            zStride: u32,\n            xSize: u32,\n            ySize: u32,\n            zSize: u32,\n            workGroups: vec3<u32>,\n            kernelSize: u32,\n            kernelDepth: u32\n        };\n        @group(0) @binding(0) var<storage, read> firstData: array<").concat(e,">;\n        @group(0) @binding(1) var<storage, read> secondData: array<").concat(e,">;\n        @group(0) @binding(2) var<storage, read_write> outputData: array<").concat(e,">;\n        @group(0) @binding(3) var<uniform> params: Params;\n\n        @compute @workgroup_size(4, 4, 4)\n        fn main(@builtin(global_invocation_id) global_id: vec3<u32>) {\n            let zStride = params.zStride;\n            let yStride = params.yStride;\n            let xStride = params.xStride; \n            let xSize = params.xSize;\n            let ySize = params.ySize;\n            let zSize = params.zSize; \n            let workGroups = params.workGroups;\n            let kernelSize = params.kernelSize;\n            let kernelDepth = params.kernelDepth;\n\n            let outX = global_id.x; \n            let outY = global_id.y;\n            let outZ = global_id.z; \n\n            if (outX >= xSize || outY >= ySize || outZ >= zSize) {\n                return;\n            }\n\n            let total_threads_per_slice = workGroups.x * workGroups.y * 16;\n            let globalIdx = global_id.z * total_threads_per_slice + \n                            global_id.y * (workGroups.x * 4) + \n                            global_id.x;\n\n            let xy_radius: i32 = i32(kernelSize/2u);\n            let z_radius: i32 = i32(kernelDepth/2u);\n\n            var xyOffset: i32 = 0; //These offsets are for kernelsizes of 1. I didn't wanna rewrite everything else for that case\n            var zOffset: i32 = 0;\n            if (xy_radius == 0){\n                xyOffset = -1;\n            }\n            if (z_radius == 0){\n                zOffset = -1;\n            }\n\n            var xSum: f32 = 0.0;\n            var ySum: f32 = 0.0;\n\n            var count: u32 = 0u;\n            for (var kx: i32 = -xy_radius + xyOffset; kx < xy_radius; kx++) {\n                for (var ky: i32 = -xy_radius + xyOffset; ky < xy_radius; ky++) {\n                    for (var kz: i32 = -z_radius + zOffset; kz < z_radius; kz++){\n                        let in_coord = vec3<i32>(global_id) + vec3<i32>(kx, ky, kz);\n                        if (in_coord.x >= 0 && in_coord.x < i32(xSize) &&\n                            in_coord.y >= 0 && in_coord.y < i32(ySize) &&\n                            in_coord.z >= 0 && in_coord.z < i32(zSize)) { \n                            let xOffset = kx * i32(xStride);\n                            let yOffset = ky * i32(yStride);\n                            let zOffset = kz * i32(zStride);\n                            let newIdx = i32(globalIdx) + xOffset + yOffset + zOffset;\n                            let xI = f32(firstData[newIdx]);\n                            let yI = f32(secondData[newIdx]);\n                            if (xI != xI || yI != yI){ //This only evaluates if a value is NaN\n                                continue;\n                            }\n                            xSum += xI;    \n                            ySum += yI;\n                            count ++;\n                        }\n                    }\n                }\n            }\n\n\n            let N: f32 = f32(count);\n            let meanX = xSum / N;\n            let meanY = ySum / N;\n            var numSum: f32 = 0;\n            var denomSum: f32 = 0;\n            \n            for (var kx: i32 = -xy_radius + xyOffset; kx < xy_radius; kx++) {\n                for (var ky: i32 = -xy_radius + xyOffset; ky < xy_radius; ky++) {\n                    for (var kz: i32 = -z_radius + zOffset; kz < z_radius; kz++){\n                        let in_coord = vec3<i32>(global_id) + vec3<i32>(kx, ky, kz);\n                        if (in_coord.x >= 0 && in_coord.x < i32(xSize) &&\n                            in_coord.y >= 0 && in_coord.y < i32(ySize) &&\n                            in_coord.z >= 0 && in_coord.z < i32(zSize)) { \n                            let xOffset = kx * i32(xStride);\n                            let yOffset = ky * i32(yStride);\n                            let zOffset = kz * i32(zStride);\n                            let newIdx = i32(globalIdx) + xOffset + yOffset + zOffset;\n                            let xI = f32(firstData[newIdx]);\n                            let yI = f32(secondData[newIdx]);\n                            if (xI != xI || yI != yI){ //This only evaluates if a value is NaN\n                                continue;\n                            }\n                            numSum += (xI - meanX)*(f32(yI) - meanY);\n                            denomSum += (f32(yI) - meanY)*(f32(yI) - meanY);\n                        }\n                    }\n                }\n            }\n            outputData[globalIdx] = ").concat(e,"(numSum/denomSum);\n        }\n    "),MeanConvolution2D:"\n            ".concat(i,"    \n            var sum: f32 = 0;\n            var count: u32 = 0u;\n            for (var kx: i32 = -xy_radius; kx <= xy_radius; kx++) {\n                for (var ky: i32 = -xy_radius; ky <= xy_radius; ky++) {\n                    let in_coord = vec2<i32>(i32(global_id.x), i32(global_id.y)) + vec2<i32>(kx, ky);\n                    if (in_coord.x >= 0 && in_coord.x < i32(xSize) &&\n                        in_coord.y >= 0 && in_coord.y < i32(ySize)) { //Ensure the sampled point is within 3D dataspace\n                        let xOffset = kx * i32(xStride);\n                        let yOffset = ky * i32(yStride);\n                        let newIdx = i32(globalIdx) + xOffset + yOffset;\n                        let newVal = f32(inputData[u32(newIdx)]);\n                        if (newVal != newVal){ //This only evaluates if newVal is NaN\n                            continue;\n                        }\n                        sum += newVal;\n                        count ++;\n                    }\n                }\n            }\n            outputData[globalIdx] = ").concat(e,"(sum / f32(count));\n        }\n    "),MinConvolution2D:"\n        ".concat(i,"   \n            var minVal: f32 = 1e12;\n            for (var kx: i32 = -xy_radius; kx <= xy_radius; kx++) {\n                for (var ky: i32 = -xy_radius; ky <= xy_radius; ky++) {\n                    let in_coord = vec2<i32>(i32(global_id.x), i32(global_id.y)) + vec2<i32>(kx, ky);\n                    if (in_coord.x >= 0 && in_coord.x < i32(xSize) &&\n                        in_coord.y >= 0 && in_coord.y < i32(ySize)) { //Ensure the sampled point is within 3D dataspace\n                        let xOffset = kx * i32(xStride);\n                        let yOffset = ky * i32(yStride);\n                        let newIdx = i32(globalIdx) + xOffset + yOffset;\n                        let newVal = f32(inputData[u32(newIdx)]);\n                        if (newVal != newVal){ //This only evaluates if newVal is NaN\n                            continue;\n                        }\n                        if (newVal < minVal){\n                            minVal = newVal;\n                        }\n                    }\n                }\n            }\n            outputData[globalIdx] = ").concat(e,"(minVal);\n        }\n    "),MaxConvolution2D:"\n        ".concat(i,"  \n            var maxVal: f32 = -1e12;\n            for (var kx: i32 = -xy_radius; kx <= xy_radius; kx++) {\n                for (var ky: i32 = -xy_radius; ky <= xy_radius; ky++) {\n                    let in_coord = vec2<i32>(i32(global_id.x), i32(global_id.y)) + vec2<i32>(kx, ky);\n                    if (in_coord.x >= 0 && in_coord.x < i32(xSize) &&\n                        in_coord.y >= 0 && in_coord.y < i32(ySize)) { //Ensure the sampled point is within 3D dataspace\n                        let xOffset = kx * i32(xStride);\n                        let yOffset = ky * i32(yStride);\n                        let newIdx = i32(globalIdx) + xOffset + yOffset;\n                        let newVal = f32(inputData[u32(newIdx)]);\n                        if (newVal != newVal){ //This only evaluates if newVal is NaN\n                            continue;\n                        }\n                        if (newVal > maxVal){\n                            maxVal = newVal;\n                        }\n                    }\n                }\n            }\n            outputData[globalIdx] = ").concat(e,"(maxVal);\n        }\n    "),StDevConvolution2D:"\n        ".concat(i,"  \n            var sum: f32 = 0.;\n            var count: u32 = 0u;\n            for (var kx: i32 = -xy_radius; kx <= xy_radius; kx++) {\n                for (var ky: i32 = -xy_radius; ky <= xy_radius; ky++) {\n                    let in_coord = vec2<i32>(i32(global_id.x), i32(global_id.y)) + vec2<i32>(kx, ky);\n                    if (in_coord.x >= 0 && in_coord.x < i32(xSize) &&\n                        in_coord.y >= 0 && in_coord.y < i32(ySize)) { //Ensure the sampled point is within 3D dataspace\n                        let xOffset = kx * i32(xStride);\n                        let yOffset = ky * i32(yStride);\n                        let newIdx = i32(globalIdx) + xOffset + yOffset;\n                        let newVal = f32(inputData[u32(newIdx)]);\n                        if (newVal != newVal){ //This only evaluates if newVal is NaN\n                            continue;\n                        }\n                        sum += newVal;\n                        count ++;\n                    }\n                }\n            }\n            \n            let mean: f32 = sum / f32(count);\n\n            var squaredDiffSum: f32 = 0.0;\n\n            for (var kx: i32 = -xy_radius; kx <= xy_radius; kx++) {\n                for (var ky: i32 = -xy_radius; ky <= xy_radius; ky++) {\n                    let in_coord = vec2<i32>(i32(global_id.x), i32(global_id.y)) + vec2<i32>(kx, ky);\n                    if (in_coord.x >= 0 && in_coord.x < i32(xSize) &&\n                        in_coord.y >= 0 && in_coord.y < i32(ySize)) { //Ensure the sampled point is within 3D dataspace\n                        let xOffset = kx * i32(xStride);\n                        let yOffset = ky * i32(yStride);\n                        let newIdx = i32(globalIdx) + xOffset + yOffset;\n                        let newVal = f32(inputData[u32(newIdx)]);\n                        if (newVal != newVal){ //This only evaluates if newVal is NaN\n                            continue;\n                        }\n                        let diff: f32 = mean - newVal;\n                        squaredDiffSum += diff*diff;\n                    }\n                }\n            }\n            let stDev: f32 = sqrt(squaredDiffSum / f32(count));\n\n            outputData[globalIdx] = ").concat(e,"(stDev);\n        }\n    "),CUMSUM3D:"\n        ".concat(n,"\n        struct Params {\n            xStride: u32,\n            yStride: u32,\n            zStride: u32,\n            xSize: u32,\n            ySize: u32,\n            zSize: u32,\n            reduceDim: u32,\n            reverse: u32,\n            workGroups: vec3<u32>,\n        };\n        @group(0) @binding(0) var<storage, read> inputData: array<").concat(e,">;\n        @group(0) @binding(1) var<storage, read_write> outputData: array<f32>;\n        @group(0) @binding(2) var<uniform> params: Params;\n\n        @compute @workgroup_size(4, 4, 4)\n        fn main(@builtin(global_invocation_id) global_id: vec3<u32>) {\n            let zStride = params.zStride;\n            let yStride = params.yStride;\n            let xStride = params.xStride; \n            let xSize = params.xSize;\n            let ySize = params.ySize;\n            let zSize = params.zSize; \n            let reverse = params.reverse;\n            let workGroups = params.workGroups;\n            let reduceDim = params.reduceDim;\n\n            let outX = global_id.x; \n            let outY = global_id.y;\n            let outZ = global_id.z; \n\n            if (outX >= xSize || outY >= ySize || outZ >= zSize) {\n                return;\n            }\n            let totalSize: u32 = xSize * ySize * zSize;\n            var baseIdx = outZ * zStride + outY * yStride + outX * xStride;\n            var accum: f32 = 0;\n\n            // Iterate along the dimension we're averaging\n            if (reduceDim == 0u) { // CUMSUM along Z\n                if (reverse == u32(1)){\n                    baseIdx = (zSize - outZ - 1) * zStride + outY * yStride + outX * xStride;\n                }\n                for (var z: u32 = 0u; z < outZ; z++) {\n                    var newZ: u32 = z;\n                    if (reverse == u32(1)){\n                        newZ = zSize - z - 1;\n                    }\n                    let idx = newZ * zStride + outY * yStride + outX * xStride;\n                    accum += f32(inputData[idx]);\n                }\n\n            } else if (reduceDim == 1u) { // CUMSUM along Y\n                if (reverse == u32(1)){\n                    baseIdx = outZ * zStride + (ySize - outY - 1)* yStride + outX * xStride;\n                }\n                for (var y: u32 = 0u; y < outY; y++) {\n                    var newY: u32 = y;\n                    if (reverse == u32(1)){\n                        newY = ySize - y - 1;\n                    }\n                    let idx = outZ * zStride + newY * yStride + outX * xStride;\n                    accum += f32(inputData[idx]);\n                }\n            } else { // CUMSUM along X\n                if (reverse == u32(1)){\n                    baseIdx = outZ * zStride + outY* yStride + (xSize - outX - 1) * xStride;\n                }\n                for (var x: u32 = 0u; x < outX; x++) {\n                    var newX: u32 = x;\n                    if (reverse == u32(1)){\n                        newX = xSize - x - 1;\n                    }\n                    let idx = outZ * zStride + outY * yStride + newX * xStride;\n                    accum += f32(inputData[idx]);\n                }\n            }\n                outputData[baseIdx] = accum;\n        }\n    ")}},W={Mean:"MeanReduction",Min:"MinReduction",Max:"MaxReduction",StDev:"StDevReduction",LinearSlope:"LinearSlopeReduction",Mean3D:"MeanConvolution",Min3D:"MinConvolution",Max3D:"MaxConvolution",StDev3D:"StDevConvolution",Mean2D:"MeanConvolution2D",Min2D:"MinConvolution2D",Max2D:"MaxConvolution2D",StDev2D:"StDevConvolution2D",Correlation2D:"CorrelationReduction",Correlation3D:"CorrelationConvolution",TwoVarLinearSlope2D:"TwoVarLinearSlopeReduction",TwoVarLinearSlope3D:"TwoVarLinearSlopeConvolution",Covariance2D:"CovarianceReduction",Covariance3D:"CovarianceConvolution",CUMSUM3D:"CUMSUM3D"},Z=async()=>{var e;let n=await (null==(e=navigator.gpu)?void 0:e.requestAdapter()),t=null==n?void 0:n.limits.maxBufferSize,r=null==n?void 0:n.limits.maxStorageBufferBindingSize,i=!!n&&n.features.has("shader-f16"),a=i?await (null==n?void 0:n.requestDevice({requiredFeatures:["shader-f16"],requiredLimits:{maxBufferSize:t,maxStorageBufferBindingSize:r}})):await (null==n?void 0:n.requestDevice({requiredLimits:{maxBufferSize:t,maxStorageBufferBindingSize:r}}));return a||Error("need a browser that supports WebGPU"),{device:a,hasF16:i}};async function q(e,n,t,r){let{device:i,hasF16:a}=await Z();if(!i)return void Error("need a browser that supports WebGPU");let{strides:o,shape:l}=n,[s,u,c]=o,d=l.filter((e,n)=>n!=t),f=l[t],m=d[0]*d[1],p=d.map(e=>Math.ceil(e/16)),x=G(a?"f16":"f32")[W[r]],v=i.createShaderModule({label:"reduction compute module",code:x}),h=i.createComputePipeline({label:"reduction compute pipeline",layout:"auto",compute:{module:v}}),S=(0,X.Wu)(x),g=(0,X.FE)(S.uniforms.params);g.set({zStride:s,yStride:u,xStride:c,xSize:d[1],ySize:d[0],reduceDim:t,dimLength:f});let y=i.createBuffer({label:"Input Buffer",size:e.byteLength*(a?1:2),usage:GPUBufferUsage.STORAGE|GPUBufferUsage.COPY_DST}),z=i.createBuffer({label:"Output Buffer",size:m*(a?2:4),usage:GPUBufferUsage.STORAGE|GPUBufferUsage.COPY_SRC}),w=i.createBuffer({size:g.arrayBuffer.byteLength,usage:GPUBufferUsage.UNIFORM|GPUBufferUsage.COPY_DST}),b=i.createBuffer({label:"Output Buffer",size:m*(a?2:4),usage:GPUBufferUsage.COPY_DST|GPUBufferUsage.MAP_READ});i.queue.writeBuffer(y,0,a?e:new Float32Array(e)),i.queue.writeBuffer(w,0,g.arrayBuffer);let I=i.createBindGroup({layout:h.getBindGroupLayout(0),entries:[{binding:0,resource:{buffer:y}},{binding:1,resource:{buffer:z}},{binding:2,resource:{buffer:w}}]}),_=i.createCommandEncoder({label:"reduction encoder"}),C=_.beginComputePass({label:"reduction compute pass"});C.setPipeline(h),C.setBindGroup(0,I),C.dispatchWorkgroups(p[0],p[1]),C.end(),_.copyBufferToBuffer(z,0,b,0,m*(a?2:4)),i.queue.submit([_.finish()]),await b.mapAsync(GPUMapMode.READ);let D=b.getMappedRange(),P=new Float16Array(a?D.slice():new Float32Array(D.slice()));return b.unmap(),P}async function H(e,n,t,r){let{device:i,hasF16:a}=await Z();if(!i)return void Error("need a browser that supports WebGPU");let{kernelDepth:o,kernelSize:l}=r,{strides:s,shape:u}=n,c=u[0]*u[1]*u[2],[d,f,m]=s,p=u.map(e=>Math.ceil(e/4)),x=G(a?"f16":"f32")[W[t]],v=i.createShaderModule({label:"convolution compute module",code:x}),h=i.createComputePipeline({label:"convolution compute pipeline",layout:"auto",compute:{module:v}}),S=(0,X.Wu)(x),g=(0,X.FE)(S.uniforms.params);g.set({xStride:m,yStride:f,zStride:d,xSize:u[2],ySize:u[1],zSize:u[0],workGroups:[p[2],p[1],p[0]],kernelDepth:o,kernelSize:l});let y=i.createBuffer({label:"Input Buffer",size:e.byteLength*(a?1:2),usage:GPUBufferUsage.STORAGE|GPUBufferUsage.COPY_DST}),z=i.createBuffer({label:"Output Buffer",size:c*(a?2:4),usage:GPUBufferUsage.STORAGE|GPUBufferUsage.COPY_SRC}),w=i.createBuffer({label:"Uniform Buffer",size:g.arrayBuffer.byteLength,usage:GPUBufferUsage.UNIFORM|GPUBufferUsage.COPY_DST}),b=i.createBuffer({label:"Read Buffer",size:c*(a?2:4),usage:GPUBufferUsage.COPY_DST|GPUBufferUsage.MAP_READ});i.queue.writeBuffer(y,0,a?e:new Float32Array(e)),i.queue.writeBuffer(w,0,g.arrayBuffer);let I=i.createBindGroup({layout:h.getBindGroupLayout(0),entries:[{binding:0,resource:{buffer:y}},{binding:1,resource:{buffer:z}},{binding:2,resource:{buffer:w}}]}),_=i.createCommandEncoder({label:"convolution encoder"}),C=_.beginComputePass({label:"convolution compute pass"});C.setPipeline(h),C.setBindGroup(0,I),C.dispatchWorkgroups(p[2],p[1],p[0]),C.end(),_.copyBufferToBuffer(z,0,b,0,c*(a?2:4)),i.queue.submit([_.finish()]),await b.mapAsync(GPUMapMode.READ);let D=b.getMappedRange(),P=new Float16Array(a?D.slice():new Float32Array(D.slice()));return b.unmap(),P}async function Q(e,n,t,r,i){let{device:a,hasF16:o}=await Z();if(!a)return void Error("need a browser that supports WebGPU");let{strides:l,shape:s}=t,[u,c,d]=l,f=s.filter((e,n)=>n!=r),m=s[r],p=f[0]*f[1],x=f.map(e=>Math.ceil(e/16)),v=G(o?"f16":"f32")[W[i]],h=a.createShaderModule({label:"Multivariate2D compute module",code:v}),S=a.createComputePipeline({label:"Multivariate2D compute pipeline",layout:"auto",compute:{module:h}}),g=(0,X.Wu)(v),y=(0,X.FE)(g.uniforms.params);y.set({zStride:u,yStride:c,xStride:d,xSize:f[1],ySize:f[0],reduceDim:r,dimLength:m});let z=a.createBuffer({label:"First Input Buffer",size:e.byteLength*(o?1:2),usage:GPUBufferUsage.STORAGE|GPUBufferUsage.COPY_DST}),w=a.createBuffer({label:"Second Input Buffer",size:n.byteLength*(o?1:2),usage:GPUBufferUsage.STORAGE|GPUBufferUsage.COPY_DST}),b=a.createBuffer({label:"Output Buffer",size:p*(o?2:4),usage:GPUBufferUsage.STORAGE|GPUBufferUsage.COPY_SRC}),I=a.createBuffer({size:y.arrayBuffer.byteLength,usage:GPUBufferUsage.UNIFORM|GPUBufferUsage.COPY_DST}),_=a.createBuffer({label:"Output Buffer",size:p*(o?2:4),usage:GPUBufferUsage.COPY_DST|GPUBufferUsage.MAP_READ});a.queue.writeBuffer(z,0,o?e:new Float32Array(e)),a.queue.writeBuffer(w,0,o?n:new Float32Array(n)),a.queue.writeBuffer(I,0,y.arrayBuffer);let C=a.createBindGroup({layout:S.getBindGroupLayout(0),entries:[{binding:0,resource:{buffer:z}},{binding:1,resource:{buffer:w}},{binding:2,resource:{buffer:b}},{binding:3,resource:{buffer:I}}]}),D=a.createCommandEncoder({label:"Multivariate2D encoder"}),P=D.beginComputePass({label:"Multivariate2D compute pass"});P.setPipeline(S),P.setBindGroup(0,C),P.dispatchWorkgroups(x[0],x[1]),P.end(),D.copyBufferToBuffer(b,0,_,0,p*(o?2:4)),a.queue.submit([D.finish()]),await _.mapAsync(GPUMapMode.READ);let M=_.getMappedRange(),k=new Float16Array(o?M.slice():new Float32Array(M.slice()));return _.unmap(),k}async function K(e,n,t,r,i){let{device:a,hasF16:o}=await Z();if(!a)return void Error("need a browser that supports WebGPU");let{kernelDepth:l,kernelSize:s}=r,{strides:u,shape:c}=t,[d,f,m]=u,p=c[0]*c[1]*c[2],x=c.map(e=>Math.ceil(e/4)),v=G(o?"f16":"f32")[W[i]],h=a.createShaderModule({label:"Multivariate3D compute module",code:v}),S=a.createComputePipeline({label:"Multivariate3D compute pipeline",layout:"auto",compute:{module:h}}),g=(0,X.Wu)(v),y=(0,X.FE)(g.uniforms.params);y.set({xStride:m,yStride:f,zStride:d,xSize:c[2],ySize:c[1],zSize:c[0],workGroups:[x[2],x[1],x[0]],kernelDepth:l,kernelSize:s});let z=a.createBuffer({label:"First Input Buffer",size:e.byteLength*(o?1:2),usage:GPUBufferUsage.STORAGE|GPUBufferUsage.COPY_DST}),w=a.createBuffer({label:"Second Input Buffer",size:n.byteLength*(o?1:2),usage:GPUBufferUsage.STORAGE|GPUBufferUsage.COPY_DST}),b=a.createBuffer({label:"Output Buffer",size:p*(o?2:4),usage:GPUBufferUsage.STORAGE|GPUBufferUsage.COPY_SRC}),I=a.createBuffer({size:y.arrayBuffer.byteLength,usage:GPUBufferUsage.UNIFORM|GPUBufferUsage.COPY_DST}),_=a.createBuffer({label:"Read Buffer",size:p*(o?2:4),usage:GPUBufferUsage.COPY_DST|GPUBufferUsage.MAP_READ});a.queue.writeBuffer(z,0,o?e:new Float32Array(e)),a.queue.writeBuffer(w,0,o?n:new Float32Array(n)),a.queue.writeBuffer(I,0,y.arrayBuffer);let C=a.createBindGroup({layout:S.getBindGroupLayout(0),entries:[{binding:0,resource:{buffer:z}},{binding:1,resource:{buffer:w}},{binding:2,resource:{buffer:b}},{binding:3,resource:{buffer:I}}]}),D=a.createCommandEncoder({label:"Multivariate3D encoder"}),P=D.beginComputePass({label:"Multivariate3D compute pass"});P.setPipeline(S),P.setBindGroup(0,C),P.dispatchWorkgroups(x[2],x[1],x[0]),P.end(),D.copyBufferToBuffer(b,0,_,0,p*(o?2:4)),a.queue.submit([D.finish()]),await _.mapAsync(GPUMapMode.READ);let M=_.getMappedRange(),k=new Float16Array(o?M.slice():new Float32Array(M.slice()));return _.unmap(),k}async function J(e,n,t,r){let{device:i,hasF16:a}=await Z();if(!i)return void Error("need a browser that supports WebGPU");let{strides:o,shape:l}=n,s=l[0]*l[1]*l[2],[u,c,d]=o,f=l.map(e=>Math.ceil(e/4)),m=G(a?"f16":"f32").CUMSUM3D,p=i.createShaderModule({label:"cumsum3d compute module",code:m}),x=i.createComputePipeline({label:"cumsum3d compute pipeline",layout:"auto",compute:{module:p}}),v=(0,X.Wu)(m),h=(0,X.FE)(v.uniforms.params);h.set({xStride:d,yStride:c,zStride:u,xSize:l[2],ySize:l[1],zSize:l[0],reduceDim:t,reverse:r,workGroups:[f[2],f[1],f[0]]});let S=i.createBuffer({label:"Input Buffer",size:e.byteLength*(a?1:2),usage:GPUBufferUsage.STORAGE|GPUBufferUsage.COPY_DST}),g=i.createBuffer({label:"Output Buffer",size:4*s,usage:GPUBufferUsage.STORAGE|GPUBufferUsage.COPY_SRC}),y=i.createBuffer({label:"Uniform Buffer",size:h.arrayBuffer.byteLength,usage:GPUBufferUsage.UNIFORM|GPUBufferUsage.COPY_DST}),z=i.createBuffer({label:"Read Buffer",size:4*s,usage:GPUBufferUsage.COPY_DST|GPUBufferUsage.MAP_READ});i.queue.writeBuffer(S,0,a?e:new Float32Array(e)),i.queue.writeBuffer(y,0,h.arrayBuffer);let w=i.createBindGroup({layout:x.getBindGroupLayout(0),entries:[{binding:0,resource:{buffer:S}},{binding:1,resource:{buffer:g}},{binding:2,resource:{buffer:y}}]}),b=i.createCommandEncoder({label:"cumsum3d encoder"}),I=b.beginComputePass({label:"cumsum3d compute pass"});I.setPipeline(x),I.setBindGroup(0,w),I.dispatchWorkgroups(f[2],f[1],f[0]),I.end(),b.copyBufferToBuffer(g,0,z,0,4*s),i.queue.submit([b.finish()]),await z.mapAsync(GPUMapMode.READ);let _=new Float32Array(z.getMappedRange().slice());return z.unmap(),_}async function $(e,n,t,r){let{device:i,hasF16:a}=await Z();if(!i)return void Error("need a browser that supports WebGPU");let{strides:o,shape:l}=n,s=l[0]*l[1],[u,c]=[o[0],o[1]],d=[Math.ceil(l[1]/16),Math.ceil(l[0]/16)],f=G(a?"f16":"f32")[W[t]],m=i.createShaderModule({label:"convolution2d compute module",code:f}),p=i.createComputePipeline({label:"convolution2d compute pipeline",layout:"auto",compute:{module:m}}),x=(0,X.Wu)(f),v=(0,X.FE)(x.uniforms.params);v.set({xStride:c,yStride:u,xSize:l[1],ySize:l[0],kernelSize:r});let h=i.createBuffer({label:"Input Buffer",size:e.byteLength*(a?1:2),usage:GPUBufferUsage.STORAGE|GPUBufferUsage.COPY_DST}),S=i.createBuffer({label:"Output Buffer",size:s*(a?2:4),usage:GPUBufferUsage.STORAGE|GPUBufferUsage.COPY_SRC}),g=i.createBuffer({label:"Uniform Buffer",size:v.arrayBuffer.byteLength,usage:GPUBufferUsage.UNIFORM|GPUBufferUsage.COPY_DST}),y=i.createBuffer({label:"Read Buffer",size:s*(a?2:4),usage:GPUBufferUsage.COPY_DST|GPUBufferUsage.MAP_READ});i.queue.writeBuffer(h,0,a?e:new Float32Array(e)),i.queue.writeBuffer(g,0,v.arrayBuffer);let z=i.createBindGroup({layout:p.getBindGroupLayout(0),entries:[{binding:0,resource:{buffer:h}},{binding:1,resource:{buffer:S}},{binding:2,resource:{buffer:g}}]}),w=i.createCommandEncoder({label:"convolution2d encoder"}),b=w.beginComputePass({label:"convolution2d compute pass"});b.setPipeline(p),b.setBindGroup(0,z),b.dispatchWorkgroups(d[0],d[1],1),b.end(),w.copyBufferToBuffer(S,0,y,0,s*(a?2:4)),i.queue.submit([w.finish()]),await y.mapAsync(GPUMapMode.READ);let I=y.getMappedRange(),_=new Float16Array(a?I.slice():new Float32Array(I.slice()));return y.unmap(),_}let ee=e=>{let{setTexture:n,ZarrDS:t}=e,{strides:r,dataShape:i,valueScales:a,isFlat:o,setIsFlat:s,setStatus:u,setValueScales:f}=(0,c.on)((0,d.k)(e=>({strides:e.strides,dataShape:e.dataShape,valueScales:e.valueScales,isFlat:e.isFlat,setIsFlat:e.setIsFlat,setStatus:e.setStatus,setValueScales:e.setValueScales}))),m=(0,c.Ws)(e=>e.setPlotType),{axis:x,execute:v,operation:h,useTwo:S,variable2:g,valueScalesOrig:y,kernelOperation:z,kernelSize:w,kernelDepth:b,reverseDirection:I,analysisStore:_,analysisMode:C,analysisArray:D,analysisDim:P,setValueScalesOrig:M,setAnalysisArray:k,setAnalysisMode:T,setOperation:O}=(0,c.r2)((0,d.k)(e=>({axis:e.axis,execute:e.execute,operation:e.operation,useTwo:e.useTwo,variable2:e.variable2,valueScalesOrig:e.valueScalesOrig,kernelOperation:e.kernelOperation,kernelSize:e.kernelSize,kernelDepth:e.kernelDepth,reverseDirection:e.reverseDirection,analysisStore:e.analysisStore,analysisMode:e.analysisMode,analysisArray:e.analysisArray,analysisDim:e.analysisDim,setValueScalesOrig:e.setValueScalesOrig,setAnalysisArray:e.setAnalysisArray,setAnalysisMode:e.setAnalysisMode,setOperation:e.setOperation}))),{zSlice:B,ySlice:A,xSlice:j}=(0,c.Ws)((0,d.k)(e=>({zSlice:e.zSlice,ySlice:e.ySlice,xSlice:e.xSlice})));return(0,l.useEffect)(()=>{let e=(0,p.Td)(_);h&&!(e.length<=1)&&(async()=>{let l,c,d;u("Computing...");let v="Convolution"==h?z:h,_=!o,O=null;if(S){u("Fetching second variable...");let e=await t.GetArray(g,{zSlice:B,ySlice:A,xSlice:j});if(O=null==e?void 0:e.data,u("Computing..."),!O){console.error("Failed to fetch data for the second variable."),u(null);return}}let U=C?D:e,N={shape:i,strides:r},E={kernelDepth:b,kernelSize:w};switch(v){case"Mean":case"Min":case"Max":case"StDev":case"LinearSlope":l=await q(U,N,x,v),_=!1;break;case"Mean3D":case"Min3D":case"Max3D":case"StDev3D":l=await H(U,N,v,E),_=!0;break;case"Mean2D":case"Min2D":case"Max2D":case"StDev2D":let V=i.length>2?i.filter((e,n)=>n!==P):i,L=r.length>2?[V[1],1]:r;l=await $(U,{shape:V,strides:L},v,w),_=!1;break;case"Correlation2D":case"TwoVarLinearSlope2D":case"Covariance2D":l=await Q(U,O,N,x,v),_=!1;break;case"Correlation3D":case"TwoVarLinearSlope3D":case"Covariance3D":l=await K(U,O,N,E,v),_=!0;break;case"CUMSUM3D":l=await J(U,N,x,I),_=!0;break;default:console.warn("Unknown operation: ".concat(v)),u(null);return}if(!l)return u(null);let R=["StDev","LinearSlope","Covariance","CUMSUM3D"].some(e=>v.includes(e)),F=v.includes("Correlation");R?(y||M(a),[c,d]=(0,p.Qt)(l)):F?(y||M(a),[c,d]=[-1,1]):{minVal:c,maxVal:d}=a,f({minVal:c,maxVal:d});let X=i.length>2?i.filter((e,n)=>n!==x):i,G=new Uint8Array(l.map(e=>{let n=(e-c)/(d-c);return isNaN(n)?255:254*n})),W=(0,Y.qw)(_?i:X,G);k(l),W&&n(W),s(!_),m(_?"volume":"flat"),T(!0),u(null)})()},[v]),null};var en=t(638),et=t(5717);let er=function(e,n,t,r,i){let a=arguments.length>5&&void 0!==arguments[5]&&arguments[5],{bgColor:o,textColor:l}=i,{doubleSize:s,includeBackground:u,mainTitle:d,cbarLabel:f,cbarLoc:m,cbarNum:p,includeColorbar:x}=c.qi.getState(),{valueScales:v,variable:h,metadata:S}=c.on.getState(),g=e.getContext("2d");if(!g)return;g.imageSmoothingEnabled=!0,g.imageSmoothingQuality="high",u?(g.fillStyle=o,g.fillRect(0,0,t,r)):g.clearRect(0,0,t,r),g.drawImage(n.domElement,0,0,t,r);let y=s?52:26,z=s?Math.min(1024,.8*t):Math.min(512,.8*t),w=s?48:24,b=Math.round(t/2-z/2),I="top"===m?s?140:70:s?r-140:r-70,_="right"===m||"left"===m;if(x){let e=document.getElementById("colorbar-canvas");if(e instanceof HTMLCanvasElement)if(_){let n=z;z=w,I=Math.round(r/2-(w=n)/2),b="right"===m?s?t-140:t-70:s?140:70,g.save();let i=b+z/2,a=I+w/2;g.translate(i,a),g.rotate(-Math.PI/2);let o=s?1024:512,l=s?48:24;g.drawImage(e,-o/2,-l/2,o,l),g.restore()}else g.drawImage(e,b,I,z,w)}if(!a&&(g.fillStyle=l,g.font="".concat(s?72:36,'px "Segoe UI"'),g.textBaseline="middle",g.fillText(null!=d?d:h,s?40:20,s?100:50),g.fillStyle="#888888",g.font="".concat(s?40:20,'px "Segoe UI", serif '),g.textAlign="left",g.textBaseline="bottom",g.fillText("browzarr.io",s?20:10,s?r-20:r-10),x)){g.font="".concat(s?36:18,'px "Segoe UI"');let e=v.maxVal-v.minVal,n=1/(p-1),i=_?1/(p-1)*w:1/(p-1)*z;if(_){let a=z;z=w,I=Math.round(r/2-(w=a)/2),b="right"===m?s?t-140:t-70:s?140:70,g.textBaseline="middle",g.textAlign="left"==m?"left":"right";for(let t=0;t<p;t++)"left"==m?g.fillText(String((v.minVal+t*n*e).toFixed(2)),b+z+6,I+w-t*i):g.fillText(String((v.minVal+t*n*e).toFixed(2)),b-6,I+w-t*i)}else{g.textBaseline="top",g.textAlign="center";for(let t=0;t<p;t++)g.fillText(String((v.minVal+t*n*e).toFixed(2)),b+t*i,I+w+6)}g.fillStyle=l,g.font="".concat(y,'px "Segoe UI" bold'),g.textAlign="center",g.fillText(null!=f?f:null==S?void 0:S.units,b+z/2,I-y-4)}};async function ei(e,n,t,r){let{doubleSize:i,mainTitle:a,cbarLabel:o,cbarLoc:l,cbarNum:s,includeColorbar:u}=c.qi.getState(),{valueScales:d,variable:f,metadata:m}=c.on.getState(),p=document.createElement("canvas");p.width=4*e,p.height=4*n;let x=p.getContext("2d");if(!x)return;x.scale(4,4);let v=i?52:26,h=i?Math.min(1024,.8*e):Math.min(512,.8*e),S=i?48:24,g=Math.round(e/2-h/2),y="top"===l?i?140:70:i?n-140:n-70,z="right"===l||"left"===l;if(x.fillStyle=t,x.font="".concat(i?72:36,'px "Segoe UI"'),x.textBaseline="middle",x.textAlign="left",x.fillText(null!=a?a:f,i?40:20,i?100:50),x.fillStyle="#888888",x.font="".concat(i?40:20,'px "Segoe UI", serif '),x.textBaseline="bottom",x.fillText("browzarr.io",i?20:10,i?n-20:n-10),u){x.font="".concat(i?36:18,'px "Segoe UI"'),x.fillStyle=t;let r=d.maxVal-d.minVal,a=1/(s-1),u=z?1/(s-1)*S:1/(s-1)*h;if(z){let t=h;h=S,y=Math.round(n/2-(S=t)/2),g="right"===l?i?e-140:e-70:i?140:70,x.textBaseline="middle",x.textAlign="left"==l?"left":"right";for(let e=0;e<s;e++)"left"==l?x.fillText(String((d.minVal+e*a*r).toFixed(2)),g+h+6,y+S-e*u):x.fillText(String((d.minVal+e*a*r).toFixed(2)),g-6,y+S-e*u)}else{x.textBaseline="top",x.textAlign="center";for(let e=0;e<s;e++)x.fillText(String((d.minVal+e*a*r).toFixed(2)),g+e*u,y+S+6)}x.fillStyle=t,x.font="".concat(v,'px "Segoe UI" bold'),x.textAlign="center",x.fillText(null!=o?o:null==m?void 0:m.units,g+h/2,y-v-4)}let w=await new Promise(e=>{p.toBlob(e,"image/png")});if(w){let e=await w.arrayBuffer();await r.writeFile("textOverlay.png",new Uint8Array(e))}}let ea=e=>{let{show:n}=e,{exportImg:t,enableExport:a,animate:o,frames:s,frameRate:u,useTime:m,timeRate:p,orbit:x,loopTime:v,animViz:h,initialState:S,finalState:g,preview:z,useCustomRes:w,customRes:b,doubleSize:I,setHideAxis:_,setHideAxisControls:C}=(0,c.qi)((0,d.k)(e=>({exportImg:e.exportImg,enableExport:e.enableExport,animate:e.animate,frames:e.frames,frameRate:e.frameRate,useTime:e.useTime,timeRate:e.timeRate,orbit:e.orbit,loopTime:e.loopTime,animViz:e.animViz,initialState:e.initialState,finalState:e.finalState,preview:e.preview,useCustomRes:e.useCustomRes,customRes:e.customRes,doubleSize:e.doubleSize,setHideAxis:e.setHideAxis,setHideAxisControls:e.setHideAxisControls}))),{setAnimProg:D,setQuality:P}=c.Ws.getState(),{setStatus:M,setProgress:k}=c.on.getState(),{dataShape:T}=(0,c.on)((0,d.k)(e=>({dataShape:e.dataShape}))),O=T[T.length-3],{gl:B,scene:A,camera:j,invalidate:U}=(0,f.C)(),N=(0,y.$m)("--text-plot"),E=(0,y.$m)("--background"),V=(0,l.useRef)(null),L=(0,l.useRef)(new et.m);return(0,l.useEffect)(()=>{if(!n||!a)return;let e=c.Ws.getState().quality;P(z?50:1e3);let t=B.domElement.width,r=B.domElement.height,l=w?b[0]:I?2*t:t,d=w?b[1]:I?2*r:r;l-=l%2,d-=d%2,V.current||(V.current=document.createElement("canvas")),V.current.width=l,V.current.height=d;let f=B.getSize(new i.I9Y),y={};function T(){let e=arguments.length>0&&void 0!==arguments[0]&&arguments[0];if(j instanceof i.ubm)e&&(y={aspect:j.aspect}),j.aspect=l/d;else if(j instanceof i.qUd){e&&(y={left:j.left,right:j.right,top:j.top,bottom:j.bottom});let n=l/d;if(n>(j.right-j.left)/(j.top-j.bottom)){let e=(j.top-j.bottom)*n,t=(j.left+j.right)/2;j.left=t-e/2,j.right=t+e/2}else{let e=(j.right-j.left)/n,t=(j.top+j.bottom)/2;j.top=t+e/2,j.bottom=t-e/2}}B.setSize(l,d),j.updateProjectionMatrix(),U()}T(!0),o?(async function(){M("Loading Module");let e=L.current;e.loaded||await e.load(),e.on("progress",e=>{let{progress:n,time:t}=e;k(Math.round(100*n))}),M("Rendering Frames");let n=p/u,t=1/O,r={x:j.position.x,y:j.position.y,z:j.position.z},i=Math.sqrt(r.x**2+r.z**2),a=Math.atan2(r.x,r.z);for(let r=0;r<s;r++){if(x){let e=a+r/(s+1)*Math.PI*2;j.position.x=i*Math.sin(e),j.position.z=i*Math.cos(e),j.lookAt(0,0,0),j.updateProjectionMatrix(),w||I||U()}if(m){let e=t*Math.floor(r*n);D(e=v?e-Math.floor(e):Math.min(e,1))}if(h&&S&&g){let e={},n=r/s;Object.keys(S).forEach(t=>{let r=S[t],i=g[t];if("number"==typeof r&&"number"==typeof i)e[t]=(0,en.Cc)(r,i,n);else if(r.length){e[t]=[];for(let a=0;a<r.length;a++)e[t][a]=(0,en.Cc)(r[a],i[a],n)}else(null==r?void 0:r.lerp)&&"function"==typeof r.lerp?e[t]=r.clone().lerp(i,n):e[t]=i}),c.Ws.setState(e)}(w||I)&&T(),B.render(A,j),er(V.current,B,l,d,{bgColor:E,textColor:N},!0);let o=await new Promise(e=>{var n;null==(n=V.current)||n.toBlob(e,"image/png")});if(o){let n=await o.arrayBuffer();await e.writeFile("frame".concat(r.toString().padStart(4,"0"),".png"),new Uint8Array(n))}}M("Building Animation"),await ei(l,d,N,e),1===await e.exec(["-framerate","".concat(u),"-i","frame%04d.png","-i","textOverlay.png","-filter_complex","[1:v]scale=".concat(l,":").concat(d,"[overlay];[0:v][overlay]overlay=0:0"),"-c:v","libx264","-pix_fmt","yuv444p","-preset","".concat(z?"ultrafast":"slow"),"-crf","".concat(z?28:16),"-tune","stillimage","-profile:v","high444","output.mp4"])&&M(null),M("Fetching Animation");let o=await e.readFile("output.mp4");M(null),k(0);let f=new Blob([o],{type:"video/mp4"}),y=URL.createObjectURL(f),b=document.createElement("a");b.download="browzarr-animation.mp4",b.href=y,b.click(),URL.revokeObjectURL(y);for(let n=0;n<s;n++)await e.deleteFile("frame".concat(n.toString().padStart(4,"0"),".png"));await e.deleteFile("output.mp4")})().then(()=>{_(!1),C(!1),(w||I)&&(j instanceof i.ubm?j.aspect=y.aspect:j instanceof i.qUd&&(j.left=y.left,j.right=y.right,j.top=y.top,j.bottom=y.bottom),B.setSize(f.x,f.y),j.updateProjectionMatrix(),U()),P(e)}):(B.render(A,j),er(V.current,B,l,d,{bgColor:E,textColor:N}),V.current.toBlob(e=>{if(!e)return;let n=URL.createObjectURL(e),t=document.createElement("a");t.download="browzarr-plot.png",t.href=n,t.click(),URL.revokeObjectURL(n)},"image/png"),_(!1),C(!1),(w||I)&&(j instanceof i.ubm?j.aspect=y.aspect:j instanceof i.qUd&&(j.left=y.left,j.right=y.right,j.top=y.top,j.bottom=y.bottom),B.setSize(f.x,f.y),j.updateProjectionMatrix(),U()),P(e))},[t]),(0,r.jsx)(r.Fragment,{})},eo=()=>{let{selectTS:e}=(0,c.Ws)((0,d.k)(e=>({selectTS:e.selectTS})));return(0,r.jsx)(r.Fragment,{children:e&&(0,r.jsx)("div",{className:"transect-notice",children:"Transect Select Mode"})})},el=e=>{let{isFlat:n}=e,{resetCamera:t,useOrtho:a,displaceSurface:o}=(0,c.Ws)((0,d.k)(e=>({resetCamera:e.resetCamera,useOrtho:e.useOrtho,displaceSurface:e.displaceSurface}))),s=(0,l.useRef)(null),u=(0,l.useRef)(!1),{set:m,camera:p,size:x}=(0,f.C)();return(0,l.useEffect)(()=>{if(!u.current){u.current=!0;return}if(s.current){let e,t=s.current,r=performance.now(),o=t.object.position.clone(),l=n?new i.Pq0(0,0,5):t.position0.clone(),u=t.target.clone(),c=t.target0.clone(),d=t.object.zoom,m=s=>{(0,f.m)();let p=Math.min((s-r)/1e3,1);t.object.position.lerpVectors(o,l,p),t.target.lerpVectors(u,c,p),n&&a&&(t.object.zoom=i.cj9.lerp(d,50,p),t.object.updateProjectionMatrix(),t.update()),p<1&&(e=requestAnimationFrame(m))};return e=requestAnimationFrame(m),()=>cancelAnimationFrame(e)}},[t]),(0,l.useEffect)(()=>{if(u.current){let n,t=x.width/x.height;if(a){var e;(n=new i.qUd).left=-50*t/2,n.right=50*t/2,n.top=25,n.bottom=-25,n.zoom=10;let r=(null==(e=s.current)?void 0:e.target)||new i.Pq0(0,0,0),a=p.position.clone().sub(r).normalize();n.position.copy(r).add(a.multiplyScalar(10)),n.lookAt(r),n.updateProjectionMatrix()}else(n=new i.ubm(50,t)).position.copy(p.position.normalize().multiply(new i.Pq0(4,4,4))),n.rotation.copy(p.rotation);m({camera:n}),s.current&&(s.current.object=n,s.current.update())}},[a]),(0,r.jsx)(L.N,{ref:s,enableRotate:!n||!a||!o,enablePan:!0,maxDistance:50,minZoom:1,maxZoom:3e3})},es=e=>{let{ZarrDS:n}=e,{setShape:t,setDataShape:a,setFlipY:o,setValueScales:s,setMetadata:u,setDimArrays:f,setDimNames:x,setDimUnits:h,setPlotOn:z,setStatus:w}=(0,c.on)((0,d.k)(e=>({setShape:e.setShape,setDataShape:e.setDataShape,setFlipY:e.setFlipY,setValueScales:e.setValueScales,setMetadata:e.setMetadata,setDimArrays:e.setDimArrays,setDimNames:e.setDimNames,setDimUnits:e.setDimUnits,setPlotOn:e.setPlotOn,setStatus:e.setStatus}))),{colormap:b,variable:I,isFlat:_,metadata:C,valueScales:D,is4D:P,setIsFlat:M}=(0,c.on)((0,d.k)(e=>({colormap:e.colormap,variable:e.variable,isFlat:e.isFlat,metadata:e.metadata,valueScales:e.valueScales,is4D:e.is4D,setIsFlat:e.setIsFlat}))),{plotType:k,displaceSurface:T,interpPixels:O,setPlotType:B}=(0,c.Ws)((0,d.k)(e=>({plotType:e.plotType,displaceSurface:e.displaceSurface,interpPixels:e.interpPixels,setPlotType:e.setPlotType}))),{zSlice:A,ySlice:j,xSlice:U,reFetch:N}=(0,c.SZ)((0,d.k)(e=>({zSlice:e.zSlice,ySlice:e.ySlice,xSlice:e.xSlice,reFetch:e.reFetch}))),{analysisMode:E}=(0,c.r2)((0,d.k)(e=>({analysisMode:e.analysisMode}))),V=(0,l.useRef)([0,0]),L=(0,l.useRef)(0),[R,X]=(0,l.useState)(!1),[G,W]=(0,l.useState)([0,0]),[Z,q]=(0,l.useState)(null),[H,Q]=(0,l.useState)(!0),[K,J]=(0,l.useState)({});(0,l.useEffect)(()=>{if("Default"!=I){Q(!1);try{Z&&Z.forEach(e=>{e.dispose(),e.source.data=null});let{setZSlice:e,setYSlice:r,setXSlice:o}=c.Ws.getState();e(A),r(j),o(U),n.GetArray(I,{xSlice:U,ySlice:j,zSlice:A}).then(e=>{let[n,r]=(0,Y.oW)({data:e.data,shape:e.shape});if(q(n),e.scalingFactor){let{maxVal:n,minVal:t}=r;s({maxVal:n*Math.pow(10,e.scalingFactor),minVal:t*Math.pow(10,e.scalingFactor)})}else s(r);let o=e.shape.length;2==o?(M(!0),["flat","sphere"].includes(k)||B("sphere")):M(!1);let l=e.shape[o-2]/e.shape[o-1]*2;t(new i.Pq0(2,l,2)),a(e.shape),Q(!0),z(!0),w(null)})}catch(e){w(null);return}n.GetAttributes(I).then(e=>{u(e),J(e);let[t,r,i]=n.GetDimArrays();P&&(t=t.slice(1),r=r.slice(1),i=i.slice(1)),f(t),x(i),t.length>2?t[1][1]<t[1][0]?o(!0):o(!1):t[0][1]<t[0][0]?o(!0):o(!1),h(r),(0,p.QB)(r,t)})}else u(null)},[N]),(0,l.useEffect)(()=>{if(!E&&H){let{dataShape:e}=c.on.getState();M(2==e.length);let n=(0,Y.qw)(e);n&&q(n)}},[E]);let $=(0,l.useMemo)(()=>({setLoc:W,setShowInfo:X,coords:V,val:L}),[]);(0,l.useEffect)(()=>()=>{Z&&Z.forEach(e=>{e.dispose()})},[Z]),(0,l.useEffect)(()=>{Z&&q(Z.map(e=>{let n=e.clone();return O?(n.minFilter=i.k6q,n.magFilter=i.k6q):(n.minFilter=i.hxR,n.magFilter=i.hxR),n.needsUpdate=!0,n}))},[O]);let en=(0,l.useMemo)(()=>y.Fp,[]);return(0,r.jsxs)("div",{id:"main-canvas-div",className:"main-canvas",style:{width:"100vw"},children:[(0,r.jsx)(eo,{}),(0,r.jsx)(ee,{setTexture:q,ZarrDS:n}),H&&(0,r.jsx)(y.PL,{units:null==K?void 0:K.units,metadata:K,valueScales:D}),(0,r.jsx)(en,{}),(_||"flat"==k)&&(0,r.jsx)(F,{loc:G,show:R,info:[...V.current,L.current]}),(!_&&"flat"!=k||_&&"sphere"===k)&&(0,r.jsx)(r.Fragment,{children:(0,r.jsxs)(g.Hl,{id:"main-canvas",camera:{position:_?[0,0,5]:[-4.5,3,4.5],fov:50},frameloop:"demand",gl:{preserveDrawingBuffer:!0},children:[(0,r.jsx)(ev,{}),(0,r.jsx)(ea,{show:H}),H&&(0,r.jsx)(eI,{}),"volume"==k&&H&&(0,r.jsxs)(r.Fragment,{children:[(0,r.jsx)(m,{volTexture:Z}),(0,r.jsx)(v,{ZarrDS:n})]}),"point-cloud"==k&&H&&(0,r.jsx)(r.Fragment,{children:(0,r.jsx)(S,{textures:{texture:Z,colormap:b},ZarrDS:n})}),"sphere"==k&&H&&(0,r.jsx)(r.Fragment,{children:T?(0,r.jsx)(ef,{textures:Z,ZarrDS:n}):(0,r.jsx)(eP,{textures:Z})}),(0,r.jsx)(el,{isFlat:!1})]})}),(_||!_&&"flat"==k)&&(0,r.jsx)(r.Fragment,{children:(0,r.jsxs)(g.Hl,{id:"main-canvas",camera:{position:[0,0,5],zoom:1e3},orthographic:!0,frameloop:"demand",children:[(0,r.jsx)(ea,{show:H}),(0,r.jsx)(ev,{}),H&&(0,r.jsx)(eI,{}),T&&(0,r.jsx)(ed,{textures:Z,infoSetters:$,ZarrDS:n}),!T&&(0,r.jsx)(eM,{textures:Z}),(0,r.jsx)(el,{isFlat:!0})]})})]})};function eu(e){let{points:n,tsID:t,pointSetters:a,scalers:o}=e,s=(0,l.useRef)(null),u=n.length,m=(0,l.useRef)(null),[p,x]=(0,l.useState)(!1),{setPointID:v,setPointLoc:h,setShowPointInfo:S}=a,[g,y]=(0,l.useState)(1),{pointColor:z,pointSize:w,useCustomPointColor:b}=(0,c.Ws)((0,d.k)(e=>({pointColor:e.pointColor,pointSize:e.linePointSize,showPoints:e.showPoints,useCustomPointColor:e.useCustomPointColor}))),{xScale:I,yScale:_}=o,{timeSeries:C}=(0,c.on)((0,d.k)(e=>({timeSeries:e.timeSeries}))),[D,P,M]=C[t].color,k=(0,l.useMemo)(()=>new i.Gu$(w),[w]),T=(0,l.useMemo)(()=>new i.V9B({color:new i.Q1f().setRGB(D/300,P/300,M/300).convertSRGBToLinear()}),[z,b,C]);return(0,l.useEffect)(()=>{if(s.current){let e=new i.B69;for(let t=0;t<u;t++){let r=n[t].toArray();e.position.set(r[0]*(I/2),r[1]*_,1),e.scale.set(w/g,w/g,w/g),e.updateMatrix(),s.current.setMatrixAt(t,e.matrix)}s.current.instanceMatrix.needsUpdate=!0}},[n,g,k,T,I,_,w]),(0,f.D)(e=>{let{camera:n}=e;n.zoom!==g&&y(n.zoom)}),(0,r.jsx)(r.Fragment,{children:(0,r.jsx)("mesh",{position:[0,0,5],onPointerEnter:function(e){if(s.current){let n=e.instanceId,r=new i.B69,a=new i.kn4,o=new i.Pq0;n!=m.current&&m.current&&(s.current.getMatrixAt(m.current,a),o.setFromMatrixPosition(a),r.scale.set(w/g,w/g,w/g),r.position.copy(o),r.updateMatrix(),s.current.setMatrixAt(m.current,r.matrix)),m.current=n,s.current.getMatrixAt(n,a),o.setFromMatrixPosition(a),r.scale.set(3*w/g,3*w/g,3/g),r.position.copy(o),r.updateMatrix(),s.current.setMatrixAt(e.instanceId,r.matrix),s.current.instanceMatrix.needsUpdate=!0,x(e=>!e),v([t,e.instanceId]),h([e.clientX,e.clientY]),S(!0)}},onPointerLeave:function(e){let n=e.instanceId;if(s.current){let e=new i.B69,t=new i.kn4,r=new i.Pq0;m.current&&(s.current.getMatrixAt(n,t),r.setFromMatrixPosition(t),e.scale.set(w/g,w/g,w/g),e.position.copy(r),e.updateMatrix(),s.current.setMatrixAt(n,e.matrix),s.current.instanceMatrix.needsUpdate=!0,x(e=>!e),S(n!=m.current))}},children:(0,r.jsx)("instancedMesh",{ref:s,args:[k,T,u]})})})}let ec=e=>{let{height:n,xScale:t,yScale:a,pointSetters:o}=e,{valueScales:s,timeSeries:u,colormap:m}=(0,c.on)((0,d.k)(e=>({valueScales:e.valueScales,timeSeries:e.timeSeries,colormap:e.colormap}))),{lineWidth:p,useLineColor:x,lineColor:v,showPoints:h,lineResolution:S,useCustomColor:g}=(0,c.Ws)((0,d.k)(e=>({lineWidth:e.lineWidth,linePointSize:e.linePointSize,showPoints:e.showPoints,useLineColor:e.useLineColor,lineColor:e.lineColor,lineResolution:e.lineResolution,useCustomColor:e.useCustomColor}))),{camera:y}=(0,f.C)(),{maxVal:z,minVal:w}=s,b=(0,l.useMemo)(()=>{let e={};return Object.keys(u).reverse().map((n,r)=>{let[o,l,s]=u[n].color;e[n]=new i.BKk({glslVersion:i.Wdf,uniforms:{cmap:{value:m},xScale:{value:t},yScale:{value:a},aspect:{value:window.innerWidth/window.innerHeight},thickness:{value:p},miter:{value:1},useLineColor:{value:g},useMapColors:{value:x},lineColor:{value:new i.Q1f().setRGB(o/255,l/255,s/255)},userColor:{value:new i.Q1f(v)},zoom:{value:y.zoom}},vertexShader:"attribute float direction; \nattribute vec3 next;\nattribute vec3 previous;\nattribute float normed;\n\nvarying float vNormed;\n\nuniform float zoom;\nuniform float thickness;\nuniform int miter;\nuniform float xScale; \nuniform float yScale;\n\nfloat getOrthographicZoom(mat4 projectionMatrix, float referenceWidth) {\n    float m0 = projectionMatrix[0][0]; // Scaling factor: 2/(right-left)\n    float viewWidth = 2.0 / m0; // Viewable width\n    return referenceWidth / viewWidth; // Zoom level\n}\n\nvoid main() {\n    vec3 pos = position;\n    vec3 prev = previous;\n    vec3 nex = next;\n    pos.x *= xScale/2.0;\n    pos.y *= yScale;\n    prev.x *= xScale/2.0;\n    prev.y *= yScale;\n    nex.x *= xScale/2.0;\n    nex.y *= yScale;\n\n    // Transform positions to view space (before projection)\n    float zoom = getOrthographicZoom(projectionMatrix, 2.);\n    float zoomLevel = 2. / projectionMatrix[0][0]; // Extract vertical scale\n    vec4 currentView = modelViewMatrix * vec4(pos, 1.0);\n    vec4 prevView = modelViewMatrix * vec4(prev, 1.0);\n    vec4 nextView = modelViewMatrix * vec4(nex, 1.0);\n\n    // Compute directions in view space\n    vec3 dir = vec3(0.0);\n    if (currentView.xyz == prevView.xyz) {\n        dir = normalize(nextView.xyz - currentView.xyz);\n    } else if (currentView.xyz == nextView.xyz) {\n        dir = normalize(currentView.xyz - prevView.xyz);\n    } else {\n        vec3 dirA = normalize(currentView.xyz - prevView.xyz);\n        if (miter == 1) {\n            vec3 dirB = normalize(nextView.xyz - currentView.xyz);\n            vec3 tangent = normalize(dirA + dirB);\n            vec3 perp = vec3(-dirA.y, dirA.x, 0.0); // Perpendicular in view space\n            vec3 miterVec = vec3(-tangent.y, tangent.x, 0.0);\n            float miterLen = dot(miterVec, perp);\n            miterLen = max(miterLen, 0.5); // Avoid division by zero\n            dir = tangent;\n        } else {\n            dir = dirA;\n        }\n    }\n\n    // Compute normal in view space\n    vec3 normal = vec3(-dir.y, dir.x, 0.0); // Perpendicular to direction\n    float len = thickness / zoom/500.; // Thickness in world/view space units\n    normal *= 0.5 * len * direction; // Apply thickness and direction\n\n    // Apply offset in view space\n    currentView.xyz += normal;\n\n    // Project to clip space\n    gl_Position = projectionMatrix * currentView;\n\n\n    vNormed = normed;\n    gl_PointSize = 1.0;\n}",fragmentShader:"\n                out vec4 Color;\n                uniform sampler2D cmap;\n                uniform bool useLineColor;\n                uniform bool useMapColors;\n                uniform vec3 lineColor;\n                uniform vec3 userColor;\n                varying float vNormed;\n\n                void main() {\n                    vec4 texColor = texture(cmap, vec2(vNormed, 0.1));\n                    texColor.a = 1.;\n                    Color = useLineColor ? vec4(userColor, 1.0) : useMapColors ? texColor : vec4(lineColor, 1.0) ;\n                }\n                ",depthWrite:!1})}),e},[u]);(0,l.useEffect)(()=>{if(Object.values(b))for(let e of Object.values(b)){let n=e.uniforms;n.cmap.value=m,n.xScale.value=t,n.yScale.value=a,n.aspect.value=window.innerWidth/window.innerHeight,n.thickness.value=p,n.miter.value=1,n.useLineColor.value=g,n.useMapColors.value=x,n.userColor.value=new i.Q1f(v),n.zoom.value=y.zoom,(0,f.m)()}},[m,p,t,a,window.innerWidth,window.innerHeight,x,v,y.zoom,g]);let I=(0,l.useMemo)(()=>window.innerWidth,[window.innerWidth]),_=(0,l.useMemo)(()=>window.innerHeight-n,[window.innerWidth,n]),[C,D]=(0,l.useState)({}),P=(0,l.useMemo)(()=>{let e={},n={};return Object.keys(u).map((t,r)=>{let a=u[t].data,o=a.map(e=>(e-w)/(z-w)),l=function(e,n,t){let r=(n-e)/(t-1);return Array.from({length:t},(n,t)=>e+r*t)}(-I,I,a.length),s=o.map((e,n)=>new i.Pq0(l[n],(e-.5)*_,5));n[t]=s;let c=new i.B6O(s).getPoints(s.length*S-1),d=[];for(let e=0;e<c.length;e++){let n=e/(c.length-1)*(o.length-1),t=Math.floor(n),r=Math.min(o.length-1,Math.ceil(n)),i=n-t;d.push(o[t]*(1-i)+o[r]*i)}let f=c.length,m=[],p=[],x=[],v=[],h=[],g=[];for(let e=0;e<f;e++){let n=c[e],t=c[Math.max(0,e-1)],r=c[Math.min(f-1,e+1)];m.push(...n,...n),p.push(1,-1),x.push(...t,...t),v.push(...r,...r),h.push(d[e],d[e])}for(let e=0;e<f-1;e++){let n=2*e,t=n+1,r=n+2,i=n+3;g.push(n,t,r),g.push(t,i,r)}let y=new i.LoY;y.setAttribute("position",new i.qtW(m,3)),y.setAttribute("direction",new i.qtW(p,1)),y.setAttribute("previous",new i.qtW(x,3)),y.setAttribute("next",new i.qtW(v,3)),y.setAttribute("normed",new i.qtW(h,1)),y.setIndex(new i.A$4(g,1)),e[t]=y}),D(n),e},[u,S]);return(0,l.useEffect)(()=>{(0,f.m)()},[h]),(0,r.jsx)(r.Fragment,{children:(0,r.jsxs)("group",{children:[Object.keys(u).map((e,n)=>(0,r.jsx)("mesh",{geometry:P[e],material:b[e]},"lineMesh_".concat(n))),h&&Object.keys(u).map((e,n)=>(0,r.jsx)(eu,{points:C[e],tsID:e,pointSetters:o,scalers:{xScale:t,yScale:a}},"plotPoints_".concat(n)))]})})},ed=e=>{let{textures:n,infoSetters:t,ZarrDS:a}=e,{setLoc:o,setShowInfo:s,val:u,coords:f}=t,{flipY:m,colormap:v,valueScales:h,dimArrays:S,dimNames:g,dimUnits:y,isFlat:z,dataShape:w,textureArrayDepths:b,strides:I,timeSeries:_,setPlotDim:C,updateDimCoords:D,updateTimeSeries:P}=(0,c.on)((0,d.k)(e=>({flipY:e.flipY,colormap:e.colormap,valueScales:e.valueScales,dimArrays:e.dimArrays,dimNames:e.dimNames,dimUnits:e.dimUnits,isFlat:e.isFlat,dataShape:e.dataShape,textureArrayDepths:e.textureArrayDepths,strides:e.strides,timeSeries:e.timeSeries,setPlotDim:e.setPlotDim,updateDimCoords:e.updateDimCoords,updateTimeSeries:e.updateTimeSeries}))),{cScale:M,cOffset:k,animProg:T,nanTransparency:O,nanColor:B,zSlice:A,ySlice:j,xSlice:U,selectTS:N,getColorIdx:E,incrementColorIdx:V}=(0,c.Ws)((0,d.k)(e=>({cOffset:e.cOffset,cScale:e.cScale,resetAnim:e.resetAnim,animate:e.animate,animProg:e.animProg,nanTransparency:e.nanTransparency,nanColor:e.nanColor,zSlice:e.zSlice,ySlice:e.ySlice,xSlice:e.xSlice,selectTS:e.selectTS,getColorIdx:e.getColorIdx,incrementColorIdx:e.incrementColorIdx}))),{axis:L,analysisMode:R,analysisArray:Y}=(0,c.r2)((0,d.k)(e=>({axis:e.axis,analysisMode:e.analysisMode,analysisArray:e.analysisArray}))),F=[S[0].slice(A[0],A[1]?A[1]:void 0),S[1].slice(j[0],j[1]?j[1]:void 0),S.length>2?S[2].slice(U[0],U[1]?U[1]:void 0):[]],X=(0,l.useMemo)(()=>{if(2==w.length)return w[0]/w[1];if(!R)return w[1]/w[2];{let e=w.filter((e,n)=>n!=L);return e[0]/e[1]}},[L,R]),G=(0,l.useMemo)(()=>new i.bdM(2,2*X),[X]),W=(0,l.useRef)(!1),Z=(0,l.useRef)(new i.I9Y(0,0)),q=R&&2==L,H=(0,l.useMemo)(()=>R?Y:(0,p.Td)(),[R,Y,n]),Q=(0,l.useMemo)(()=>S.length>2?F.filter((e,n)=>n!=L):F,[F,L]);(0,l.useEffect)(()=>{G.dispose()},[G]);let K=(0,l.useRef)(null),[J,$]=(0,l.useState)({}),[ee,en]=(0,l.useState)(Array(10).fill(new i.IUQ(-1,-1,-1,-1))),[et,er]=[w[w.length-2],w[w.length-1]];(0,l.useEffect)(()=>{let e=Object.keys(J),n=Object.keys(_),t=(e=e.filter(e=>n.includes(e))).map(e=>J[e]);en([...t,...Array(Math.max(0,10-t.length)).fill(new i.IUQ(-1,-1,-1,-1))])},[J,_]);let ei=(0,l.useMemo)(()=>new i.BKk({glslVersion:i.Wdf,uniforms:{cScale:{value:M},cOffset:{value:k},selectTS:{value:N},selectBounds:{value:ee},map:{value:n},textureDepths:{value:new i.Pq0(b[2],b[1],b[0])},cmap:{value:v},animateProg:{value:T},nanColor:{value:new i.Q1f(B)},nanAlpha:{value:1-O}},vertexShader:" // by Jeran Poehls\r\nvarying vec2 vUv;\r\n\r\nvoid main() {\r\n    vUv = uv;\r\n    gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);\r\n}",fragmentShader:z?" // Basic Shader for colors on a plane used in FlatMap with 2D data\r\nprecision highp float;\r\nprecision highp sampler3D;\r\n\r\nout vec4 color;\r\n\r\nvarying vec2 vUv;\r\n\r\nuniform sampler2D map[14];\r\nuniform vec3 textureDepths;\r\nuniform sampler2D cmap;\r\nuniform float nanAlpha;\r\nuniform vec3 nanColor;\r\nuniform float cOffset;\r\nuniform float cScale;\r\n\r\n#define epsilon 0.0001\r\n\r\nfloat sample1(vec2 p, int index) { // Shader doesn't support dynamic indexing so we gotta use switching\r\n    if (index == 0) return texture(map[0], p).r;\r\n    else if (index == 1) return texture(map[1], p).r;\r\n    else if (index == 2) return texture(map[2], p).r;\r\n    else if (index == 3) return texture(map[3], p).r;\r\n    else if (index == 4) return texture(map[4], p).r;\r\n    else if (index == 5) return texture(map[5], p).r;\r\n    else if (index == 6) return texture(map[6], p).r;\r\n    else if (index == 7) return texture(map[7], p).r;\r\n    else if (index == 8) return texture(map[8], p).r;\r\n    else if (index == 9) return texture(map[9], p).r;\r\n    else if (index == 10) return texture(map[10], p).r;\r\n    else if (index == 11) return texture(map[11], p).r;\r\n    else if (index == 12) return texture(map[12], p).r;\r\n    else if (index == 13) return texture(map[13], p).r;\r\n    else return 0.0;\r\n}\r\n\r\n\r\nvoid main(){\r\n    int yStepSize = int(textureDepths.x); \r\n    vec2 texCoord = vUv;\r\n    texCoord.xy = clamp(texCoord.xy, vec2(0.0), 1. - vec2(epsilon)); // This prevent the very edges from looping around and causing line artifacts\r\n    ivec2 idx = clamp(ivec2(texCoord * textureDepths.xy), ivec2(0), ivec2(textureDepths.xy) - 1);\r\n    int textureIdx = idx.y * yStepSize + idx.x;\r\n    vec2 localCoord = texCoord * (textureDepths.xy); // Scale up\r\n    localCoord = fract(localCoord);\r\n\r\n    float strength = sample1(localCoord, textureIdx);\r\n    bool isNaN = strength == 1.;\r\n    float sampLoc = isNaN ? strength: (strength - 0.5)*cScale + 0.5;\r\n    sampLoc = isNaN ? strength : min(sampLoc+cOffset,0.995);\r\n    color = isNaN ? vec4(nanColor, nanAlpha) : vec4(texture2D(cmap, vec2(sampLoc, 0.5)).rgb, 1.);\r\n\r\n}":"//This is for Flat Textures but with 3D textures to sample from i,e; animation\r\n\r\nuniform sampler3D map[14];\r\nuniform sampler2D cmap;\r\nuniform vec3 textureDepths;\r\n\r\nuniform bool selectTS;\r\nuniform float cOffset;\r\nuniform float cScale;\r\nuniform float animateProg;\r\nuniform float nanAlpha;\r\nuniform vec3 nanColor;\r\nuniform vec4[10] selectBounds; \r\n\r\nvarying vec2 vUv;\r\nout vec4 Color;\r\n#define epsilon 0.0001\r\n\r\nfloat sample1(vec3 p, int index) { // Shader doesn't support dynamic indexing so we gotta use switching\r\n    if (index == 0) return texture(map[0], p).r;\r\n    else if (index == 1) return texture(map[1], p).r;\r\n    else if (index == 2) return texture(map[2], p).r;\r\n    else if (index == 3) return texture(map[3], p).r;\r\n    else if (index == 4) return texture(map[4], p).r;\r\n    else if (index == 5) return texture(map[5], p).r;\r\n    else if (index == 6) return texture(map[6], p).r;\r\n    else if (index == 7) return texture(map[7], p).r;\r\n    else if (index == 8) return texture(map[8], p).r;\r\n    else if (index == 9) return texture(map[9], p).r;\r\n    else if (index == 10) return texture(map[10], p).r;\r\n    else if (index == 11) return texture(map[11], p).r;\r\n    else if (index == 12) return texture(map[12], p).r;\r\n    else if (index == 13) return texture(map[13], p).r;\r\n    else return 0.0;\r\n}\r\n\r\nbool isValid(vec2 sampleCoord){\r\n    for (int i = 0; i < 10; i++){\r\n        vec4 thisBound = selectBounds[i];\r\n        if (thisBound.x == -1.){\r\n            return false;\r\n        }\r\n        bool cond = (sampleCoord.x < thisBound.r || sampleCoord.x > thisBound.g || sampleCoord.y < thisBound.b ||  sampleCoord.y > thisBound.a);\r\n        if (!cond){\r\n            return true;\r\n        }\r\n    }\r\n    return false;\r\n}\r\n\r\nvoid main() {\r\n    int zStepSize = int(textureDepths.y) * int(textureDepths.x); \r\n    int yStepSize = int(textureDepths.x); \r\n    vec3 texCoord = vec3(vUv, animateProg);\r\n    texCoord.xy = clamp(texCoord.xy, vec2(0.0), 1. - vec2(epsilon)); // This prevent the very edges from looping around and causing line artifacts\r\n    ivec3 idx = clamp(ivec3(texCoord * textureDepths), ivec3(0), ivec3(textureDepths) - 1);\r\n    int textureIdx = idx.z * zStepSize + idx.y * yStepSize + idx.x;\r\n    vec3 localCoord = texCoord * (textureDepths); // Scale up\r\n    localCoord = fract(localCoord);\r\n\r\n    float strength = sample1(localCoord, textureIdx);\r\n\r\n    bool isNaN = strength == 1.;\r\n    float sampLoc = isNaN ? strength: (strength)*cScale;\r\n    sampLoc = isNaN ? strength : min(sampLoc+cOffset,0.995);\r\n    Color = isNaN ? vec4(nanColor, nanAlpha) : vec4(texture2D(cmap, vec2(sampLoc, 0.5)).rgb, 1.);\r\n    if (selectTS){\r\n        bool cond = isValid(vUv);\r\n        Color.rgb *= cond ? 1. : 0.65;\r\n    }\r\n}",side:i.$EB}),[z,n]);return(0,l.useEffect)(()=>{if(ei){let e=ei.uniforms;e.cOffset.value=k,e.map.value=n,e.cmap.value=v,e.animateProg.value=T,e.nanColor.value=new i.Q1f(B),e.nanAlpha.value=1-O,e.cScale.value=M,e.selectBounds.value=ee,e.selectTS.value=N}},[M,k,n,v,T,B,O,ee,N]),(0,r.jsx)(r.Fragment,{children:(0,r.jsx)("mesh",{material:ei,geometry:G,scale:[R&&2==L&&m?-1:1,m||R&&2==L?-1:1,1],rotation:[0,0,q?Math.PI/2:0],onPointerEnter:()=>{s(!0),W.current=!0},onPointerLeave:()=>{s(!1),W.current=!1},onPointerMove:e=>{if(W.current&&e.uv){K.current=e,o([e.clientX,e.clientY]),Z.current=e.uv;let{x:n,y:t}=e.uv,r=z?R?Q[1].length:F[1].length:F[2].length,i=z?R?Q[0].length:F[0].length:F[1].length,a=Math.round(n*r-.5),l=Math.round(t*i-.5),s=r*l+a;s+=z?0:Math.floor((F[0].length-1)*T)*r*i,u.current=H?H[s]:0,f.current=z?R?[Q[0][l],Q[1][a]]:[F[0][l],F[1][a]]:[F[1][l],F[2][a]]}},onClick:N&&function(e){let n=e.uv,t=new i.Pq0(0,0,1);if(a&&n){var r,o;let e=m?new i.I9Y(n.x,1-n.y):n,a=(0,p.PE)({data:R?Y:(0,p.Td)(),shape:w,stride:I},{uv:e,normal:t});C(0);let l=(0,p.jT)({normal:t,uv:n}).map((e,n)=>e?F[n][Math.round(e*F[n].length)]:null),s=g.filter((e,n)=>null!==l[n]),u=y.filter((e,n)=>null!==l[n]);l=l.filter(e=>null!==e);let c="".concat(l[0],"_").concat(l[1]),d={color:(0,x.md)(E()/10,"Paired"),data:a};V(),P({[c]:d}),D({[c]:{first:{name:s[0],loc:null!=(r=l[0])?r:0,units:u[0]},second:{name:s[1],loc:null!=(o=l[1])?o:0,units:u[1]},plot:{units:y[0]}}}),function(e,n){let t=Math.floor(e.x*er)+.5,r=Math.ceil(e.y*et)-.5,a=1/er,o=1/et,l={[n]:new i.IUQ(...[t/er-a/2,t/er+a/2],...[r/et-o/2,r/et+o/2])};$(e=>({...l,...e}))}(n,c)}}})})},ef=e=>{let{textures:n,ZarrDS:t}=e,{setPlotDim:a,updateDimCoords:o,updateTimeSeries:s}=(0,c.on)((0,d.k)(e=>({setPlotDim:e.setPlotDim,updateDimCoords:e.updateDimCoords,updateTimeSeries:e.updateTimeSeries}))),{analysisMode:u,analysisArray:f}=(0,c.r2)((0,d.k)(e=>({analysisMode:e.analysisMode,analysisArray:e.analysisArray}))),{colormap:m,isFlat:v,dimArrays:h,dimNames:S,dimUnits:g,valueScales:y,timeSeries:z,dataShape:w,strides:b,flipY:I,textureArrayDepths:_}=(0,c.on)((0,d.k)(e=>({colormap:e.colormap,isFlat:e.isFlat,dimArrays:e.dimArrays,dimNames:e.dimNames,dimUnits:e.dimUnits,valueScales:e.valueScales,timeSeries:e.timeSeries,dataShape:e.dataShape,strides:e.strides,flipY:e.flipY,textureArrayDepths:e.textureArrayDepths}))),{animate:C,animProg:D,cOffset:P,cScale:M,selectTS:k,lonExtent:T,latExtent:O,lonResolution:B,latResolution:A,nanColor:j,nanTransparency:U,sphereDisplacement:N,sphereResolution:E,zSlice:V,ySlice:L,xSlice:R,getColorIdx:Y,incrementColorIdx:F}=(0,c.Ws)((0,d.k)(e=>({animate:e.animate,animProg:e.animProg,cOffset:e.cOffset,cScale:e.cScale,selectTS:e.selectTS,lonExtent:e.lonExtent,latExtent:e.latExtent,lonResolution:e.lonResolution,latResolution:e.latResolution,nanColor:e.nanColor,nanTransparency:e.nanTransparency,sphereDisplacement:e.displacement,sphereResolution:e.sphereResolution,zSlice:e.zSlice,ySlice:e.ySlice,xSlice:e.xSlice,getColorIdx:e.getColorIdx,incrementColorIdx:e.incrementColorIdx}))),X=[h[0].slice(V[0],V[1]?V[1]:void 0),h[1].slice(L[0],L[1]?L[1]:void 0),h.length>2?h[2].slice(R[0],R[1]?R[1]:void 0):[]],[G,W]=(0,l.useState)({}),[Z,q]=(0,l.useState)(Array(10).fill(new i.IUQ(-1,-1,-1,-1))),[H,Q]=(0,l.useMemo)(()=>v?w:[w[1],w[2]],[w]);(0,l.useEffect)(()=>{let e=Object.keys(G),n=Object.keys(z),t=(e=e.filter(e=>n.includes(e))).map(e=>G[e]);q([...t,...Array(Math.max(0,10-t.length)).fill(new i.IUQ(-1,-1,-1,-1))])},[G,z]);let[K,J]=(0,l.useMemo)(()=>{let e=A/2,n=B/2;return[[Math.max(T[0]-n,-180),Math.min(T[1]+n,180)],[Math.max(O[0]-e,-90),Math.min(O[1]+e,90)]]},[O,T,B,A]),$=(0,l.useMemo)(()=>new i.WBB(1,E),[E]),ee=(0,l.useMemo)(()=>new i.BKk({glslVersion:i.Wdf,uniforms:{map:{value:n},textureDepths:{value:new i.Pq0(_[2],_[1],_[0])},selectTS:{value:k},selectBounds:{value:Z},cmap:{value:m},cOffset:{value:P},cScale:{value:M},animateProg:{value:D},latBounds:{value:new i.I9Y((0,p.kU)(J[0]),(0,p.kU)(J[1]))},lonBounds:{value:new i.I9Y((0,p.kU)(K[0]),(0,p.kU)(K[1]))},nanColor:{value:new i.Q1f(j)},nanAlpha:{value:1-U},displaceZero:{value:-y.minVal/(y.maxVal-y.minVal)},displacement:{value:N}},vertexShader:v?" // by Jeran Poehls\r\n\r\nuniform sampler2D map[14];\r\nuniform vec3 textureDepths;\r\n\r\nuniform float displaceZero;\r\nuniform float displacement;\r\nuniform vec2 latBounds;\r\nuniform vec2 lonBounds;\r\n\r\nvec2 giveUV(vec3 position){\r\n    vec3 n = normalize(position);\r\n    float latitude = asin(n.y);\r\n    float longitude = atan(n.z, n.x);\r\n    latitude = (latitude - latBounds.x)/(latBounds.y - latBounds.x);\r\n    longitude = (longitude - lonBounds.x)/(lonBounds.y - lonBounds.x);\r\n\r\n    return vec2(1.-longitude, latitude);\r\n}\r\n\r\nfloat sample1(vec2 p, int index) { // Shader doesn't support dynamic indexing so we gotta use switching\r\n    if (index == 0) return texture(map[0], p).r;\r\n    else if (index == 1) return texture(map[1], p).r;\r\n    else if (index == 2) return texture(map[2], p).r;\r\n    else if (index == 3) return texture(map[3], p).r;\r\n    else if (index == 4) return texture(map[4], p).r;\r\n    else if (index == 5) return texture(map[5], p).r;\r\n    else if (index == 6) return texture(map[6], p).r;\r\n    else if (index == 7) return texture(map[7], p).r;\r\n    else if (index == 8) return texture(map[8], p).r;\r\n    else if (index == 9) return texture(map[9], p).r;\r\n    else if (index == 10) return texture(map[10], p).r;\r\n    else if (index == 11) return texture(map[11], p).r;\r\n    else if (index == 12) return texture(map[12], p).r;\r\n    else if (index == 13) return texture(map[13], p).r;\r\n    else return 0.0;\r\n}\r\n\r\nout vec3 aPosition;\r\n\r\nvoid main() {\r\n    vec2 uv = giveUV(position);\r\n    vec3 normal = normalize(position);\r\n    int yStepSize = int(textureDepths.x); \r\n    ivec2 idx = clamp(ivec2(uv * textureDepths.xy), ivec2(0), ivec2(textureDepths.xy) - 1);\r\n    int textureIdx = idx.y * yStepSize + idx.x;\r\n    vec2 localCoord = uv * (textureDepths.xy); // Scale up\r\n    localCoord = fract(localCoord);\r\n\r\n    float dispStrength = sample1(localCoord, textureIdx);\r\n    float noNan = float(dispStrength != 1.0);\r\n    vec3 newPos = position + (normal * (dispStrength-displaceZero) * noNan * displacement);\r\n    aPosition = position; //Pass out position for sphere frag\r\n    vec4 worldPos = modelViewMatrix * vec4( newPos, 1.0 );\r\n    gl_Position = projectionMatrix * worldPos;\r\n}":" // by Jeran Poehls\r\n\r\nuniform sampler3D map[14];\r\nuniform vec3 textureDepths;\r\n\r\nuniform float displaceZero;\r\nuniform float displacement;\r\nuniform vec2 latBounds;\r\nuniform vec2 lonBounds;\r\nuniform float animateProg;\r\n\r\nvec2 giveUV(vec3 position){\r\n    vec3 n = normalize(position);\r\n    float latitude = asin(n.y);\r\n    float longitude = atan(n.z, n.x);\r\n    latitude = (latitude - latBounds.x)/(latBounds.y - latBounds.x);\r\n    longitude = (longitude - lonBounds.x)/(lonBounds.y - lonBounds.x);\r\n\r\n    return vec2(1.-longitude, latitude);\r\n}\r\n\r\nfloat sample1(vec3 p, int index) { // Shader doesn't support dynamic indexing so we gotta use switching\r\n    if (index == 0) return texture(map[0], p).r;\r\n    else if (index == 1) return texture(map[1], p).r;\r\n    else if (index == 2) return texture(map[2], p).r;\r\n    else if (index == 3) return texture(map[3], p).r;\r\n    else if (index == 4) return texture(map[4], p).r;\r\n    else if (index == 5) return texture(map[5], p).r;\r\n    else if (index == 6) return texture(map[6], p).r;\r\n    else if (index == 7) return texture(map[7], p).r;\r\n    else if (index == 8) return texture(map[8], p).r;\r\n    else if (index == 9) return texture(map[9], p).r;\r\n    else if (index == 10) return texture(map[10], p).r;\r\n    else if (index == 11) return texture(map[11], p).r;\r\n    else if (index == 12) return texture(map[12], p).r;\r\n    else if (index == 13) return texture(map[13], p).r;\r\n    else return 0.0;\r\n}\r\n\r\nout vec3 aPosition;\r\n\r\nvoid main() {\r\n    vec2 uv = giveUV(position); // We can't just pass this as a varying because the fragment will try to interpoalte between the seems which looks bad \r\n    vec3 normal = normalize(position);\r\n    int zStepSize = int(textureDepths.y) * int(textureDepths.x); \r\n    int yStepSize = int(textureDepths.x); \r\n    vec3 texCoord = vec3(uv, animateProg);\r\n    ivec3 idx = clamp(ivec3(texCoord * textureDepths), ivec3(0), ivec3(textureDepths) - 1); // Ivec3 is like running a \"floor\" operation on all three at once. The clamp is because the very last idx is OOR\r\n    int textureIdx = idx.z * zStepSize + idx.y * yStepSize + idx.x;\r\n    vec3 localCoord = texCoord * textureDepths; // Scale up\r\n    localCoord = fract(localCoord);\r\n\r\n    float dispStrength = sample1(localCoord, textureIdx);\r\n    float noNan = float(dispStrength != 1.0);\r\n    vec3 newPos = position + (normal * (dispStrength-displaceZero) * noNan * displacement);\r\n    aPosition = position; //Pass out position for sphere frag\r\n    vec4 worldPos = modelViewMatrix * vec4( newPos, 1.0 );\r\n    gl_Position = projectionMatrix * worldPos;\r\n}",fragmentShader:v?" // by Jeran Poehls\nprecision highp float;\nprecision highp sampler2D;\n\nout vec4 color;\n\nin vec3 aPosition;\n\nuniform sampler2D map[14];\nuniform sampler2D cmap;\nuniform vec3 textureDepths;\n\nuniform float cOffset;\nuniform float cScale;\nuniform float animateProg;\nuniform bool selectTS;\nuniform vec2 latBounds;\nuniform vec2 lonBounds;\nuniform vec3 nanColor;\nuniform float nanAlpha;\n\n#define pi 3.141592653\n\nfloat sample1(vec2 p, int index) { // Shader doesn't support dynamic indexing so we gotta use switching\n    if (index == 0) return texture(map[0], p).r;\n    else if (index == 1) return texture(map[1], p).r;\n    else if (index == 2) return texture(map[2], p).r;\n    else if (index == 3) return texture(map[3], p).r;\n    else if (index == 4) return texture(map[4], p).r;\n    else if (index == 5) return texture(map[5], p).r;\n    else if (index == 6) return texture(map[6], p).r;\n    else if (index == 7) return texture(map[7], p).r;\n    else if (index == 8) return texture(map[8], p).r;\n    else if (index == 9) return texture(map[9], p).r;\n    else if (index == 10) return texture(map[10], p).r;\n    else if (index == 11) return texture(map[11], p).r;\n    else if (index == 12) return texture(map[12], p).r;\n    else if (index == 13) return texture(map[13], p).r;\n    else return 0.0;\n}\n\nvec2 giveUV(vec3 position){\n    vec3 n = normalize(position);\n    float latitude = asin(n.y);\n    float longitude = atan(n.z, n.x);\n    latitude = (latitude - latBounds.x)/(latBounds.y - latBounds.x);\n    longitude = (longitude - lonBounds.x)/(lonBounds.y - lonBounds.x);\n\n    return vec2(1.-longitude, latitude);\n}\n\nvoid main(){\n    vec2 texCoord = giveUV(aPosition);\n    int yStepSize = int(textureDepths.x); \n    ivec2 idx = clamp(ivec2(texCoord * textureDepths.xy), ivec2(0), ivec2(textureDepths.xy) - 1);\n    int textureIdx = idx.y * yStepSize + idx.x;\n    vec2 localCoord = texCoord * (textureDepths.xy); // Scale up\n    localCoord = fract(localCoord);\n\n    float strength = sample1(localCoord, textureIdx);\n    bool isNaN = strength == 1.;\n    strength = isNaN ? strength : (strength - 0.5)*cScale + 0.5;\n    strength = isNaN ? strength : min(strength+cOffset,0.99);\n    color = isNaN ? vec4(nanColor, nanAlpha) : texture(cmap, vec2(strength, 0.5));\n    if (!isNaN){\n        color.a = 1.;\n    }\n\n\n}":" // by Jeran Poehls\nprecision highp float;\nprecision highp sampler3D;\n\nout vec4 color;\n\nin vec3 aPosition;\n\nuniform sampler3D map[14];\nuniform sampler2D cmap;\nuniform vec3 textureDepths;\n\nuniform float cOffset;\nuniform float cScale;\nuniform float animateProg;\nuniform vec4[10] selectBounds; \nuniform bool selectTS;\nuniform vec2 latBounds;\nuniform vec2 lonBounds;\nuniform vec3 nanColor;\nuniform float nanAlpha;\n\n#define pi 3.141592653\n#define epsilon 0.0001\n\nvec2 giveUV(vec3 position){\n    vec3 n = normalize(position);\n    float latitude = asin(n.y);\n    float longitude = atan(n.z, n.x);\n    latitude = (latitude - latBounds.x)/(latBounds.y - latBounds.x);\n    longitude = (longitude - lonBounds.x)/(lonBounds.y - lonBounds.x);\n\n    return vec2(1.-longitude, latitude);\n}\n\nbool isValid(vec2 sampleCoord){\n    for (int i = 0; i < 10; i++){\n        vec4 thisBound = selectBounds[i];\n        if (thisBound.x == -1.){\n            return false;\n        }\n        bool cond = (sampleCoord.x < thisBound.r || sampleCoord.x > thisBound.g || sampleCoord.y < thisBound.b ||  sampleCoord.y > thisBound.a);\n        if (!cond){\n            return true;\n        }\n    }\n    return false;\n}\n\nfloat sample1(vec3 p, int index) { // Shader doesn't support dynamic indexing so we gotta use switching\n    if (index == 0) return texture(map[0], p).r;\n    else if (index == 1) return texture(map[1], p).r;\n    else if (index == 2) return texture(map[2], p).r;\n    else if (index == 3) return texture(map[3], p).r;\n    else if (index == 4) return texture(map[4], p).r;\n    else if (index == 5) return texture(map[5], p).r;\n    else if (index == 6) return texture(map[6], p).r;\n    else if (index == 7) return texture(map[7], p).r;\n    else if (index == 8) return texture(map[8], p).r;\n    else if (index == 9) return texture(map[9], p).r;\n    else if (index == 10) return texture(map[10], p).r;\n    else if (index == 11) return texture(map[11], p).r;\n    else if (index == 12) return texture(map[12], p).r;\n    else if (index == 13) return texture(map[13], p).r;\n    else return 0.0;\n}\n\nvoid main(){\n    vec2 sampleCoord = giveUV(aPosition);\n    bool inBounds = all(greaterThanEqual(sampleCoord, vec2(0.0))) && \n                all(lessThanEqual(sampleCoord, vec2(1.0)));\n    \n    if (inBounds) {\n        int zStepSize = int(textureDepths.y) * int(textureDepths.x); \n        int yStepSize = int(textureDepths.x); \n        vec3 texCoord = vec3(sampleCoord, animateProg);\n        ivec3 idx = clamp(ivec3(texCoord * textureDepths), ivec3(0), ivec3(textureDepths) - 1);\n        int textureIdx = idx.z * zStepSize + idx.y * yStepSize + idx.x;\n        vec3 localCoord = texCoord * (textureDepths); // Scale up\n        localCoord = fract(localCoord);\n\n        float strength = sample1(localCoord, textureIdx);\n        bool isNaN = strength == 1.;\n        strength = isNaN ? strength : (strength)*cScale;\n        strength = isNaN ? strength : min(strength+cOffset,0.99);\n        color = isNaN ? vec4(nanColor, nanAlpha) : texture(cmap, vec2(strength, 0.5));\n        if (!isNaN){\n            color.a = 1.;\n        }\n        if (selectTS){\n            bool cond = isValid(sampleCoord);\n            color.rgb *= cond ? 1. : 0.65;\n        }\n    } else {\n        color = vec4(nanColor, 1.); // Black\n        color.a = nanAlpha;\n    }\n\n}",blending:i.NTi,side:i.hB5,transparent:!0,depthWrite:!0}),[v,n]),en=ee.clone();return en.side=i.hsX,(0,l.useEffect)(()=>{if(ee){let e=ee.uniforms;e.map.value=n,e.selectTS.value=k,e.selectBounds.value=Z,e.cmap.value=m,e.cOffset.value=P,e.cScale.value=M,e.animateProg.value=D,e.latBounds.value=new i.I9Y((0,p.kU)(J[0]),(0,p.kU)(J[1])),e.lonBounds.value=new i.I9Y((0,p.kU)(K[0]),(0,p.kU)(K[1])),e.nanColor.value=new i.Q1f(j),e.nanAlpha.value=1-U,e.displaceZero.value=-y.minVal/(y.maxVal-y.minVal),e.displacement.value=N}if(en){let e=en.uniforms;e.map.value=n,e.selectTS.value=k,e.selectBounds.value=Z,e.cmap.value=m,e.cOffset.value=P,e.cScale.value=M,e.animateProg.value=D,e.latBounds.value=new i.I9Y((0,p.kU)(J[0]),(0,p.kU)(J[1])),e.lonBounds.value=new i.I9Y((0,p.kU)(K[0]),(0,p.kU)(K[1])),e.nanColor.value=new i.Q1f(j),e.nanAlpha.value=1-U,e.displaceZero.value=-y.minVal/(y.maxVal-y.minVal),e.displacement.value=N}},[n,D,m,P,M,C,Z,k,K,J,j,U,N,y]),(0,r.jsxs)(r.Fragment,{children:[(0,r.jsx)("mesh",{renderOrder:1,geometry:$,material:ee,onClick:e=>k&&function(e){let n=function(e,n,t){let r=Math.atan2(e.z,e.x),a=Math.asin(e.y),o=(r-(0,p.kU)(t[0]))/((0,p.kU)(t[1])-(0,p.kU)(t[0])),l=(a-(0,p.kU)(n[0]))/((0,p.kU)(n[1])-(0,p.kU)(n[0]));return new i.I9Y(1-o,l)}(e.point.normalize(),J,K),r=new i.Pq0(0,0,1);if(t){var l,c;let e=I?new i.I9Y(n.x,1-n.y):n,t=(0,p.PE)({data:u?f:(0,p.Td)(),shape:w,stride:b},{uv:e,normal:r});a(0);let d=(0,p.jT)({normal:r,uv:n}).map((e,n)=>e?X[n][Math.round(e*X[n].length)]:null),m=S.filter((e,n)=>null!==d[n]),v=g.filter((e,n)=>null!==d[n]);d=d.filter(e=>null!==e);let h="".concat(d[0],"_").concat(d[1]),y={color:(0,x.md)(Y()/10,"Paired"),data:t};F(),s({[h]:y}),o({[h]:{first:{name:m[0],loc:null!=(l=d[0])?l:0,units:v[0]},second:{name:m[1],loc:null!=(c=d[1])?c:0,units:v[1]},plot:{units:g[0]}}}),function(e,n){let t=Math.floor(e.x*Q)+.5,r=Math.ceil(e.y*H)-.5,a=1/Q,o=1/H,l={[n]:new i.IUQ(...[t/Q-a/2,t/Q+a/2],...[r/H-o/2,r/H+o/2])};W(e=>({...l,...e}))}(n,h)}}(e)}),(0,r.jsx)("mesh",{renderOrder:0,geometry:$,material:en})]})};function em(e,n,t){let[r,i]=e,a=(r-n[0])/(n[1]-n[0]),o=(i-t[0])/(t[1]-t[0]);return a-=.5,o-=.5,[a*=2,(o*=2)/2,0]}function ep(e){let[n,t]=e,r=t*Math.PI/180,i=n*Math.PI/180;return[Math.cos(r)*Math.cos(i)*1.001,1.001*Math.sin(r),Math.cos(r)*Math.sin(i)*1.001]}function ex(e){let{features:n}=e,{xRange:t,yRange:a,plotType:o,borderColor:u,lonExtent:m,latExtent:p,lonResolution:x,latResolution:v}=(0,c.Ws)((0,d.k)(e=>({xRange:e.xRange,yRange:e.yRange,plotType:e.plotType,borderColor:e.borderColor,lonExtent:e.lonExtent,latExtent:e.latExtent,lonResolution:e.lonResolution,latResolution:e.latResolution}))),{flipY:h,shape:S}=(0,c.on)((0,d.k)(e=>({flipY:e.flipY,shape:e.shape}))),[g,y]=(0,l.useMemo)(()=>{let e=v/2,n=x/2,t=[Math.max(m[0]-n,-180),Math.min(m[1]+n,180)],r=[Math.max(p[0]-e,-90),Math.min(p[1]+e,90)];return[t,r=h?[r[1],r[0]]:r]},[p,m,x,v]),[z,w]=(0,l.useState)(!1);(0,l.useEffect)(()=>{"sphere"===o?w(!0):w(!1)},[o]);let b=(0,l.useMemo)(()=>new i.BKk({glslVersion:i.Wdf,vertexShader:s,fragmentShader:"precision highp float;\r\nprecision highp sampler3D;\r\n\r\nout vec4 color;\r\n\r\nin vec3 aPosition;\r\n\r\nuniform vec2 xBounds;\r\nuniform vec2 yBounds;\r\nuniform vec3 borderColor;\r\nuniform bool trim;\r\n\r\nvoid main() {\r\n\r\n    if ((aPosition.x < xBounds.x || aPosition.x > xBounds.y || aPosition.y < yBounds.x || aPosition.y > yBounds.y) && trim){\r\n        discard;\r\n    }\r\n\r\n    color = vec4(borderColor, 1.0);\r\n}",uniforms:{xBounds:{value:new i.I9Y(t[0],t[1])},yBounds:{value:new i.I9Y(a[0]/S.x,a[1]/S.x)},borderColor:{value:new i.Q1f(u)},trim:{value:!z}}}),[]);(0,l.useEffect)(()=>{if(b){let e=b.uniforms;e.xBounds.value=new i.I9Y(t[0],t[1]),e.yBounds.value=new i.I9Y(a[0]/S.x,a[1]/S.x),e.borderColor.value=new i.Q1f(u),e.trim.value=!z,(0,f.m)()}},[t,a,u,z]);let I=(0,l.useMemo)(()=>n.flatMap((e,n)=>{let t=[];if("LineString"===e.geometry.type){let n=[];e.geometry.coordinates.forEach(e=>{let[t,r]=e,[a,o,l]=z?ep([-t,r]):em([t,r],g,y);n.push(new i.Pq0(a,o,l))});let r=new Float32Array(3*n.length);n.forEach((e,n)=>{r.set([e.x,e.y,e.z],3*n)});let a=new i.LoY;a.setAttribute("position",new i.THS(r,3)),t.push(a)}else"MultiPolygon"===e.geometry.type?e.geometry.coordinates.forEach((e,n)=>{let r=n,a=e[0],o=[];a.forEach(e=>{let[n,t]=e;r++;let[a,l,s]=z?ep([-n,t]):em([n,t],g,y);o.push(new i.Pq0(a,l,s))});let l=new Float32Array(3*o.length);o.forEach((e,n)=>{l.set([e.x,e.y,e.z],3*n)});let s=new i.LoY;s.setAttribute("position",new i.THS(l,3)),t.push(s)}):("Polygon"===e.geometry.type?[e.geometry.coordinates]:e.geometry.coordinates).forEach(e=>{let n=[];e.forEach(e=>{e.forEach(e=>{let[t,r]=e,[a,o,l]=z?ep([-t,r]):em([t,r],g,y);n.push(new i.Pq0(a,o,l))})});let r=new Float32Array(3*n.length);n.forEach((e,n)=>{r.set([e.x,e.y,e.z],3*n)});let a=new i.LoY;a.setAttribute("position",new i.THS(r,3)),t.push(a)});return t}),[n,z,h,g,y]),_=(0,l.useMemo)(()=>I.map((e,n)=>{let t=new i.N1A(e,b);return(0,r.jsx)("primitive",{object:t},"border-".concat(n))}),[I,b]);return(0,r.jsx)(r.Fragment,{children:_})}let ev=()=>{let[e,n]=(0,l.useState)(null),[t,i]=(0,l.useState)(null),[a,o]=(0,l.useState)(!1),{dataShape:s,is4D:u}=(0,c.on)((0,d.k)(e=>({dataShape:e.dataShape,is4D:e.is4D}))),{zRange:m,plotType:p,showBorders:x,timeScale:v}=(0,c.Ws)((0,d.k)(e=>({zRange:e.zRange,plotType:e.plotType,showBorders:e.showBorders,timeScale:e.timeScale}))),{analysisMode:h,axis:S}=(0,c.r2)((0,d.k)(e=>({analysisMode:e.analysisMode,axis:e.axis}))),[g,y]=(0,l.useState)(!1);(0,l.useEffect)(()=>{"sphere"===p?y(!0):y(!1)},[p]),(0,f.D)(e=>{let{camera:n}=e;!g&&(Math.abs(n.rotation.z)>Math.PI/2?o(!0):a&&o(!1))}),(0,l.useEffect)(()=>{fetch("./ne_110m_coastline.json").then(e=>e.json()).then(e=>n(e.features)),fetch("./ne_110m_admin_0_countries.json").then(e=>e.json()).then(e=>i(e.features))},[]);let z="point-cloud"==p,w="flat"==p,b=s[0]/s[2]*v;return(0,r.jsxs)("group",{visible:x&&!(h&&0!=S),position:g||w?[0,0,0]:[0,0,a?m[0]*(z?b:1):m[1]*(z?b:1)],children:[e&&(0,r.jsx)(ex,{features:e}),t&&(0,r.jsx)(ex,{features:t})]})};var eh=t(3666),eS=t(4044),eg=t(6341);let ey={INITIAL_RESOLUTION:7,MAX_RESOLUTION:20,MIN_RESOLUTION:1,PC_GLOBAL_SCALE_DIVISOR:500,LINE_WIDTH:2,TICK_LENGTH_FACTOR:.05,TICK_FONT_SIZE_FACTOR:.05,TITLE_FONT_SIZE_FACTOR:.08,CONTROL_FONT_SIZE_FACTOR:.15,X_TITLE_OFFSET_FACTOR:.15,Z_TITLE_OFFSET_FACTOR:.15},ez=e=>{let{flipX:n,flipY:t,flipDown:a}=e,{dimArrays:o,dimNames:s,dimUnits:u,dataShape:f,revY:m}=(0,c.on)((0,d.k)(e=>({dimArrays:e.dimArrays,dimNames:e.dimNames,dimUnits:e.dimUnits,dataShape:e.dataShape,revY:e.flipY}))),{xRange:x,yRange:v,zRange:h,plotType:S,timeScale:g,animProg:z,zSlice:w,ySlice:b,xSlice:I}=(0,c.Ws)((0,d.k)(e=>({xRange:e.xRange,yRange:e.yRange,zRange:e.zRange,plotType:e.plotType,timeScale:e.timeScale,animProg:e.animProg,zSlice:e.zSlice,ySlice:e.ySlice,xSlice:e.xSlice}))),{hideAxis:_,hideAxisControls:C}=(0,c.qi)((0,d.k)(e=>({hideAxis:e.hideAxis,hideAxisControls:e.hideAxisControls}))),D=[(w[1]?w[1]:o[0].length)-w[0],(b[1]?b[1]:o[1].length)-b[0],(I[1]?I[1]:o[2].length)-I[0]],P=[o[0].slice(w[0],w[1]?w[1]:void 0),m?o[1].slice(b[0],b[1]?b[1]:void 0).reverse():o[1].slice(b[0],b[1]?b[1]:void 0),o[2].slice(I[0],I[1]?I[1]:void 0)],[M,k]=(0,l.useState)(ey.INITIAL_RESOLUTION),[T,O]=(0,l.useState)(ey.INITIAL_RESOLUTION),[B,A]=(0,l.useState)(ey.INITIAL_RESOLUTION),j=(0,l.useMemo)(()=>"point-cloud"==S,[S]),U=j?f[2]/ey.PC_GLOBAL_SCALE_DIVISOR:1,N=(0,l.useMemo)(()=>f[0]/f[2]*g,[f,g]),E=(0,l.useMemo)(()=>f[1]/f[2],[f]),L=(0,y.$m)("--text-plot"),R=(0,l.useMemo)(()=>{if(L)return new i.Q1f(L).getHex()},[L]),Y=(0,l.useMemo)(()=>new eg.G({color:R||0,linewidth:ey.LINE_WIDTH}),[R]),F=ey.TICK_LENGTH_FACTOR*U,X=(0,l.useMemo)(()=>{let e=new eh.n().setPositions([x[0]*U-F/2,0,0,x[1]*U+F/2,0,0]);return new eS.b(e,Y)},[x,Y,U]),G=(0,l.useMemo)(()=>{let e=new eh.n().setPositions([0,v[0]*E*U,0,0,v[1]*E*U+F/2,0]);return new eS.b(e,Y)},[v,E,Y,U]),W=(0,l.useMemo)(()=>{let e=new eh.n().setPositions([0,0,j?h[0]*U*N-F/2:h[0]-F/2,0,0,j?h[1]*U*N+F/2:h[1]+F/2]);return new eS.b(e,Y)},[h,N,j,Y,U]),Z=(0,l.useMemo)(()=>{let e=new eh.n().setPositions([0,0,0,0,0,F]);return new eS.b(e,Y)},[Y,U]),q=M/(M-1),H=1/(M-1),Q=T/(T-1),K=1/(T-1),J=B/(B-1),$=1/(B-1),ee=(0,l.useMemo)(()=>(s[2].length*ey.TITLE_FONT_SIZE_FACTOR/2+.1)*U,[s,U]),en=(0,l.useMemo)(()=>(s[1].length*ey.TITLE_FONT_SIZE_FACTOR/2+.1)*U,[s,U]),et=(0,l.useMemo)(()=>(s[0].length*ey.TITLE_FONT_SIZE_FACTOR/2+.1)*U,[s,U]);return(0,r.jsxs)("group",{visible:"sphere"!=S&&"flat"!=S&&!_,children:[(0,r.jsxs)("group",{position:[0,j?E*U*v[0]:E*v[0],0],children:[(0,r.jsxs)("group",{position:[0,0,n?j?h[0]*N*U-F/2:h[0]-F/2:j?h[1]*U*N+F/2:h[1]+F/2],rotation:[a?n?-Math.PI/2:Math.PI/2:0,0,0],children:[(0,r.jsx)("primitive",{object:X},"xLine"),Array(M).fill(null).map((e,t)=>(x[0]+1)/2<=t*q/M&&(x[1]+1)/2>=t*q/M&&(0,r.jsxs)("group",{position:[j?-U+t*q/(M/2)*U:-1+t*q/(M/2),0,0],children:[(0,r.jsx)("primitive",{object:Z.clone(),rotation:[0,n?Math.PI:0,0]},t),(0,r.jsx)(V.E,{anchorX:0==t?n?"right":"left":t==M-1?n?"left":"right":"center",anchorY:"top",fontSize:ey.TICK_FONT_SIZE_FACTOR*U,color:R,"material-depthTest":!1,rotation:[-Math.PI/2,0,n?Math.PI:0],position:[0,0,n?-ey.TICK_LENGTH_FACTOR*U:ey.TICK_LENGTH_FACTOR*U],children:(0,p.SB)(P[2][Math.floor((D[2]-1)*t*H)],u[2])},"textX_".concat(t))]},"xGroup_".concat(t))),(0,r.jsxs)("group",{rotation:[-Math.PI/2,0,n?Math.PI:0],position:[(x[0]+x[1])/2*U,0,n?-ey.X_TITLE_OFFSET_FACTOR*U:ey.X_TITLE_OFFSET_FACTOR*U],children:[(0,r.jsx)(V.E,{anchorX:"center",anchorY:"top",fontSize:ey.TITLE_FONT_SIZE_FACTOR*U,color:R,"material-depthTest":!1,children:s[2]},"xTitle"),(0,r.jsxs)("group",{visible:!C,children:[M<ey.MAX_RESOLUTION&&(0,r.jsx)(V.E,{anchorX:"center",anchorY:"middle",fontSize:.15*U,color:R,"material-depthTest":!1,position:[ee,-ey.TITLE_FONT_SIZE_FACTOR*U/2,0],onClick:e=>k(e=>Math.min(e+1,ey.MAX_RESOLUTION)),onPointerEnter:e=>document.body.style.cursor="pointer",onPointerLeave:e=>document.body.style.cursor="default",children:"+"},"xAdd"),M>ey.MIN_RESOLUTION&&(0,r.jsx)(V.E,{anchorX:"center",anchorY:"middle",fontSize:.15*U,color:R,"material-depthTest":!1,position:[-ee,-ey.TITLE_FONT_SIZE_FACTOR*U/2,0],onClick:e=>k(e=>Math.max(e-1,ey.MIN_RESOLUTION)),onPointerEnter:e=>document.body.style.cursor="pointer",onPointerLeave:e=>document.body.style.cursor="default",children:"-"},"xSub")]})]})]}),(0,r.jsxs)("group",{position:[t?x[1]*U+F/2:x[0]*U-F/2,0,0],rotation:[0,0,a?t?-Math.PI/2:Math.PI/2:0],children:[(0,r.jsx)("primitive",{object:W},"zLine"),Array(B).fill(null).map((e,n)=>(h[0]+1)/2<=n*J/B&&(h[1]+1)/2>=n*J/B&&(0,r.jsxs)("group",{position:[0,0,j?-N*U+n*J/(B/2)*N*U:-1+n*J/(B/2)],children:[(0,r.jsx)("primitive",{object:Z.clone(),rotation:[0,t?Math.PI/2:-Math.PI/2,0]},n),(0,r.jsx)(V.E,{anchorX:0==n?t?"right":"left":n==B-1?t?"left":"right":"center",anchorY:"top",fontSize:ey.TICK_FONT_SIZE_FACTOR*U*.8,color:R,"material-depthTest":!1,rotation:[-Math.PI/2,0,t?Math.PI/2:-Math.PI/2],position:[t?ey.TICK_LENGTH_FACTOR*U:-ey.TICK_LENGTH_FACTOR*U,0,0],children:(0,p.SB)(P[0][(Math.floor((D[0]-1)*n*$)+Math.floor(D[0]*z))%D[0]],u[0])},"textY_".concat(n))]},"zGroup_".concat(n))),(0,r.jsxs)("group",{rotation:[-Math.PI/2,0,t?Math.PI/2:-Math.PI/2],position:[t?ey.Z_TITLE_OFFSET_FACTOR*U:-ey.Z_TITLE_OFFSET_FACTOR*U,0,j?(h[0]+h[1])/2*N*U:(h[0]+h[1])/2],children:[(0,r.jsx)(V.E,{anchorX:"center",anchorY:"top",fontSize:ey.TITLE_FONT_SIZE_FACTOR*U,color:R,"material-depthTest":!1,children:s[0]},"zTitle"),(0,r.jsxs)("group",{visible:!C,children:[B<ey.MAX_RESOLUTION&&(0,r.jsx)(V.E,{anchorX:"center",anchorY:"middle",fontSize:.15*U,color:R,"material-depthTest":!1,position:[et,-ey.TITLE_FONT_SIZE_FACTOR*U/2,0],onClick:e=>A(e=>Math.min(e+1,ey.MAX_RESOLUTION)),onPointerEnter:e=>document.body.style.cursor="pointer",onPointerLeave:e=>document.body.style.cursor="default",children:"+"},"zAdd"),B>ey.MIN_RESOLUTION&&(0,r.jsx)(V.E,{anchorX:"center",anchorY:"middle",fontSize:.15*U,color:R,"material-depthTest":!1,position:[-et,-ey.TITLE_FONT_SIZE_FACTOR*U/2,0],onClick:e=>A(e=>Math.max(e-1,ey.MIN_RESOLUTION)),onPointerEnter:e=>document.body.style.cursor="pointer",onPointerLeave:e=>document.body.style.cursor="default",children:"-"},"zSub")]})]})]})]}),(0,r.jsxs)("group",{position:[t?x[0]*U-F/2:x[1]*U+F/2,0,n?j?h[0]*N*U-F/2:h[0]-F/2:j?h[1]*N*U+F/2:h[1]+F/2],children:[(0,r.jsx)("primitive",{object:G},"yLine"),Array(T).fill(null).map((e,i)=>(v[0]+1)/2<=i*Q/T&&(v[1]+1)/2>=i*Q/T&&(0,r.jsxs)("group",{position:[0,j?-E*U+i*Q/(T/2)*E*U:-E+i*Q/(T/2)*E,0],children:[(0,r.jsx)("primitive",{object:Z.clone(),rotation:[0,t?-Math.PI/2:Math.PI/2,0]},i),(0,r.jsx)(V.E,{anchorX:t?n?"left":"right":n?"right":"left",anchorY:"middle",fontSize:.05*U,color:R,"material-depthTest":!1,rotation:[0,n?Math.PI:0,0],position:[t?-.07*U:.07*U,0,0],children:(0,p.SB)(P[1][Math.floor((D[1]-1)*i*K)],u[1])},"text_".concat(i))]},"yGroup_".concat(i))),(0,r.jsxs)("group",{rotation:[0,n?Math.PI:0,0],position:[t?-.32*U:.32*U,(v[0]+v[1])/2*E*U,0],children:[(0,r.jsx)(V.E,{anchorX:"center",anchorY:"middle",fontSize:.08*U,color:R,"material-depthTest":!1,rotation:[0,0,Math.PI/2],children:s[1]},"yTitle"),(0,r.jsxs)("group",{visible:!C,children:[T<ey.MAX_RESOLUTION&&(0,r.jsx)(V.E,{anchorX:"center",anchorY:"middle",fontSize:ey.CONTROL_FONT_SIZE_FACTOR*U,color:R,"material-depthTest":!1,position:[0,en,0],onClick:e=>O(e=>Math.min(e+1,ey.MAX_RESOLUTION)),onPointerEnter:e=>document.body.style.cursor="pointer",onPointerLeave:e=>document.body.style.cursor="default",children:"+"},"zAdd"),T>ey.MIN_RESOLUTION&&(0,r.jsx)(V.E,{anchorX:"center",anchorY:"middle",rotation:[0,0,Math.PI/2],fontSize:ey.CONTROL_FONT_SIZE_FACTOR*U,color:R,"material-depthTest":!1,position:[0,-en,0],onClick:e=>O(e=>Math.max(e-1,ey.MIN_RESOLUTION)),onPointerEnter:e=>document.body.style.cursor="pointer",onPointerLeave:e=>document.body.style.cursor="default",children:"-"},"zSub")]})]})]})]})},ew={INITIAL_RESOLUTION:7,MAX_RESOLUTION:20,MIN_RESOLUTION:1,LINE_WIDTH:2,TICK_LENGTH:.05,TICK_FONT_SIZE:.05,TITLE_FONT_SIZE:.08,X_TITLE_OFFSET:.15,Y_TITLE_OFFSET:.325},eb=()=>{let{dimArrays:e,dimNames:n,dimUnits:t,flipY:a,isFlat:o}=(0,c.on)((0,d.k)(e=>({dimArrays:e.dimArrays,dimNames:e.dimNames,dimUnits:e.dimUnits,flipY:e.flipY,isFlat:e.isFlat}))),{plotType:s,zSlice:u,ySlice:f,xSlice:m}=(0,c.Ws)((0,d.k)(e=>({plotType:e.plotType,zSlice:e.zSlice,ySlice:e.ySlice,xSlice:e.xSlice}))),{hideAxis:x,hideAxisControls:v}=(0,c.qi)((0,d.k)(e=>({hideAxis:e.hideAxis,hideAxisControls:e.hideAxisControls}))),{analysisMode:h,axis:S}=(0,c.r2)((0,d.k)(e=>({analysisMode:e.analysisMode,axis:e.axis}))),g=2==e.length,z=g?[f,m]:[u,f,m],w=(0,l.useMemo)(()=>h&&!g?e.map((e,n)=>(z[n][1]?z[n][1]:e.length)-z[n][0]).filter((e,n)=>n!=S):e.map((e,n)=>(z[n][1]?z[n][1]:e.length)-z[n][0]),[S,e,h]),b=(0,l.useMemo)(()=>g?[a?e[0].slice().reverse():e[0],e[1]]:[e[0].slice(u[0],u[1]?u[1]:void 0),a?e[1].slice(f[0],f[1]?f[1]:void 0).reverse():e[1].slice(f[0],f[1]?f[1]:void 0),e[2].slice(m[0],m[1]?m[1]:void 0)],[e,a]),I=(0,l.useMemo)(()=>h&&2==S&&!g,[S,h]),_=I?w.length-2:w.length-1,C=I?w.length-1:w.length-2,[D,P]=(0,l.useState)(ew.INITIAL_RESOLUTION),[M,k]=(0,l.useState)(ew.INITIAL_RESOLUTION),{axisArrays:T,axisUnits:O,axisNames:B}=(0,l.useMemo)(()=>h&&!g?{axisArrays:b.filter((e,n)=>n!=S),axisUnits:t.filter((e,n)=>n!=S),axisNames:n.filter((e,n)=>n!=S)}:{axisArrays:b,axisUnits:t,axisNames:n},[h,e,t,n,b]),A=(0,l.useMemo)(()=>(h,w[C]/w[_]),[w,h,S]),j=(0,y.$m)("--text-plot"),U=(0,l.useMemo)(()=>{if(j)return new i.Q1f(j).getHex()},[j]),N=(0,l.useMemo)(()=>new eg.G({color:U||0,linewidth:ew.LINE_WIDTH}),[U]),E=ew.TICK_LENGTH,L=(0,l.useMemo)(()=>{let e=new eh.n().setPositions([-1/(I?A:1)-E/2,0,0,1/(I?A:1)+E/2,0,0]);return new eS.b(e,N)},[N,I,A]),R=(0,l.useMemo)(()=>{let e=new eh.n().setPositions([0,-(I?1:A)-E/2,0,0,(I?1:A)+E/2,0]);return new eS.b(e,N)},[A,N,I,A]),Y=(0,l.useMemo)(()=>{let e=new eh.n().setPositions([0,0,0,0,0,ew.TICK_LENGTH]);return new eS.b(e,N)},[N,I]),F=D/(D-1),X=1/(D-1),G=M/(M-1),W=1/(M-1),Z=(0,l.useMemo)(()=>B[_].length*ew.TITLE_FONT_SIZE/2+.1,[B,_]),q=(0,l.useMemo)(()=>B[C].length*ew.TITLE_FONT_SIZE/2+.1,[B,C]);return(0,r.jsxs)("group",{visible:"flat"==s&&!x,children:[(0,r.jsxs)("group",{position:[0,-(I?1:A)-E/2,0],rotation:[Math.PI/2,0,0],children:[(0,r.jsx)("primitive",{object:L},"xLine"),Array(D).fill(null).map((e,n)=>D>ew.MIN_RESOLUTION&&(0,r.jsxs)("group",{position:[-(I?1/A:1)+n*F/(D/2)*(I?1/A:1),0,0],children:[(0,r.jsx)("primitive",{object:Y.clone(),rotation:[0,0,0]},n),(0,r.jsx)(V.E,{anchorX:"center",anchorY:"top",fontSize:ew.TICK_FONT_SIZE,color:U,"material-depthTest":!1,rotation:[-Math.PI/2,0,0],position:[0,0,ew.TICK_LENGTH],children:(0,p.SB)(T[_][Math.floor((w[_]-1)*n*X)],O[_])},"textX_".concat(n))]},"xGroup_".concat(n))),(0,r.jsxs)("group",{rotation:[-Math.PI/2,0,0],position:[0,0,ew.X_TITLE_OFFSET],children:[(0,r.jsx)(V.E,{anchorX:"center",anchorY:"top",fontSize:ew.TITLE_FONT_SIZE,color:U,"material-depthTest":!1,children:B[_]},"xTitle"),(0,r.jsxs)("group",{visible:!v,children:[D<ew.MAX_RESOLUTION&&(0,r.jsx)(V.E,{anchorX:"center",anchorY:"middle",fontSize:.125,color:U,"material-depthTest":!1,position:[Z,-.05,0],onClick:e=>P(e=>Math.min(e+1,ew.MAX_RESOLUTION)),onPointerEnter:e=>document.body.style.cursor="pointer",onPointerLeave:e=>document.body.style.cursor="default",children:"+"},"xAdd"),D>ew.MIN_RESOLUTION&&(0,r.jsx)(V.E,{anchorX:"center",anchorY:"middle",fontSize:.125,color:U,"material-depthTest":!1,position:[-Z,-.05,0],onClick:e=>P(e=>Math.max(e-1,ew.MIN_RESOLUTION)),onPointerEnter:e=>document.body.style.cursor="pointer",onPointerLeave:e=>document.body.style.cursor="default",children:"-"},"xSub")]})]})]}),(0,r.jsxs)("group",{position:[-(I?1/A:1)-E/2,0,0],children:[(0,r.jsx)("primitive",{object:R},"yLine"),Array(M).fill(null).map((e,n)=>M>ew.MIN_RESOLUTION&&(0,r.jsxs)("group",{position:[0,-(I?1:A)+n*G/(M/2)*(I?1:A),0],rotation:[0,0,Math.PI],children:[(0,r.jsx)("primitive",{object:Y.clone(),rotation:[0,Math.PI/2,0]},n),(0,r.jsx)(V.E,{anchorX:"right",anchorY:"middle",fontSize:ew.TICK_FONT_SIZE,color:U,"material-depthTest":!1,rotation:[0,0,-Math.PI],position:[1.4*ew.TICK_LENGTH,0,0],children:(0,p.SB)(T[C][Math.floor((w[C]-1)*n*W)],O[C])},"text_".concat(n))]},"yGroup_".concat(n))),(0,r.jsxs)("group",{rotation:[0,0,0],position:[-ew.Y_TITLE_OFFSET,0,0],children:[(0,r.jsx)(V.E,{anchorX:"center",anchorY:"middle",rotation:[0,0,Math.PI/2],fontSize:ew.TITLE_FONT_SIZE,color:U,"material-depthTest":!1,children:B[C]},"yTitle"),(0,r.jsxs)("group",{visible:!v,children:[M<ew.MAX_RESOLUTION&&(0,r.jsx)(V.E,{anchorX:"center",anchorY:"middle",fontSize:.125,color:U,"material-depthTest":!1,position:[0,q,0],onClick:e=>k(e=>Math.min(e+1,ew.MAX_RESOLUTION)),onPointerEnter:e=>document.body.style.cursor="pointer",onPointerLeave:e=>document.body.style.cursor="default",children:"+"},"zAdd"),M>ew.MIN_RESOLUTION&&(0,r.jsx)(V.E,{anchorX:"center",anchorY:"middle",fontSize:.125,color:U,"material-depthTest":!1,position:[0,-q,0],onClick:e=>k(e=>Math.max(e-1,ew.MIN_RESOLUTION)),onPointerEnter:e=>document.body.style.cursor="pointer",onPointerLeave:e=>document.body.style.cursor="default",children:"-"},"zSub")]})]})]})]})},eI=()=>{let[e,n]=(0,l.useState)(!1),[t,i]=(0,l.useState)(!1),[a,o]=(0,l.useState)(!1),{isFlat:s}=(0,c.on)((0,d.k)(e=>({isFlat:e.isFlat})));return(0,f.D)(r=>{let{camera:l}=r,s=Math.abs(l.rotation.z)>Math.PI/2;e!==s&&n(s);let u=l.rotation.z>0&&l.rotation.x<0||l.rotation.z<=0&&l.rotation.x>0;t!==u&&i(u);let c=l.rotation.x>0||l.position.y<=0;a!==c&&o(c)}),(0,r.jsxs)(r.Fragment,{children:[!s&&(0,r.jsx)(ez,{flipX:e,flipY:t,flipDown:a}),(0,r.jsx)(eb,{})]})};var e_=t(3140);let eC=()=>{let e=(0,l.useRef)(null),{gl:n}=(0,f.C)(),{setMaxTextureSize:t,setMax3DTextureSize:a}=(0,c.Ws)((0,d.k)(e=>({setMaxTextureSize:e.setMaxTextureSize,setMax3DTextureSize:e.setMax3DTextureSize})));(0,l.useEffect)(()=>{let e=n.getContext();a(e.getParameter(e.MAX_3D_TEXTURE_SIZE)),t(e.getParameter(e.MAX_TEXTURE_SIZE))},[]);let{colormap:o}=(0,c.on)((0,d.k)(e=>({colormap:e.colormap}))),{spherePositions:s,cubePositions:u,planePositions:m}=(0,l.useMemo)(()=>{let e=new Float32Array(46875),n=new Float32Array(46875),t=new Float32Array(46875),r=Math.PI*(3-Math.sqrt(5));for(let n=0;n<15625;n++){let t=1-n/15624*2,i=Math.sqrt(1-t*t),a=r*n,o=Math.cos(a)*i,l=Math.sin(a)*i;e[3*n]=1.2*o,e[3*n+1]=1.2*t,e[3*n+2]=1.2*l}let i=0;for(let e=0;e<25;e++)for(let t=0;t<25;t++)for(let r=0;r<25;r++)n[3*i]=(e/25-.5)*2,n[3*i+1]=(t/25-.5)*2,n[3*i+2]=(r/25-.5)*2,i++;i=0;for(let e=0;e<125;e++)for(let n=0;n<125;n++)t[3*i]=(e/125-.5)*2.5,t[3*i+1]=(n/125-.5)*2.5,t[3*i+2]=0,i++;return{spherePositions:e,cubePositions:n,planePositions:t}},[15625]),p=(0,l.useMemo)(()=>new i.BKk({glslVersion:i.Wdf,uniforms:{uSphereMix:{value:1},uCubeMix:{value:0},uPlaneMix:{value:0},uTime:{value:0},cmap:{value:o}},vertexShader:"uniform float uSphereMix;\r\nuniform float uCubeMix;\r\nuniform float uPlaneMix;\r\nuniform float uSize;\r\nuniform float uTime;\r\nuniform sampler2D cmap;\r\n\r\nattribute vec3 aSpherePosition;\r\nattribute vec3 aCubePosition;\r\nattribute vec3 aPlanePosition;\r\n\r\nvarying vec3 vColor; \r\n\r\nvoid main() {\r\n    // Linearly interpolate between the three shapes using the mix uniforms\r\n    vec3 pos = mix(aSpherePosition, aCubePosition, uCubeMix);\r\n    pos = mix(pos, aPlanePosition, uPlaneMix);\r\n\r\n    // Add a slight sine wave animation to make it more dynamic\r\n    // pos.y += sin(pos.x * 50.0 + uTime) * 0.005;\r\n    // pos.x += cos(pos.y * 50.0 + uTime) * 0.005;\r\n\r\n    float minBrightness = 0.2;\r\n    float maxBrightness = 0.96;\r\n\r\n    float r = sin(pos.z + (uTime * 0.2 ) )  ;\r\n    float g = cos(pos.y + (uTime * 0.3 ) );\r\n    float b = cos(pos.x+pos.y + (uTime * 0.5));\r\n\r\n    vColor = vec3(r, g, b);\r\n    float mag = min(((sin(r+g+b) + 1.) /2.), 0.996) ;\r\n    vec4 sampled = texture(cmap, vec2(mag, 0.5));\r\n    vColor = sampled.rgb;\r\n    // Calculate luminance (perceived brightness)\r\n\r\n    vec4 modelPosition = modelMatrix * vec4(pos, 1.0);\r\n    vec4 viewPosition = viewMatrix * modelPosition;\r\n    vec4 projectedPosition = projectionMatrix * viewPosition;\r\n\r\n    gl_Position = projectedPosition;\r\n\r\n    // Make points smaller as they are further away (perspective)\r\n    gl_PointSize = (15.0 / -viewPosition.z);\r\n}\r\n\r\n",fragmentShader:"// Fragment Shader\r\n\r\nin vec3 vColor;\r\nout vec4 Color;\r\n\r\nvoid main() {\r\n    // Simple white color for the points\r\n    Color = vec4(vColor, 0.8);\r\n}"}),[]);return(0,l.useEffect)(()=>{let e=null;if(p){let n=p.uniforms;(e=e_.Ay.timeline({repeat:-1,yoyo:!1})).to(n.uCubeMix,{value:1,duration:2,delay:3,ease:"power2.inOut"}),e.to(n.uCubeMix,{value:0,duration:2,delay:3,ease:"power2.inOut"}),e.to(n.uPlaneMix,{value:1,duration:2,ease:"power2.inOut"},"<"),e.to(n.uPlaneMix,{value:0,duration:2,delay:3,ease:"power2.inOut"})}return()=>{e&&e.kill()}},[]),(0,f.D)(n=>{p&&(p.uniforms.uTime.value=n.clock.getElapsedTime()),e.current&&(e.current.rotation.y+=.001,e.current.rotation.x+=.001)}),(0,l.useEffect)(()=>{p&&(p.uniforms.cmap.value=o)},[o]),(0,r.jsx)("points",{ref:e,material:p,children:(0,r.jsxs)("bufferGeometry",{children:[(0,r.jsx)("bufferAttribute",{attach:"attributes-position",args:[s,3],count:15625}),(0,r.jsx)("bufferAttribute",{attach:"attributes-aSpherePosition",args:[s,3],count:15625}),(0,r.jsx)("bufferAttribute",{attach:"attributes-aCubePosition",args:[u,3],count:15625}),(0,r.jsx)("bufferAttribute",{attach:"attributes-aPlanePosition",args:[m,3],count:15625})]})})},eD=()=>(0,r.jsx)("div",{className:"w-[100vw] h-[100vh]",children:(0,r.jsx)(g.Hl,{camera:{position:[0,0,3]},children:(0,r.jsx)(eC,{})})}),eP=e=>{let{textures:n}=e,{colormap:t,isFlat:a,valueScales:o,dataShape:s,textureArrayDepths:m}=(0,c.on)((0,d.k)(e=>({colormap:e.colormap,isFlat:e.isFlat,valueScales:e.valueScales,dataShape:e.dataShape,textureArrayDepths:e.textureArrayDepths}))),{animProg:x,cOffset:v,cScale:h,lonExtent:S,latExtent:g,lonResolution:y,latResolution:z,nanColor:w,nanTransparency:b,sphereDisplacement:I,offsetNegatives:_}=(0,c.Ws)((0,d.k)(e=>({animate:e.animate,animProg:e.animProg,cOffset:e.cOffset,cScale:e.cScale,lonExtent:e.lonExtent,latExtent:e.latExtent,lonResolution:e.lonResolution,latResolution:e.latResolution,nanColor:e.nanColor,nanTransparency:e.nanTransparency,sphereDisplacement:e.displacement,sphereResolution:e.sphereResolution,offsetNegatives:e.offsetNegatives}))),C=(0,l.useMemo)(()=>{let e=s[s.length-1];return e*(s[s.length-1]/2)},[s]),D=(0,l.useMemo)(()=>{let e=s[s.length-1],n=s[s.length-1]/2,t=2*Math.PI,r=new i.iNn(t/e,.05,t/n/2),a=new Float32Array(e*n*2),o=0;for(let t=0;t<e;t++)for(let r=0;r<n;r++){let i=(t+.5)/e,l=(r+.5)/n;a[2*o]=i,a[2*o+1]=l,o++}return r.setAttribute("instanceUV",new i.uWO(a,2)),r},[s]),[P,M]=(0,l.useMemo)(()=>{let e=z/2,n=y/2;return[[Math.max(S[0]-n,-180),Math.min(S[1]+n,180)],[Math.max(g[0]-e,-90),Math.min(g[1]+e,90)]]},[g,S,y,z]),k=(0,l.useMemo)(()=>new i.BKk({glslVersion:i.Wdf,uniforms:{map:{value:n},textureDepths:{value:new i.Pq0(m[2],m[1],m[0])},latBounds:{value:new i.I9Y((0,p.kU)(M[0]),(0,p.kU)(M[1]))},lonBounds:{value:new i.I9Y((0,p.kU)(P[0]),(0,p.kU)(P[1]))},cmap:{value:t},cOffset:{value:v},cScale:{value:h},animateProg:{value:x},nanColor:{value:new i.Q1f(w)},nanAlpha:{value:1-b},displaceZero:{value:_?0:-o.minVal/(o.maxVal-o.minVal)},displacement:{value:I}},vertexShader:a?" // by Jeran Poehls\r\n\r\nattribute vec2 instanceUV;\r\n\r\nuniform sampler2D map[14];\r\nuniform vec3 textureDepths;\r\n\r\nuniform float displaceZero;\r\nuniform float displacement;\r\nuniform vec2 latBounds;\r\nuniform vec2 lonBounds;\r\nuniform float animateProg;\r\n\r\n#define PI 3.1415926535\r\n\r\nvec3 givePosition(vec2 uv) {\r\n    // Reverse the normalization using the bounds\r\n    float longitude = (1.0 - uv.x) * (lonBounds.y - lonBounds.x) + lonBounds.x;\r\n    float latitude = uv.y * (latBounds.y - latBounds.x) + latBounds.x;\r\n    \r\n    // Convert to Cartesian coordinates\r\n    float x = cos(latitude) * cos(longitude);\r\n    float y = sin(latitude);\r\n    float z = cos(latitude) * sin(longitude);\r\n    \r\n    return vec3(x, y, z);\r\n}\r\n\r\n\r\nfloat sample1(vec2 p, int index) { // Shader doesn't support dynamic indexing so we gotta use switching\r\n    if (index == 0) return texture(map[0], p).r;\r\n    else if (index == 1) return texture(map[1], p).r;\r\n    else if (index == 2) return texture(map[2], p).r;\r\n    else if (index == 3) return texture(map[3], p).r;\r\n    else if (index == 4) return texture(map[4], p).r;\r\n    else if (index == 5) return texture(map[5], p).r;\r\n    else if (index == 6) return texture(map[6], p).r;\r\n    else if (index == 7) return texture(map[7], p).r;\r\n    else if (index == 8) return texture(map[8], p).r;\r\n    else if (index == 9) return texture(map[9], p).r;\r\n    else if (index == 10) return texture(map[10], p).r;\r\n    else if (index == 11) return texture(map[11], p).r;\r\n    else if (index == 12) return texture(map[12], p).r;\r\n    else if (index == 13) return texture(map[13], p).r;\r\n    else return 0.0;\r\n}\r\n\r\nout float vStrength;\r\n\r\nvoid main() {\r\n\r\n    int yStepSize = int(textureDepths.x); \r\n    ivec2 idx = clamp(ivec2(instanceUV * textureDepths.xy), ivec2(0), ivec2(textureDepths.xy) - 1);\r\n    int textureIdx = idx.y * yStepSize + idx.x;\r\n    vec2 localCoord = instanceUV * (textureDepths.xy); // Scale up\r\n    localCoord = fract(localCoord);\r\n\r\n    float dispStrength = sample1(localCoord, textureIdx);\r\n\r\n    if (dispStrength == 1.0){ // Invalid value. Just hide it\r\n        gl_Position = vec4(2.0, 2.0, 2.0, 1.0);\r\n    } else {\r\n        vec2 centeredUV = (instanceUV - vec2(0.5, 0.5)) * vec2(2.0, 2.0); \r\n        vec3 spherePosition = givePosition(instanceUV);\r\n        float latitudeFactor = cos(centeredUV.y * 3.14159 * 0.5); // Maps -1..1 to proper latitude\r\n        float heightFactor = (dispStrength - displaceZero) * displacement;\r\n        vec3 scaledPosition = position;\r\n        scaledPosition.x *= latitudeFactor;\r\n        scaledPosition.y += 0.025;\r\n        scaledPosition.y *= heightFactor;\r\n\r\n\r\n        vec3 normal = normalize(spherePosition);\r\n        // Create orientation matrix to point cube outward\r\n        vec3 up = vec3(0.0, 1.0, 0.0);\r\n        vec3 tangent = normalize(cross(up, normal));\r\n        vec3 bitangent = cross(normal, tangent);\r\n        mat3 orientation = mat3(tangent, normal, bitangent);\r\n\r\n        // Apply orientation and position\r\n        vec3 oriented = orientation * scaledPosition;\r\n        vec3 worldPosition = spherePosition + oriented;\r\n        // worldPosition = scaledPosition + spherePosition;\r\n        vStrength = dispStrength;\r\n        \r\n        gl_Position = projectionMatrix * modelViewMatrix * vec4(worldPosition, 1.0);\r\n\r\n    }\r\n}":' // by Jeran Poehls\r\n\r\nattribute vec2 instanceUV;\r\n\r\nuniform sampler3D map[14];\r\nuniform vec3 textureDepths;\r\n\r\nuniform float displaceZero;\r\nuniform float displacement;\r\nuniform vec2 latBounds;\r\nuniform vec2 lonBounds;\r\nuniform float animateProg;\r\n\r\n#define PI 3.1415926535\r\n\r\nvec3 givePosition(vec2 uv) {\r\n    // Reverse the normalization using the bounds\r\n    float longitude = (1.0 - uv.x) * (lonBounds.y - lonBounds.x) + lonBounds.x;\r\n    float latitude = uv.y * (latBounds.y - latBounds.x) + latBounds.x;\r\n    \r\n    // Convert to Cartesian coordinates\r\n    float x = cos(latitude) * cos(longitude);\r\n    float y = sin(latitude);\r\n    float z = cos(latitude) * sin(longitude);\r\n    \r\n    return vec3(x, y, z);\r\n}\r\n\r\n\r\nfloat sample1(vec3 p, int index) { // Shader doesn\'t support dynamic indexing so we gotta use switching\r\n    if (index == 0) return texture(map[0], p).r;\r\n    else if (index == 1) return texture(map[1], p).r;\r\n    else if (index == 2) return texture(map[2], p).r;\r\n    else if (index == 3) return texture(map[3], p).r;\r\n    else if (index == 4) return texture(map[4], p).r;\r\n    else if (index == 5) return texture(map[5], p).r;\r\n    else if (index == 6) return texture(map[6], p).r;\r\n    else if (index == 7) return texture(map[7], p).r;\r\n    else if (index == 8) return texture(map[8], p).r;\r\n    else if (index == 9) return texture(map[9], p).r;\r\n    else if (index == 10) return texture(map[10], p).r;\r\n    else if (index == 11) return texture(map[11], p).r;\r\n    else if (index == 12) return texture(map[12], p).r;\r\n    else if (index == 13) return texture(map[13], p).r;\r\n    else return 0.0;\r\n}\r\n\r\nout float vStrength;\r\n\r\nvoid main() {\r\n\r\n    int zStepSize = int(textureDepths.y) * int(textureDepths.x); \r\n    int yStepSize = int(textureDepths.x); \r\n    vec3 texCoord = vec3(instanceUV, animateProg);\r\n    ivec3 idx = clamp(ivec3(texCoord * textureDepths), ivec3(0), ivec3(textureDepths) - 1); // Ivec3 is like running a "floor" operation on all three at once. The clamp is because the very last idx is OOR\r\n    int textureIdx = idx.z * zStepSize + idx.y * yStepSize + idx.x;\r\n    vec3 localCoord = texCoord * textureDepths; // Scale up\r\n    localCoord = fract(localCoord);\r\n\r\n    float dispStrength = sample1(localCoord, textureIdx);\r\n\r\n    if (dispStrength == 1.0){ // Invalid value. Just hide it\r\n        gl_Position = vec4(2.0, 2.0, 2.0, 1.0);\r\n    } else {\r\n        vec2 centeredUV = (instanceUV - vec2(0.5, 0.5)) * vec2(2.0, 2.0); \r\n        vec3 spherePosition = givePosition(instanceUV);\r\n        float latitudeFactor = cos(centeredUV.y * 3.14159 * 0.5); // Maps -1..1 to proper latitude\r\n        float heightFactor = (dispStrength - displaceZero) * displacement;\r\n        vec3 scaledPosition = position;\r\n        scaledPosition.x *= latitudeFactor;\r\n        scaledPosition.y += 0.025;\r\n        scaledPosition.y *= heightFactor;\r\n\r\n\r\n\r\n        vec3 normal = normalize(spherePosition);\r\n        // Create orientation matrix to point cube outward\r\n        vec3 up = vec3(0.0, 1.0, 0.0);\r\n        vec3 tangent = normalize(cross(up, normal));\r\n        vec3 bitangent = cross(normal, tangent);\r\n        mat3 orientation = mat3(tangent, normal, bitangent);\r\n\r\n        // Apply orientation and position\r\n        vec3 oriented = orientation * scaledPosition;\r\n        vec3 worldPosition = spherePosition + oriented;\r\n        // worldPosition = scaledPosition + spherePosition;\r\n        vStrength = dispStrength;\r\n        \r\n        gl_Position = projectionMatrix * modelViewMatrix * vec4(worldPosition, 1.0);\r\n\r\n    }\r\n}',fragmentShader:u,blending:i.NTi,side:i.$EB,depthWrite:!0}),[C,a]);(0,l.useEffect)(()=>{if(k){let e=k.uniforms;e.map.value=n,e.animateProg.value=x,e.displaceZero.value=-o.minVal/(o.maxVal-o.minVal),e.displacement.value=I,e.cmap.value=t,e.cOffset.value=v,e.cScale.value=h,e.latBounds.value=new i.I9Y((0,p.kU)(M[0]),(0,p.kU)(M[1])),e.lonBounds.value=new i.I9Y((0,p.kU)(P[0]),(0,p.kU)(P[1])),e.displaceZero.value=_?0:-o.minVal/(o.maxVal-o.minVal)}(0,f.m)()},[x,o,I,t,h,v,M,P,_,n]);let T=(0,l.useMemo)(()=>new i.V9B({color:w}),[]);T.transparent=!0;let O=(0,l.useMemo)(()=>new i.WBB(1,9),[]);return(0,l.useEffect)(()=>{T&&(T.color.set(w),T.opacity=1-b,(0,f.m)())},[w,b]),(0,r.jsxs)("group",{scale:[1,1,1],children:[(0,r.jsx)("instancedMesh",{args:[D,k,C],frustumCulled:!1}),(0,r.jsx)("mesh",{geometry:O,material:T})]})},eM=e=>{let{textures:n}=e,{colormap:t,isFlat:a,valueScales:o,flipY:s,dataShape:m,textureArrayDepths:p}=(0,c.on)((0,d.k)(e=>({colormap:e.colormap,isFlat:e.isFlat,valueScales:e.valueScales,flipY:e.flipY,dataShape:e.dataShape,textureArrayDepths:e.textureArrayDepths}))),{animProg:x,cOffset:v,cScale:h,nanColor:S,nanTransparency:g,displacement:y,offsetNegatives:z}=(0,c.Ws)((0,d.k)(e=>({animate:e.animate,animProg:e.animProg,cOffset:e.cOffset,cScale:e.cScale,nanColor:e.nanColor,nanTransparency:e.nanTransparency,displacement:e.displacement,sphereResolution:e.sphereResolution,offsetNegatives:e.offsetNegatives}))),w=m[m.length-1],b=m[m.length-2],I=(0,l.useMemo)(()=>{let e=w*b,n=w/b,t=new i.iNn(1/w*n,1/b,.01),r=new Float32Array(2*e),a=0;for(let e=0;e<w;e++)for(let n=0;n<b;n++){let t=(e+.5)/w,i=(n+.5)/b;r[2*a]=t,r[2*a+1]=i,a++}return t.setAttribute("instanceUV",new i.uWO(r,2)),t},[w,b]),_=(0,l.useMemo)(()=>new i.BKk({glslVersion:i.Wdf,uniforms:{map:{value:n},aspect:{value:w/b},textureDepths:{value:new i.Pq0(p[2],p[1],p[0])},cmap:{value:t},cOffset:{value:v},cScale:{value:h},animateProg:{value:x},nanColor:{value:new i.Q1f(S)},nanAlpha:{value:1-g},displaceZero:{value:z?0:-o.minVal/(o.maxVal-o.minVal)},displacement:{value:y}},vertexShader:a?"attribute vec2 instanceUV;\r\n\r\nuniform sampler2D map[14];\r\nuniform vec3 textureDepths;\r\nuniform float aspect;\r\nuniform float displaceZero;\r\nuniform float displacement;\r\nuniform float animateProg;\r\n\r\n#define PI 3.1415926535\r\n\r\nvec3 givePosition(vec2 uv) {\r\n    return vec3(uv.x*aspect, uv.y, 0.);\r\n}\r\n\r\n\r\nfloat sample1(vec2 p, int index) { // Shader doesn't support dynamic indexing so we gotta use switching\r\n    if (index == 0) return texture(map[0], p).r;\r\n    else if (index == 1) return texture(map[1], p).r;\r\n    else if (index == 2) return texture(map[2], p).r;\r\n    else if (index == 3) return texture(map[3], p).r;\r\n    else if (index == 4) return texture(map[4], p).r;\r\n    else if (index == 5) return texture(map[5], p).r;\r\n    else if (index == 6) return texture(map[6], p).r;\r\n    else if (index == 7) return texture(map[7], p).r;\r\n    else if (index == 8) return texture(map[8], p).r;\r\n    else if (index == 9) return texture(map[9], p).r;\r\n    else if (index == 10) return texture(map[10], p).r;\r\n    else if (index == 11) return texture(map[11], p).r;\r\n    else if (index == 12) return texture(map[12], p).r;\r\n    else if (index == 13) return texture(map[13], p).r;\r\n    else return 0.0;\r\n}\r\n\r\nout float vStrength;\r\n\r\nvoid main() {\r\n\r\n    int yStepSize = int(textureDepths.x); \r\n    ivec2 idx = clamp(ivec2(instanceUV * textureDepths.xy), ivec2(0), ivec2(textureDepths.xy) - 1);\r\n    int textureIdx = idx.y * yStepSize + idx.x;\r\n    vec2 localCoord = instanceUV * (textureDepths.xy); // Scale up\r\n    localCoord = fract(localCoord);\r\n\r\n    float dispStrength = sample1(localCoord, textureIdx);\r\n\r\n    if (dispStrength == 1.0){ // Invalid value. Just hide it\r\n        gl_Position = vec4(2.0, 2.0, 2.0, 1.0);\r\n    } else {\r\n        vec2 centeredUV = (instanceUV - vec2(0.5, 0.5)); \r\n        vec3 planePosition = givePosition(centeredUV);\r\n        float heightFactor = (dispStrength - displaceZero) * displacement;\r\n        vec3 scaledPosition = position;\r\n        scaledPosition.z += 0.005;\r\n        scaledPosition.z *= heightFactor;\r\n        vStrength = dispStrength;\r\n        vec3 worldPosition = planePosition + scaledPosition;\r\n        \r\n        gl_Position = projectionMatrix * modelViewMatrix * vec4(worldPosition, 1.0);\r\n\r\n    }\r\n}":' // by Jeran Poehls\r\n\r\nattribute vec2 instanceUV;\r\n\r\nuniform sampler3D map[14];\r\nuniform vec3 textureDepths;\r\n\r\nuniform float aspect;\r\nuniform float displaceZero;\r\nuniform float displacement;\r\nuniform float animateProg;\r\n\r\n#define PI 3.1415926535\r\n\r\nvec3 givePosition(vec2 uv) {\r\n    return vec3(uv.x*aspect, uv.y, 0.);\r\n}\r\n\r\n\r\nfloat sample1(vec3 p, int index) { // Shader doesn\'t support dynamic indexing so we gotta use switching\r\n    if (index == 0) return texture(map[0], p).r;\r\n    else if (index == 1) return texture(map[1], p).r;\r\n    else if (index == 2) return texture(map[2], p).r;\r\n    else if (index == 3) return texture(map[3], p).r;\r\n    else if (index == 4) return texture(map[4], p).r;\r\n    else if (index == 5) return texture(map[5], p).r;\r\n    else if (index == 6) return texture(map[6], p).r;\r\n    else if (index == 7) return texture(map[7], p).r;\r\n    else if (index == 8) return texture(map[8], p).r;\r\n    else if (index == 9) return texture(map[9], p).r;\r\n    else if (index == 10) return texture(map[10], p).r;\r\n    else if (index == 11) return texture(map[11], p).r;\r\n    else if (index == 12) return texture(map[12], p).r;\r\n    else if (index == 13) return texture(map[13], p).r;\r\n    else return 0.0;\r\n}\r\n\r\nout float vStrength;\r\n\r\nvoid main() {\r\n\r\n    int zStepSize = int(textureDepths.y) * int(textureDepths.x); \r\n    int yStepSize = int(textureDepths.x); \r\n    vec3 texCoord = vec3(instanceUV, animateProg);\r\n    ivec3 idx = clamp(ivec3(texCoord * textureDepths), ivec3(0), ivec3(textureDepths) - 1); // Ivec3 is like running a "floor" operation on all three at once. The clamp is because the very last idx is OOR\r\n    int textureIdx = idx.z * zStepSize + idx.y * yStepSize + idx.x;\r\n    vec3 localCoord = texCoord * textureDepths; // Scale up\r\n    localCoord = fract(localCoord);\r\n\r\n    float dispStrength = sample1(localCoord, textureIdx);\r\n\r\n    if (dispStrength == 1.0){ // Invalid value. Just hide it\r\n        gl_Position = vec4(2.0, 2.0, 2.0, 1.0);\r\n    } else {\r\n        vec2 centeredUV = (instanceUV - vec2(0.5, 0.5)); \r\n        vec3 planePosition = givePosition(centeredUV);\r\n        float heightFactor = (dispStrength - displaceZero) * displacement;\r\n        vec3 scaledPosition = position;\r\n        scaledPosition.z += 0.005;\r\n        scaledPosition.z *= heightFactor;\r\n        vStrength = dispStrength;\r\n        vec3 worldPosition = planePosition + scaledPosition;\r\n        \r\n        gl_Position = projectionMatrix * modelViewMatrix * vec4(worldPosition, 1.0);\r\n\r\n    }\r\n}',fragmentShader:u,blending:i.NTi,side:i.$EB,depthWrite:!0}),[w,b,a]);return(0,l.useEffect)(()=>{if(_){let e=_.uniforms;e.map.value=n,e.animateProg.value=x,e.displaceZero.value=-o.minVal/(o.maxVal-o.minVal),e.displacement.value=y,e.cmap.value=t,e.cOffset.value=v,e.cScale.value=h,e.displaceZero.value=z?0:-o.minVal/(o.maxVal-o.minVal)}(0,f.m)()},[x,o,y,t,h,v,z,n]),(0,r.jsx)("instancedMesh",{scale:[1,s?-1:1,1],args:[I,_,w*b],frustumCulled:!1})};i.l2R.enabled=!0;let ek=function(){let{initStore:e,timeSeries:n,variable:t,plotOn:i,setZMeta:s,setVariables:u,setPlotOn:f,setTitleDescription:m}=(0,c.on)((0,d.k)(e=>({initStore:e.initStore,timeSeries:e.timeSeries,variable:e.variable,plotOn:e.plotOn,setZMeta:e.setZMeta,setVariables:e.setVariables,setPlotOn:e.setPlotOn,setTitleDescription:e.setTitleDescription}))),{currentStore:p,setCurrentStore:x,setZSlice:v,setYSlice:h,setXSlice:S}=(0,c.SZ)((0,d.k)(e=>({currentStore:e.currentStore,setCurrentStore:e.setCurrentStore,setZSlice:e.setZSlice,setYSlice:e.setYSlice,setXSlice:e.setXSlice})));(0,l.useEffect)(()=>{v([0,null]),h([0,null]),S([0,null]),e.startsWith("local")||x((0,o.Oe)(e))},[e,x]);let g=(0,l.useMemo)(()=>new o.Y5(p),[p]);return(0,l.useEffect)(()=>{let e=!0;(0,a.tz)(p).then(n=>{e&&m(n)});let n=(0,a.Tk)(p),t=(0,a.Bi)(n);return n.then(e=>s(e)),t.then(e=>u(e)),()=>{e=!1}},[p,s,u,m]),(0,r.jsxs)(r.Fragment,{children:[(0,r.jsx)(y.oU,{}),"Default"==t&&(0,r.jsx)(eD,{}),(0,r.jsx)(y.$D,{}),!i&&(0,r.jsx)(y.Fp,{}),(0,r.jsx)(y.Rh,{}),"Default"!=t&&(0,r.jsx)(es,{ZarrDS:g}),Object.keys(n).length>=1&&(0,r.jsx)(E,{})]})}},4634:()=>{},7343:()=>{},8365:()=>{},8533:(e,n,t)=>{Promise.resolve().then(t.bind(t,1931))}},e=>{e.O(0,[172,645,863,99,969,925,478,11,432,667,60,544,235,103,459,195,100,970,984,790,340,324,495,212,868,702,358],()=>e(e.s=8533)),_N_E=e.O()}]);